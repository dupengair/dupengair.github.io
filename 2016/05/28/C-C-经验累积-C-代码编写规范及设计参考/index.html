<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="keep it simple, stupid"><title>C++代码编写规范及设计参考 | dupengair的blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/3.0.3/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">C++代码编写规范及设计参考</h1><a id="logo" href="/.">dupengair的blog</a><p class="description">日拱一卒 精而悟道</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">C++代码编写规范及设计参考</h1><div class="post-meta">May 28, 2016<span> | </span><span class="category"><a href="/categories/C-C-经验累积/">C&amp;C++经验累积</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-代码编写规范及设计参考"><span class="toc-number">1.</span> <span class="toc-text">C++代码编写规范及设计参考</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#目录"><span class="toc-number">2.</span> <span class="toc-text">[目录]</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第一章-简介"><span class="toc-number">3.</span> <span class="toc-text">[第一章 简介]</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-1-说明"><span class="toc-number">4.</span> <span class="toc-text">1.1 说明</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-2-基本原则"><span class="toc-number">5.</span> <span class="toc-text">1.2 基本原则</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-3-前提"><span class="toc-number">6.</span> <span class="toc-text">1.3 前提</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第一部分：基础部分：C-代码编写规范"><span class="toc-number">7.</span> <span class="toc-text">第一部分：基础部分：C++代码编写规范</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第二章-头文件"><span class="toc-number">8.</span> <span class="toc-text">[第二章 头文件]</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-1-使用-define防止重复编译"><span class="toc-number">9.</span> <span class="toc-text">2.1 使用#define防止重复编译</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-2-降低头文件依赖"><span class="toc-number">10.</span> <span class="toc-text">2.2 降低头文件依赖</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-3-内联函数"><span class="toc-number">11.</span> <span class="toc-text">2.3 内联函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-4-lt-inline-gt-h头文件"><span class="toc-number">12.</span> <span class="toc-text">2.4 _<inline>.h头文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-5-函数参数顺序"><span class="toc-number">13.</span> <span class="toc-text">2.5 函数参数顺序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-6-包含文件的名称及次序"><span class="toc-number">14.</span> <span class="toc-text">2.6 包含文件的名称及次序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-7-Summary"><span class="toc-number">15.</span> <span class="toc-text">2.7 Summary</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第三章-作用域"><span class="toc-number">16.</span> <span class="toc-text">[第三章 作用域]</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-1命名空间（Namespaces）"><span class="toc-number">17.</span> <span class="toc-text">3.1命名空间（Namespaces）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-2-嵌套类（Nested-Class）"><span class="toc-number">18.</span> <span class="toc-text">3.2 嵌套类（Nested Class）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-3-非成员函数（Nonmember）、静态成员函数（Static-Member）和全局函数（Global-Functions）"><span class="toc-number">19.</span> <span class="toc-text">3.3 非成员函数（Nonmember）、静态成员函数（Static Member）和全局函数（Global Functions）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-4-局部变量（Local-Variables）"><span class="toc-number">20.</span> <span class="toc-text">3.4. 局部变量（Local Variables）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-5-全局变量（Global-Variables）"><span class="toc-number">21.</span> <span class="toc-text">3.5 全局变量（Global Variables）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-6-Summary"><span class="toc-number">22.</span> <span class="toc-text">3.6 Summary</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第四章-C-类"><span class="toc-number">23.</span> <span class="toc-text">[第四章 C++类]</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-1-构造函数（Constructor）的职责"><span class="toc-number">24.</span> <span class="toc-text">4.1 构造函数（Constructor）的职责</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-2-默认构造函数（Default-Constructors）"><span class="toc-number">25.</span> <span class="toc-text">4.2 默认构造函数（Default Constructors）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-3-显式构造函数（Explicit-Constructors）"><span class="toc-number">26.</span> <span class="toc-text">4.3 显式构造函数（Explicit Constructors）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-4-拷贝构造函数（Copy-Constructors）"><span class="toc-number">27.</span> <span class="toc-text">4.4 拷贝构造函数（Copy Constructors）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-5-结构体和类（Structs-vs-Classes）"><span class="toc-number">28.</span> <span class="toc-text">4.5 结构体和类（Structs vs. Classes）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-6-继承（Inheritance）"><span class="toc-number">29.</span> <span class="toc-text">4.6 继承（Inheritance）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-7-多重继承（Multiple-Inheritance）"><span class="toc-number">30.</span> <span class="toc-text">4.7 多重继承（Multiple Inheritance）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-8-接口类（Interface）"><span class="toc-number">31.</span> <span class="toc-text">4.8 接口类（Interface）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-9-操作符重载（Operator-Overloading）"><span class="toc-number">32.</span> <span class="toc-text">4.9 操作符重载（Operator Overloading）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-10-存取控制（Access-Control）"><span class="toc-number">33.</span> <span class="toc-text">4.10 存取控制（Access Control）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-11-声明次序（Declaration-Order）"><span class="toc-number">34.</span> <span class="toc-text">4.11 声明次序（Declaration Order）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-12-编写短小函数（Write-Short-Functions）"><span class="toc-number">35.</span> <span class="toc-text">4.12 编写短小函数（Write Short Functions）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-13-Summary"><span class="toc-number">36.</span> <span class="toc-text">4.13 Summary</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-1-智能指针（Smart-Pointers）"><span class="toc-number">37.</span> <span class="toc-text">5.1 智能指针（Smart Pointers）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-2-引用参数（Reference-Arguments）"><span class="toc-number">38.</span> <span class="toc-text">5.2 引用参数（Reference Arguments）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-3-函数重载（Function-Overloading）"><span class="toc-number">39.</span> <span class="toc-text">5.3 函数重载（Function Overloading）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-4-缺省参数（Default-Arguments）"><span class="toc-number">40.</span> <span class="toc-text">5.4 缺省参数（Default Arguments）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-5-变长数组和C-style-allocator（Variable-Length-Arrays-and-C-style-allocator）"><span class="toc-number">41.</span> <span class="toc-text">5.5 变长数组和C style allocator（Variable-Length Arrays and C style allocator）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-6-友元（Friends）"><span class="toc-number">42.</span> <span class="toc-text">5.6 友元（Friends）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-7-异常（Exceptions）"><span class="toc-number">43.</span> <span class="toc-text">5.7 异常（Exceptions）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-8-运行时类型识别（Run-Time-Type-Information-RTTI）"><span class="toc-number">44.</span> <span class="toc-text">5.8 运行时类型识别（Run-Time Type Information, RTTI）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-9-类型转换（Casting）"><span class="toc-number">45.</span> <span class="toc-text">5.9 类型转换（Casting）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-10-流（Streams）"><span class="toc-number">46.</span> <span class="toc-text">5.10 流（Streams）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-11-前置自增和自减（Preincrement-and-Predecrement）"><span class="toc-number">47.</span> <span class="toc-text">5.11 前置自增和自减（Preincrement and Predecrement）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-12-const的使用（Use-of-const）"><span class="toc-number">48.</span> <span class="toc-text">5.12 const的使用（Use of const）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-13-整型（Integer-Types）"><span class="toc-number">49.</span> <span class="toc-text">5.13 整型（Integer Types）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-14-预处理宏（Preprocessor-Macros）"><span class="toc-number">50.</span> <span class="toc-text">5.14 预处理宏（Preprocessor Macros）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-15-0和NULL（0-and-NULL）"><span class="toc-number">51.</span> <span class="toc-text">5.15 0和NULL（0 and NULL）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-16-sizeof（sizeof）"><span class="toc-number">52.</span> <span class="toc-text">5.16 sizeof（sizeof）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-17-Boost库（Boost）"><span class="toc-number">53.</span> <span class="toc-text">5.17 Boost库（Boost）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-18-Summary"><span class="toc-number">54.</span> <span class="toc-text">5.18 Summary</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-1-通用命名规则（General-Naming-Rules）"><span class="toc-number">55.</span> <span class="toc-text">6.1 通用命名规则（General Naming Rules）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-2-文件命名（File-Names）"><span class="toc-number">56.</span> <span class="toc-text">6.2 文件命名（File Names）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-3-类型命名（Type-Names）"><span class="toc-number">57.</span> <span class="toc-text">6.3 类型命名（Type Names）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-4-变量命名（Variable-Names）"><span class="toc-number">58.</span> <span class="toc-text">6.4 变量命名（Variable Names）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-5-常量命名（Constant-Names）"><span class="toc-number">59.</span> <span class="toc-text">6.5 常量命名（Constant Names）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-6-函数命名（Function-Names）"><span class="toc-number">60.</span> <span class="toc-text">6.6 函数命名（Function Names）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-7-命名空间（Namespace-Names）"><span class="toc-number">61.</span> <span class="toc-text">6.7 命名空间（Namespace Names）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-8-枚举命名（Enumerator-Names）"><span class="toc-number">62.</span> <span class="toc-text">6.8 枚举命名（Enumerator Names）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-9-宏命名（Macro-Names）"><span class="toc-number">63.</span> <span class="toc-text">6.9 宏命名（Macro Names）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-10例外（Exceptions）"><span class="toc-number">64.</span> <span class="toc-text">6.10例外（Exceptions）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-11-Summary"><span class="toc-number">65.</span> <span class="toc-text">6.11 Summary</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-1-注释风格（Comment-Style）"><span class="toc-number">66.</span> <span class="toc-text">7.1 注释风格（Comment Style）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-2-文件注释（File-Comments）"><span class="toc-number">67.</span> <span class="toc-text">7.2 文件注释（File Comments）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-3-类注释（Class-Comments）"><span class="toc-number">68.</span> <span class="toc-text">7.3 类注释（Class Comments）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-4-函数注释（Function-Comments）"><span class="toc-number">69.</span> <span class="toc-text">7.4 函数注释（Function Comments）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-5-变量注释（Variable-Comments）"><span class="toc-number">70.</span> <span class="toc-text">7.5 变量注释（Variable Comments）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-6-实现注释（Implementation-Comments）"><span class="toc-number">71.</span> <span class="toc-text">7.6 实现注释（Implementation Comments）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-7-标点、拼写和语法（Punctuation-Spelling-and-Grammar）"><span class="toc-number">72.</span> <span class="toc-text">7.7  标点、拼写和语法（Punctuation, Spelling and Grammar）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-8-TODO注释（TODO-Comments）"><span class="toc-number">73.</span> <span class="toc-text">7.8 TODO注释（TODO Comments）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-9-Summary"><span class="toc-number">74.</span> <span class="toc-text">7.9 Summary</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-1-行长度（Line-Length）"><span class="toc-number">75.</span> <span class="toc-text">8.1 行长度（Line Length）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-2-非ASCII字符（Non-ASCII-Characters）"><span class="toc-number">76.</span> <span class="toc-text">8.2 非ASCII字符（Non-ASCII Characters）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-3-空格还是制表位（Spaces-vs-Tabs）"><span class="toc-number">77.</span> <span class="toc-text">8.3 空格还是制表位（Spaces vs. Tabs）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-4-函数声明与定义（Function-Declarations-and-Definitions）"><span class="toc-number">78.</span> <span class="toc-text">8.4 函数声明与定义（Function Declarations and Definitions）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-5-函数调用（Function-Calls）"><span class="toc-number">79.</span> <span class="toc-text">8.5 函数调用（Function Calls）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-6-条件语句（Conditionals）"><span class="toc-number">80.</span> <span class="toc-text">8.6 条件语句（Conditionals）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-7-循环和开关选择语句（Loops-and-Switch-Statements）"><span class="toc-number">81.</span> <span class="toc-text">8.7 循环和开关选择语句（Loops and Switch Statements）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-8-指针和引用表达式（Pointers-and-Reference-Expressions）"><span class="toc-number">82.</span> <span class="toc-text">8.8 指针和引用表达式（Pointers and Reference Expressions）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-9-布尔表达式（Boolean-Expressions）"><span class="toc-number">83.</span> <span class="toc-text">8.9 布尔表达式（Boolean Expressions）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-10-函数返回值（Return-Values）"><span class="toc-number">84.</span> <span class="toc-text">8.10 函数返回值（Return Values）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-11-变量及数组初始化（Variable-and-Array-Initialization）"><span class="toc-number">85.</span> <span class="toc-text">8.11 变量及数组初始化（Variable and Array Initialization）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-12-预处理指令（Preprocessor-Directives）"><span class="toc-number">86.</span> <span class="toc-text">8.12 预处理指令（Preprocessor Directives）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-13-类格式（Class-Format）"><span class="toc-number">87.</span> <span class="toc-text">8.13 类格式（Class Format）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-15-命名空间格式化（Namespace-Formatting）"><span class="toc-number">88.</span> <span class="toc-text">8.15 命名空间格式化（Namespace Formatting）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-16-水平空白（Horizontal-Whitespace）"><span class="toc-number">89.</span> <span class="toc-text">8.16 水平空白（Horizontal Whitespace）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-17-垂直空白（Vertical-Whitespace）"><span class="toc-number">90.</span> <span class="toc-text">8.17 垂直空白（Vertical Whitespace）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-18-Summary"><span class="toc-number">91.</span> <span class="toc-text">8.18 Summary</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-19-补充"><span class="toc-number">92.</span> <span class="toc-text">8.19 补充</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-1-名字空间"><span class="toc-number">93.</span> <span class="toc-text">9.1  名字空间</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-1-1-只有namespace的声明才能是全局声明"><span class="toc-number">94.</span> <span class="toc-text">9.1.1 只有namespace的声明才能是全局声明</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-1-2-使用名字空间划分非类功能"><span class="toc-number">95.</span> <span class="toc-text">9.1.2 使用名字空间划分非类功能</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-2-类"><span class="toc-number">96.</span> <span class="toc-text">9.2  类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-2-1-使用-class-而不是-struct-来实现抽象数据类型"><span class="toc-number">97.</span> <span class="toc-text">9.2.1 使用 class 而不是 struct 来实现抽象数据类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-2-2-以可访问权限逐次降低的顺序声明类的成员"><span class="toc-number">98.</span> <span class="toc-text">9.2.2 以可访问权限逐次降低的顺序声明类的成员</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-2-3-抽象数据类型避免声明public或protected数据成员"><span class="toc-number">99.</span> <span class="toc-text">9.2.3 抽象数据类型避免声明public或protected数据成员</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-2-4-使用友元保留封装性"><span class="toc-number">100.</span> <span class="toc-text">9.2.4 使用友元保留封装性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-2-5-避免在类声明中定义函数"><span class="toc-number">101.</span> <span class="toc-text">9.2.5 避免在类声明中定义函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-2-6-为明确声明构造函数的类提供默认构造函数"><span class="toc-number">102.</span> <span class="toc-text">9.2.6 为明确声明构造函数的类提供默认构造函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-2-7-带有指针类型数据成员的类要声明其复制构造函数和赋值操作符"><span class="toc-number">103.</span> <span class="toc-text">9.2.7 带有指针类型数据成员的类要声明其复制构造函数和赋值操作符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-2-8-不要重新声明构造函数参数使其有默认值"><span class="toc-number">104.</span> <span class="toc-text">9.2.8 不要重新声明构造函数参数使其有默认值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-2-9-将析构函数总是声明为-virtual-类型"><span class="toc-number">105.</span> <span class="toc-text">9.2.9 将析构函数总是声明为 virtual 类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-2-10-避免声明太多的转换操作符和单参数构造函数"><span class="toc-number">106.</span> <span class="toc-text">9.2.10            避免声明太多的转换操作符和单参数构造函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-2-11-不要重定义非虚函数"><span class="toc-number">107.</span> <span class="toc-text">9.2.11            不要重定义非虚函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-2-12-谨慎使用非虚函数"><span class="toc-number">108.</span> <span class="toc-text">9.2.12            谨慎使用非虚函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-2-13-在构造函数中使用构造函数初始化而不使用赋值语句"><span class="toc-number">109.</span> <span class="toc-text">9.2.13            在构造函数中使用构造函数初始化而不使用赋值语句</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-2-14-构造函数初始化时不要调用成员函数"><span class="toc-number">110.</span> <span class="toc-text">9.2.14            构造函数初始化时不要调用成员函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-2-15-注意构造函数和析构函数调用成员函数时的情况"><span class="toc-number">111.</span> <span class="toc-text">9.2.15            注意构造函数和析构函数调用成员函数时的情况</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-2-16-整形类常量使用-static-const"><span class="toc-number">112.</span> <span class="toc-text">9.2.16            整形类常量使用 static const</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-3-函数"><span class="toc-number">113.</span> <span class="toc-text">9.3  函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-3-1-一定要明确声明函数的返回值类型"><span class="toc-number">114.</span> <span class="toc-text">9.3.1 一定要明确声明函数的返回值类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-3-2-函数声明中要提供正式参数名称"><span class="toc-number">115.</span> <span class="toc-text">9.3.2 函数声明中要提供正式参数名称</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-3-3-函数要尽量只有一个返回点"><span class="toc-number">116.</span> <span class="toc-text">9.3.3 函数要尽量只有一个返回点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-3-4-避免创建对全局有副作用的函数"><span class="toc-number">117.</span> <span class="toc-text">9.3.4 避免创建对全局有副作用的函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-3-5-以重要性和活跃性递减的顺序声明函数的参数"><span class="toc-number">118.</span> <span class="toc-text">9.3.5 以重要性和活跃性递减的顺序声明函数的参数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-3-6-避免声明带有不定参数个数的函数"><span class="toc-number">119.</span> <span class="toc-text">9.3.6 避免声明带有不定参数个数的函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-3-7-避免重新声明带有默认参数的函数"><span class="toc-number">120.</span> <span class="toc-text">9.3.7 避免重新声明带有默认参数的函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-3-8-函数声明中尽可能多地使用-const"><span class="toc-number">121.</span> <span class="toc-text">9.3.8 函数声明中尽可能多地使用 const</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-3-9-避免利用值传递对象"><span class="toc-number">122.</span> <span class="toc-text">9.3.9 避免利用值传递对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-3-10-不能返回对局部对象的引用"><span class="toc-number">123.</span> <span class="toc-text">9.3.10            不能返回对局部对象的引用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-3-11-不可返回由-new-初始化的de-referenced指针"><span class="toc-number">124.</span> <span class="toc-text">9.3.11            不可返回由 new 初始化的de-referenced指针</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-3-12-不要返回对成员数据的非常量引用或指向成员数据的指针"><span class="toc-number">125.</span> <span class="toc-text">9.3.12            不要返回对成员数据的非常量引用或指向成员数据的指针</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-3-13-使用内嵌定义函数而不使用-define-来实现宏扩展功能"><span class="toc-number">126.</span> <span class="toc-text">9.3.13            使用内嵌定义函数而不使用 #define 来实现宏扩展功能</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-3-15-使用函数重载表达常用语义"><span class="toc-number">127.</span> <span class="toc-text">9.3.15            使用函数重载表达常用语义</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-3-16-避免重载以指针和整形数为实参的函数"><span class="toc-number">128.</span> <span class="toc-text">9.3.16            避免重载以指针和整形数为实参的函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-3-17-操作符-operator-必须返回对-this-的引用"><span class="toc-number">129.</span> <span class="toc-text">9.3.17            操作符 operator= 必须返回对 *this 的引用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-3-18-在-operator-中必须检查自赋值"><span class="toc-number">130.</span> <span class="toc-text">9.3.18            在 operator=中必须检查自赋值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-3-19-尽可能减少复杂性"><span class="toc-number">131.</span> <span class="toc-text">9.3.19            尽可能减少复杂性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-4-类型"><span class="toc-number">132.</span> <span class="toc-text">9.4  类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-4-1-定义项目范围的全局系统类型"><span class="toc-number">133.</span> <span class="toc-text">9.4.1 定义项目范围的全局系统类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-4-2-避免使用基本类型"><span class="toc-number">134.</span> <span class="toc-text">9.4.2 避免使用基本类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-4-3-使用-typedef-创建同义词来加强局部含义"><span class="toc-number">135.</span> <span class="toc-text">9.4.3 使用 typedef 创建同义词来加强局部含义</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-5-常量与对象"><span class="toc-number">136.</span> <span class="toc-text">9.5  常量与对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-5-1-避免使用字符串值"><span class="toc-number">137.</span> <span class="toc-text">9.5.1 避免使用字符串值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-5-2-避免使用-define-预处理指示符来定义常量"><span class="toc-number">138.</span> <span class="toc-text">9.5.2 避免使用 #define 预处理指示符来定义常量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-5-3-对象声明靠近其第一次使用点"><span class="toc-number">139.</span> <span class="toc-text">9.5.3 对象声明靠近其第一次使用点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-5-4-声明时总要初始化-const-对象"><span class="toc-number">140.</span> <span class="toc-text">9.5.4 声明时总要初始化 const 对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-5-5-永远不要cast掉常量对象的“不变性”"><span class="toc-number">141.</span> <span class="toc-text">9.5.5 永远不要cast掉常量对象的“不变性”</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-5-6-定义时初始化对象"><span class="toc-number">142.</span> <span class="toc-text">9.5.6 定义时初始化对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-1-表达式"><span class="toc-number">143.</span> <span class="toc-text">10.1                  表达式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-1-1-使用冗余的圆括号使复合表达式含义更加清晰"><span class="toc-number">144.</span> <span class="toc-text">10.1.1             使用冗余的圆括号使复合表达式含义更加清晰</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-1-2-避免表达式的过深嵌套"><span class="toc-number">145.</span> <span class="toc-text">10.1.2             避免表达式的过深嵌套</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-1-3-不要假定任何特殊的表达式计算次序"><span class="toc-number">146.</span> <span class="toc-text">10.1.3             不要假定任何特殊的表达式计算次序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-1-5-不要使用旧式的类型转换"><span class="toc-number">147.</span> <span class="toc-text">10.1.5             不要使用旧式的类型转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-1-6-Boolean（布尔）表达式使用新的-bool-类型"><span class="toc-number">148.</span> <span class="toc-text">10.1.6             Boolean（布尔）表达式使用新的 bool 类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-1-7-不要直接与布尔值-true（真）做比较"><span class="toc-number">149.</span> <span class="toc-text">10.1.7             不要直接与布尔值 true（真）做比较</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-1-8-不在同一数组中的对象的指针不要做比较"><span class="toc-number">150.</span> <span class="toc-text">10.1.8             不在同一数组中的对象的指针不要做比较</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-1-9-已删除的对象指针要赋予空指针值"><span class="toc-number">151.</span> <span class="toc-text">10.1.9             已删除的对象指针要赋予空指针值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-2-语句"><span class="toc-number">152.</span> <span class="toc-text">10.2                  语句</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-2-1-当分支条件为布尔表达式时使用-if-语句"><span class="toc-number">153.</span> <span class="toc-text">10.2.1             当分支条件为布尔表达式时使用 if 语句</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-2-2-当分支条件为离散时使用-switch-语句"><span class="toc-number">154.</span> <span class="toc-text">10.2.2             当分支条件为离散时使用 switch 语句</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-2-3-一定为-switch-语句提供一个-default-分支以捕获错误"><span class="toc-number">155.</span> <span class="toc-text">10.2.3             一定为 switch 语句提供一个 default 分支以捕获错误</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-2-4-当循环需要迭代前测试时使用-for-语句或-while-语句"><span class="toc-number">156.</span> <span class="toc-text">10.2.4             当循环需要迭代前测试时使用 for 语句或 while 语句</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-2-5-当循环需要迭代后测试时使用-do-while-语句"><span class="toc-number">157.</span> <span class="toc-text">10.2.5             当循环需要迭代后测试时使用 do while 语句</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-2-6-循环中避免使用-jump-语句"><span class="toc-number">158.</span> <span class="toc-text">10.2.6             循环中避免使用 jump 语句</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-2-7-不要使用-goto-语句"><span class="toc-number">159.</span> <span class="toc-text">10.2.7             不要使用 goto 语句</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-2-8-避免嵌套作用域内隐藏标识符"><span class="toc-number">160.</span> <span class="toc-text">10.2.8             避免嵌套作用域内隐藏标识符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-1-内存管理"><span class="toc-number">161.</span> <span class="toc-text">11.1                  内存管理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-1-1-避免混合使用C-和-C-内存操作"><span class="toc-number">162.</span> <span class="toc-text">11.1.1             避免混合使用C 和 C++ 内存操作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-1-2-删除由-new-创建的数组对象时总使用-delete"><span class="toc-number">163.</span> <span class="toc-text">11.1.2             删除由 new 创建的数组对象时总使用 delete[]</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-2-错误处理和异常"><span class="toc-number">164.</span> <span class="toc-text">11.2                  错误处理和异常</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-2-1-开发过程中多使用“断言语句”以发现错误"><span class="toc-number">165.</span> <span class="toc-text">11.2.1             开发过程中多使用“断言语句”以发现错误</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-2-2-只在确实是异常的情况下使用异常"><span class="toc-number">166.</span> <span class="toc-text">11.2.2             只在确实是异常的情况下使用异常</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-2-3-从标准异常中派生项目自己的异常"><span class="toc-number">167.</span> <span class="toc-text">11.2.3             从标准异常中派生项目自己的异常</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-2-4-给定抽象尽量少使用异常"><span class="toc-number">168.</span> <span class="toc-text">11.2.4             给定抽象尽量少使用异常</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-2-5-将所有异常声明为thrown"><span class="toc-number">169.</span> <span class="toc-text">11.2.5             将所有异常声明为thrown</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-2-6-在异常首次出现时就报告它"><span class="toc-number">170.</span> <span class="toc-text">11.2.6             在异常首次出现时就报告它</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-2-7-按照从派生结构最底端到最顶端的顺序定义异常处理"><span class="toc-number">171.</span> <span class="toc-text">11.2.7             按照从派生结构最底端到最顶端的顺序定义异常处理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-2-8-避免使用捕获所有异常的处理过程"><span class="toc-number">172.</span> <span class="toc-text">11.2.8             避免使用捕获所有异常的处理过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-2-9-确保函数状态代码有合适的值"><span class="toc-number">173.</span> <span class="toc-text">11.2.9             确保函数状态代码有合适的值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-2-10-本地执行安全检查；不要希望您的客户会这样做"><span class="toc-number">174.</span> <span class="toc-text">11.2.10         本地执行安全检查；不要希望您的客户会这样做</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-1-路径名"><span class="toc-number">175.</span> <span class="toc-text">12.1                  路径名</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-1-1-不要使用硬编码的文件路径名"><span class="toc-number">176.</span> <span class="toc-text">12.1.1             不要使用硬编码的文件路径名</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-2-数据表示"><span class="toc-number">177.</span> <span class="toc-text">12.2                  数据表示</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-2-1-不要对类型的表示做假设"><span class="toc-number">178.</span> <span class="toc-text">12.2.1             不要对类型的表示做假设</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-2-2-不要对类型的alignment作假设"><span class="toc-number">179.</span> <span class="toc-text">12.2.2             不要对类型的alignment作假设</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-2-3-不要依赖于一个特殊的下溢或上溢行为"><span class="toc-number">180.</span> <span class="toc-text">12.2.3             不要依赖于一个特殊的下溢或上溢行为</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-2-4-尽可能使用“可伸缩”常量"><span class="toc-number">181.</span> <span class="toc-text">12.2.4             尽可能使用“可伸缩”常量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-3-类型转换"><span class="toc-number">182.</span> <span class="toc-text">12.3                  类型转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-3-1-不要从一个“短”类型转换成一个“长类型”"><span class="toc-number">183.</span> <span class="toc-text">12.3.1             不要从一个“短”类型转换成一个“长类型”</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-1-尽可能使用标准库构件"><span class="toc-number">184.</span> <span class="toc-text">13.1                  尽可能使用标准库构件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-2-使用template实现独立于数据的行为的复用"><span class="toc-number">185.</span> <span class="toc-text">13.2                  使用template实现独立于数据的行为的复用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-3-使用公共继承复用类接口（子类型化）"><span class="toc-number">186.</span> <span class="toc-text">13.3                  使用公共继承复用类接口（子类型化）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-4-使用包含而不是私有继承复用类的实现"><span class="toc-number">187.</span> <span class="toc-text">13.4                  使用包含而不是私有继承复用类的实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-5-谨慎使用多继承"><span class="toc-number">188.</span> <span class="toc-text">13.5                  谨慎使用多继承</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-1-尽量减少对编译的依赖"><span class="toc-number">189.</span> <span class="toc-text">14.1                  尽量减少对编译的依赖</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-2-用具体值定义-NDEBUG"><span class="toc-number">190.</span> <span class="toc-text">14.2                  用具体值定义 NDEBUG</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-3-采用统一的系统配置头文件compiler-h"><span class="toc-number">191.</span> <span class="toc-text">14.3                  采用统一的系统配置头文件compiler.h</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-1-参考文献"><span class="toc-number">192.</span> <span class="toc-text">15.1                  参考文献</span></a></li></ol></div></div><div class="post-content"><h1 id="C-代码编写规范及设计参考"><a href="#C-代码编写规范及设计参考" class="headerlink" title="C++代码编写规范及设计参考"></a>C++代码编写规范及设计参考</h1><ul>
<li>杜鹏</li>
<li>2013-09-30</li>
</ul>
<h1 id="目录"><a href="#目录" class="headerlink" title="[目录]"></a><strong>[目录]</strong></h1><pre><code>第一章 简介................................................................................................................... 7

1.1 说明....................................................................................................................... 7
1.2 基本原则................................................................................................................ 7
1.3 前提....................................................................................................................... 8
第一部分：基础部分：C++代码编写规范...................................................................... 9

第二章 头文件.............................................................................................................. 10

2.1 使用#define防止重复编译.................................................................................... 10
2.2 降低头文件依赖.................................................................................................... 10
2.3 内联函数............................................................................................................... 11
2.4 _&lt;inline&gt;.h头文件................................................................................................ 11
第三章 作用域.............................................................................................................. 14

3.1命名空间（Namespaces）...................................................................................... 14
3.2 嵌套类（Nested Class）...................................................................................... 16
3.3 非成员函数（Nonmember）、静态成员函数（Static Member）和全局函数（Global Functions）   16
3.4. 局部变量（Local Variables）............................................................................. 17
3.5 全局变量（Global Variables）............................................................................ 18
3.6 Summary............................................................................................................... 18
第四章 C++类............................................................................................................... 19

4.1 构造函数（Constructor）的职责......................................................................... 19
4.2 默认构造函数（Default Constructors）............................................................. 19
4.3 显式构造函数（Explicit Constructors）............................................................. 20
4.4 拷贝构造函数（Copy Constructors）.................................................................. 20
4.5 结构体和类（Structs vs. Classes）..................................................................... 21
4.6 继承（Inheritance）............................................................................................ 21
4.7 多重继承（Multiple Inheritance）...................................................................... 22
4.8 接口类（Interface）............................................................................................ 22
4.9 操作符重载（Operator Overloading）................................................................ 23
4.10 存取控制（Access Control）............................................................................. 24
4.11 声明次序（Declaration Order）........................................................................ 24
4.12 编写短小函数（Write Short Functions）........................................................... 24
4.13 Summary............................................................................................................. 25
第五章 智能指针和其他C++特性................................................................................ 26

5.1 智能指针（Smart Pointers）............................................................................... 26
5.2 引用参数（Reference Arguments）..................................................................... 26
5.3 函数重载（Function Overloading）.................................................................... 27
5.4 缺省参数（Default Arguments）......................................................................... 27
5.5 变长数组和C style allocator（Variable-Length Arrays and C style allocator） 28
5.6 友元（Friends）................................................................................................... 28
5.7 异常（Exceptions）............................................................................................. 28
5.8 运行时类型识别（Run-Time Type Information, RTTI）......................................... 29
5.9 类型转换（Casting）........................................................................................... 30
5.10 流（Streams）................................................................................................... 30
5. 11 前置自增和自减（Preincrement and Predecrement）....................................... 31
5.12 const的使用（Use of const）............................................................................. 31
5.13 整型（Integer Types）....................................................................................... 32
5.14 预处理宏（Preprocessor Macros）.................................................................... 33
5. 15 0和NULL（0 and NULL）.................................................................................. 33
5.16 sizeof（sizeof）................................................................................................. 34
5.17 Boost库（Boost）............................................................................................. 34
5.18 Summary............................................................................................................. 34
第六章 命名约定.......................................................................................................... 36

6.1 通用命名规则（General Naming Rules）............................................................ 36
6.2 文件命名（File Names）...................................................................................... 37
6.3 类型命名（Type Names）..................................................................................... 37
6.4 变量命名（Variable Names）............................................................................... 38
6.5 常量命名（Constant Names）.............................................................................. 38
6.6 函数命名（Function Names）.............................................................................. 38
6.7 命名空间（Namespace Names）............................................................................ 39
6.8 枚举命名（Enumerator Names）......................................................................... 39
6.9 宏命名（Macro Names）...................................................................................... 40
6.10例外（Exceptions）............................................................................................ 40
6.11 Summary............................................................................................................. 40
第七章 代码注释.......................................................................................................... 41

7.1 注释风格（Comment Style）............................................................................... 41
7.2 文件注释（File Comments）................................................................................ 41
7.3 类注释（Class Comments）................................................................................. 42
7.4 函数注释（Function Comments）........................................................................ 42
7.5 变量注释（Variable Comments）......................................................................... 43
7.6 实现注释（Implementation Comments）.............................................................. 44
7.7  标点、拼写和语法（Punctuation, Spelling and Grammar）............................... 45
7.8 TODO注释（TODO Comments）.......................................................................... 46
7.9 Summary............................................................................................................... 46
第八章 格式................................................................................................................. 47

8.1 行长度（Line Length）........................................................................................ 47
8.2 非ASCII字符（Non-ASCII Characters）............................................................ 47
8.3 空格还是制表位（Spaces vs. Tabs）...................................................................... 48
8.4 函数声明与定义（Function Declarations and Definitions）............................... 48
8.5 函数调用（Function Calls）............................................................................... 50
8.6 条件语句（Conditionals）.................................................................................. 50
8.7 循环和开关选择语句（Loops and Switch Statements）........................................ 52
8.8 指针和引用表达式（Pointers and Reference Expressions）................................. 53
8.9 布尔表达式（Boolean Expressions）................................................................... 53
8.10 函数返回值（Return Values）........................................................................... 54
8.11 变量及数组初始化（Variable and Array Initialization）................................... 54
8.12 预处理指令（Preprocessor Directives）............................................................ 54
8.13 类格式（Class Format）.................................................................................... 55
8.14 初始化列表（Initializer Lists）......................................................................... 56
8.15 命名空间格式化（Namespace Formatting）....................................................... 56
8.16 水平空白（Horizontal Whitespace）................................................................. 57
8. 17 垂直空白（Vertical Whitespace）.................................................................... 58
8.18 Summary............................................................................................................. 59
8.19 补充.................................................................................................................... 59
第二部分 高级主题：C++设计参考............................................................................. 60

第9章         声明............................................................................................................. 61

9.1        名字空间.......................................................................................................... 61
9.1.1         只有namespace的声明才能是全局声明...................................................... 61
9.1.2         使用名字空间划分非类功能....................................................................... 61
9.1.3         尽量不使用全局和名字空间范围的数据。.................................................. 61
9.2        类.................................................................................................................... 61
9.2.1         使用 class 而不是 struct 来实现抽象数据类型........................................... 62
9.2.2         以可访问权限逐次降低的顺序声明类的成员.............................................. 62
9.2.3         抽象数据类型避免声明public或protected数据成员.................................... 62
9.2.4         使用友元保留封装性................................................................................. 62
9.2.5         避免在类声明中定义函数.......................................................................... 63
9.2.6         为明确声明构造函数的类提供默认构造函数.............................................. 63
9.2.7         带有指针类型数据成员的类要声明其复制构造函数和赋值操作符............... 63
9.2.8         不要重新声明构造函数参数使其有默认值.................................................. 64
9.2.9         将析构函数总是声明为 virtual 类型.......................................................... 65
9.2.10       避免声明太多的转换操作符和单参数构造函数........................................... 66
9.2.11       不要重定义非虚函数................................................................................. 66
9.2.12       谨慎使用非虚函数..................................................................................... 67
9.2.13       在构造函数中使用构造函数初始化而不使用赋值语句................................ 67
9.2.14       构造函数初始化时不要调用成员函数......................................................... 68
9.2.15       注意构造函数和析构函数调用成员函数时的情况....................................... 68
9.2.16       整形类常量使用 static const....................................................................... 68
9.3        函数................................................................................................................. 69
9.3.1         一定要明确声明函数的返回值类型............................................................ 69
9.3.2         函数声明中要提供正式参数名称................................................................ 69
9.3.3         函数要尽量只有一个返回点....................................................................... 69
9.3.4         避免创建对全局有副作用的函数................................................................ 70
9.3.5         以重要性和活跃性递减的顺序声明函数的参数........................................... 70
9.3.6         避免声明带有不定参数个数的函数............................................................ 70
9.3.7         避免重新声明带有默认参数的函数............................................................ 70
9.3.8         函数声明中尽可能多地使用 const.............................................................. 70
9.3.9         避免利用值传递对象................................................................................. 71
9.3.10       不能返回对局部对象的引用....................................................................... 72
9.3.11       不可返回由 new 初始化的de-referenced指针............................................ 72
9.3.12       不要返回对成员数据的非常量引用或指向成员数据的指针......................... 72
9.3.13       使用内嵌定义函数而不使用 #define 来实现宏扩展功能............................. 73
9.3.14       使用默认参数而不使用函数重载................................................................ 73
9.3.15       使用函数重载表达常用语义....................................................................... 73
9.3.16       避免重载以指针和整形数为实参的函数..................................................... 73
9.3.17       操作符 operator= 必须返回对 *this 的引用............................................... 74
9.3.18       在 operator=中必须检查自赋值.................................................................. 74
9.3.19       尽可能减少复杂性..................................................................................... 74
9.4        类型................................................................................................................. 75
9.4.1         定义项目范围的全局系统类型................................................................... 75
9.4.2         避免使用基本类型..................................................................................... 75
9.4.3         使用 typedef 创建同义词来加强局部含义.................................................. 75
9.5        常量与对象...................................................................................................... 76
9.5.1         避免使用字符串值..................................................................................... 76
9.5.2         避免使用 #define 预处理指示符来定义常量.............................................. 76
9.5.3         对象声明靠近其第一次使用点................................................................... 77
9.5.4         声明时总要初始化 const 对象................................................................... 77
9.5.5         永远不要cast掉常量对象的“不变性”.......................................................... 77
9.5.6         定义时初始化对象..................................................................................... 77
第10章       表达式和语句.............................................................................................. 78

10.1          表达式.......................................................................................................... 78
10.1.1       使用冗余的圆括号使复合表达式含义更加清晰........................................... 78
10.1.2       避免表达式的过深嵌套.............................................................................. 78
10.1.3       不要假定任何特殊的表达式计算次序......................................................... 78
10.1.4       空指针使用 0 而不使用 NULL................................................................. 78
10.1.5       不要使用旧式的类型转换.......................................................................... 79
10.1.6       Boolean（布尔）表达式使用新的 bool 类型.............................................. 80
10.1.7       不要直接与布尔值 true（真）做比较......................................................... 80
10.1.8       不在同一数组中的对象的指针不要做比较.................................................. 80
10.1.9       已删除的对象指针要赋予空指针值............................................................ 80
10.2          语句............................................................................................................. 81
10.2.1       当分支条件为布尔表达式时使用 if 语句................................................... 81
10.2.2       当分支条件为离散时使用 switch 语句....................................................... 81
10.2.3       一定为 switch 语句提供一个 default 分支以捕获错误............................... 81
10.2.4       当循环需要迭代前测试时使用 for 语句或 while 语句............................... 81
10.2.5       当循环需要迭代后测试时使用 do while 语句............................................. 81
10.2.6       循环中避免使用 jump 语句....................................................................... 81
10.2.7       不要使用 goto 语句.................................................................................. 81
10.2.8       避免嵌套作用域内隐藏标识符................................................................... 81
第11章       特殊主题..................................................................................................... 82

11.1      内存管理.......................................................................................................... 82
11.1.1       避免混合使用C 和 C++ 内存操作............................................................ 82
11.1.2       删除由 new 创建的数组对象时总使用 delete[].......................................... 82
11.2      错误处理和异常............................................................................................... 82
11.2.1       开发过程中多使用“断言语句”以发现错误................................................ 82
11.2.2       只在确实是异常的情况下使用异常............................................................ 83
11.2.3       从标准异常中派生项目自己的异常............................................................ 83
11.2.4       给定抽象尽量少使用异常.......................................................................... 83
11.2.5       将所有异常声明为thrown.......................................................................... 84
11.2.6       在异常首次出现时就报告它....................................................................... 84
11.2.7       按照从派生结构最底端到最顶端的顺序定义异常处理................................ 84
11.2.8       避免使用捕获所有异常的处理过程............................................................ 85
11.2.9       确保函数状态代码有合适的值................................................................... 85
11.2.10         本地执行安全检查；不要希望您的客户会这样做.................................... 85
第12章       可移植性..................................................................................................... 86

12.1          路径名.......................................................................................................... 86
12.1.1       不要使用硬编码的文件路径名................................................................... 86
12.2          数据表示...................................................................................................... 86
12.2.1       不要对类型的表示做假设.......................................................................... 86
12.2.2       不要对类型的alignment作假设.................................................................. 86
12.2.3       不要依赖于一个特殊的下溢或上溢行为..................................................... 86
12.2.4       尽可能使用“可伸缩”常量........................................................................... 86
12.3          类型转换...................................................................................................... 87
12.3.1       不要从一个“短”类型转换成一个“长类型”................................................... 87
第13章       复用............................................................................................................. 88

13.1          尽可能使用标准库构件................................................................................. 88
13.2          使用template实现独立于数据的行为的复用................................................ 88
13.3          使用公共继承复用类接口（子类型化）......................................................... 88
13.4          使用包含而不是私有继承复用类的实现......................................................... 88
13.5          谨慎使用多继承............................................................................................ 88
第14章       编译问题..................................................................................................... 90

14.1          尽量减少对编译的依赖................................................................................. 90
14.2          用具体值定义 NDEBUG................................................................................ 91
14.3          采用统一的系统配置头文件compiler.h......................................................... 91
第15章       后记............................................................................................................. 92

15.1          参考文献...................................................................................................... 92
</code></pre><h1 id="第一章-简介"><a href="#第一章-简介" class="headerlink" title="[第一章 简介]"></a>[第一章 简介]</h1><p>大型嵌入式软件项目通常由相应的多人开发团队承担。多人团队生成的代码要有项目范围内可评测的质量，代码必须遵从于某一标准并以此来评价。因此，对大型嵌入式的项目团队来说，建立一个编程的标准或一组指南很重要。</p>
<p>使用编程标准也使以下各项成为可能：</p>
<ul>
<li>增加开发过程代码的强壮性、可读性、易维护性；减少有经验和无经验开发人员编程所需的脑力工作；</li>
<li>在项目范围内统一代码风格；</li>
<li>通过人为以及自动的方式对最终软件应用质量标准；</li>
<li>使新的开发人员快速适应项目氛围；</li>
<li>支持项目资源的复用：允许开发人员从一个项目区域（或子项目团队）移动到另一个，而不需要重新适应新的子项目团队的氛围。<br>本文从代码编写和正确使用C++特性进行面向对象的程序设计两个维度，对项目开发过程产生的代码定义了约束方式，其中代码编写规范为编写代码时应尽量遵守的规范约束和代码检查时的参考条例。设计指南结合C++特性提供了应用C++进行设计应注意的技术要点，适合有一定经验的编程人员阅读。</li>
</ul>
<h1 id="1-1-说明"><a href="#1-1-说明" class="headerlink" title="1.1 说明"></a>1.1 说明</h1><p>本规范的目的是通过详细阐述如何进行C++编码来规避其复杂性，使得代码在有效使用C++诧言特性的同时也易于管理。</p>
<p>使代码易于管理的方法之一是增强代码一致性，让别人可以读懂你的代码是很重要的，保持统一编程风格意味着可以轻松根据“模式匹配”规则推断各种符号的含义。创建通用的、必需的习惯用语和模式可以使代码更加容易理解，在某些情况下改变一些编程风格可能会是好的选择，但我们还是应该遵循一致性原则，尽量不这样去做。</p>
<p>本规范的另一个观点是C++特性的臃肿。C++是一门包含大量高级特性的巨型语言，某些情况下，我们会限制甚至禁止使用某些特性使代码简化，避免可能导致的各种问题，规范中列举了这类特性，并解释说为什么这些特性是被限制使用的。</p>
<h1 id="1-2-基本原则"><a href="#1-2-基本原则" class="headerlink" title="1.2 基本原则"></a>1.2 基本原则</h1><p>清晰、可理解的 C++ 源代码是规则和指南的主要目标：清晰、可理解的源代码是软件可靠性和可维护性的主要作用因子。清晰、可理解的代码可以表示为以下三个简单的基础原理。</p>
<p>最小混淆 — 它的生存期中，阅读源代码远比写代码的时间多，尤其是规约文件（头文件）。理想情况下，源代码读起来应该像英语一样描述了所要做的事。程序更多是为人编写，而不是为计算机而编写。阅读代码是一个复杂的脑力过程，它可由统一标准来简化，这就是在本文所说的最小混淆原则。整个项目中统一风格是软件开发团队在编程标准上达成一致的主要原因，它不应视为一种惩罚或成为对创造性和生产力的阻碍。</p>
<p>维护的唯一点 — 只要可能，设计决策就应只在源代码的一个地方表述，它的多数衍生结果应由面向对象的程序化设计方式派生得到。不遵守这一原则严重损害了可维护性、可靠性和可理解性。</p>
<p>最小干扰 — 最终，应用最小干扰原则(它是易读性的主要作用因素)。即，避免将源代码与不相关的结果输出（如混乱的编码方式或与编写软件目的不一致的代码内容）相混合：</p>
<p>规范这里所要表达的精神是不要过于拘泥语言技术深度，对正确安全的使用语言特性提供指导。优秀软件的关键在于：</p>
<p>了解每一个特性以及它的限制和潜在的危险；<br>确切了解此特性可安全的使用于哪一个环境中；<br>做出使用高度可视特性的决定；<br>在合适的地方小心适度的使用特性。</p>
<h1 id="1-3-前提"><a href="#1-3-前提" class="headerlink" title="1.3 前提"></a>1.3 前提</h1><p>本规范假设以下几个基本前提：</p>
<ul>
<li>编码人员熟悉C++基本特性，有一定的C++编码经验</li>
<li>任何有益的地方都鼓励使用 C++ 的高级特性，而不是由于有一些程序员不熟悉，就不鼓励使用这些特性。这是项目能从使用 C++ 中获益的唯一方式。C++ 不应只当成 C 来使用，事实上 C++ 的面向对象特性使它不会象 C 一样使用。不鼓励在注释中解释代码；相反，在任何可能的地方应当使用源代码代替注释。</li>
<li>遵从大型嵌入式软件做法。</li>
<li>许多规则对大型嵌入式系统比较有价值，目的是为了项目一级或公司一级的编码实现和统一。</li>
<li>代码遵从于面向对象设计。</li>
<li>许多规则都会支持从面向对象 (OO) 概念到 C++ 特性和具体命名的约定。</li>
</ul>
<h1 id="第一部分：基础部分：C-代码编写规范"><a href="#第一部分：基础部分：C-代码编写规范" class="headerlink" title="第一部分：基础部分：C++代码编写规范"></a>第一部分：基础部分：C++代码编写规范</h1><p>说明：本部分用于约束开发人员进行代码编写的过程，须尽量遵守规范条例，以保证项目编码风格统一，提高开发质量。并可用于代码审查的执行标准</p>
<h1 id="第二章-头文件"><a href="#第二章-头文件" class="headerlink" title="[第二章 头文件]"></a>[第二章 头文件]</h1><p>通常，每一个.cpp文件（C++的源文件）都有一个对应的.h文件（头文件），也有一些例外，如单元测试代码和只包含main()的.cpp文件。</p>
<p>正确使用头文件可令代码在可读性、文件大小和性能上大为改观。</p>
<p>下面的规则将引导程序员规避使用头文件时的各种麻烦。</p>
<h1 id="2-1-使用-define防止重复编译"><a href="#2-1-使用-define防止重复编译" class="headerlink" title="2.1 使用#define防止重复编译"></a>2.1 使用#define防止重复编译</h1><p>所有头文件都应该使用#define防止头文件被多重包含，这个宏的命名格式为： _<filename><em>H</em></filename></p>
<p>为保证在项目唯一性，头文件的命名应基亍其所在项目的模块源代码的文件名。例如，项目P0424中IDPHandler模块的头文件IDPModule.h按如下方式保护：</p>
<pre><code>#ifndef _IDPHANDLER_H_

#define _IDPHANDLER _H_

 ...

#endif // _IDPHANDLER _H_
</code></pre><h1 id="2-2-降低头文件依赖"><a href="#2-2-降低头文件依赖" class="headerlink" title="2.2 降低头文件依赖"></a>2.2 降低头文件依赖</h1><p>使用向前引用声明尽量减少.h文件中#include的数量。</p>
<p>当一个头文件被包含的同时也引入了一项新的依赖，只要该头文件被修改，代码就要重新编译。如果的头文件包含了其他头文件，这些头文件的任何改变也将导致那些包含了该头文件的代码重新编译。因此，我们应该尽量少所的包含头文件，尤其是那些又被包含在其他头文件中的头文件。</p>
<p>使用向前引用声明可以显著减少需要包含吨的头文件数量。丼例说明：头文件中用到类File，但不需要访问File的声明，则头文件中只需声明class File;无需#include “file/base/file.h”。</p>
<p>在头文件如何做到使用类Foo而无需访问类的定义？</p>
<p>1) 将数据成员类型声明为成员指针或引用：Foo *或Foo &amp;；</p>
<p>2) 参数、返回值类型为Foo的函数只声明（但不定义实现）；</p>
<p>3) 静态数据成员的类型可以被声明为Foo，因为静态数据成员的定义在类定义类外。</p>
<p>另一方面，如果你的类是Foo的子类，或者含有类型为Foo的非静态数据成员，则必须为类包含头文件。</p>
<p>大多数时候，使用指针成员替代对象成员更有意义。然而，某些情况下这样的做法也有可能降低代码可读性及执行效率。此时如果仅仅为了少包含头文件，还是不要这样替代的好。</p>
<p>注意，如果.cpp文件需要使用的符号应从头文件中获得，不要在源文件中包含其它源文件。应在模块中将可能被其它模块使用的符号声明到头文件中，被其他模块的源文件包含。</p>
<p>总之，本规则的核心思想是：能依赖声明的就不要依赖定义。</p>
<h1 id="2-3-内联函数"><a href="#2-3-内联函数" class="headerlink" title="2.3 内联函数"></a>2.3 内联函数</h1><p>只有当函数只有10行甚至更少时才将其定义为内联函数（inline function）。</p>
<p>定义：当函数被声明为内联函数之后，编译器可能会将其内联展开，无需按通常的函数调用机制调用内联函数。</p>
<p>优点：当函数体比较小的时候，内联该函数可以令目标代码更加高效。对于存取函数（accessor、mutator）以及其他一些短小的影响性能的关键执行函数，应考虑采用inline。</p>
<p>缺点：滥用内联将导致程序发慢，内联有可能导致目标代码量或增或减，这取决于被内联的函数的大小。内联短小的函数通常会减少代码量，但内联一个庞大的函数（注：如果编译器允许的话）将显著增加代码量。在现代处理器上，由于能更好的利用指令缓存（instruction cache），小巧的代码往往执行的更快。</p>
<p>结论：一个比较得当的处理规则是，不要内联超过10行的函数。对于析构函数应慎重对待，析构函数往往比其表面看起来要长，因为有一些隐式成员和基类析构函数（如果有的话）被编译器扩充调用！</p>
<p>另一有用的处理规则：内联那些包含循环或switch语句的函数是得不偿失的，除非在大多数情况下，这些循环或switch语句从不执行。</p>
<p>重要的是，虚函数和递归函数即使被声明为内联的也不一定会内联展开。通常，递归函数不应该被声明为内联的，递归调用堆栈的展开开不像循环那么简单，比如递归层数在编译时可能是未知的，大多数编译器都不支持内联递归函数。虚函数内联的主要原因是其定义在类的定义中，方便代码阅读。</p>
<h1 id="2-4-lt-inline-gt-h头文件"><a href="#2-4-lt-inline-gt-h头文件" class="headerlink" title="2.4 _&lt;inline&gt;.h头文件"></a>2.4 <code>_&lt;inline&gt;.h</code>头文件</h1><p>复杂的内联函数的定义，应放在后缀名为<code>_&lt;inline&gt;.h</code>的头文件中。</p>
<p>在头文件中给出内联函数的定义，可令编译器将其在调用处内联展开。然而，实现代码应完全放到.cpp文件中，我们一般不希望.h文件中出现太多实现代码，除非这样做在可读性和效率上有明显优势。</p>
<p>如果内联函数的定义比较短小、逻辑比较简单，其实现代码可以放在.h文件中。例如，存取函数的实现理所当然都放在类定义中。出于实现和调用的方便，较复杂的内联函数也可以放到.h文件中，如果你觉得这样会使头文件显得笨重，还可以将其分离到单独的<code>_&lt;inline&gt;.h</code>中。这样即把实现和类定义分离开来，当需要时包含实现所在的k即可。 </p>
<p><code>_&lt;inline&gt;.h</code>文件还可用于数模板的定义，从而使得模板定义可读性增强。</p>
<p>需提醒的一点是，<code>_&lt;inline&gt;.h</code>和其他头文件一样，也需要#define保护。</p>
<h1 id="2-5-函数参数顺序"><a href="#2-5-函数参数顺序" class="headerlink" title="2.5 函数参数顺序"></a>2.5 函数参数顺序</h1><p>定义函数时，参数顺序为：输入参数在前，输出参数在后。</p>
<p>C/C++函数参数分为输入参数和输出参数两种，有时输入参数也会输出（注：值被修改时）。输入参数一般传值或常量引用（const references），输出参数或输入/输出参数为非常量指针（non-const pointers）。对参数排序时，将所有输入参数置于输出参数之前。不要仅仅因为是新添加的参数，就将其置于最后，而应该依然置亍输出参数之前。</p>
<p>返一点并不是必须遵循的规则，输入/输出两用参数（通常是类/结构体变量）混在其中，会使得规则难以遵循。</p>
<h1 id="2-6-包含文件的名称及次序"><a href="#2-6-包含文件的名称及次序" class="headerlink" title="2.6 包含文件的名称及次序"></a>2.6 包含文件的名称及次序</h1><p>将包含次序标准化可增强可读性、避免文件间隐性依赖关系，次序如下：</p>
<p>C系统文件</p>
<p>C++系统文件</p>
<p>其他库头文件</p>
<p>本项目内头文件</p>
<p>项目内头文件应按照项目源代码目录树结构排列，并避免使用UNIX文件相对路径描述符.（当前目录）和..（父目录）。</p>
<p>例如：</p>
<p>IDPModule.cpp中包含头文件的次序如下：</p>
<p>IDPModule.h（优先位置，详情如下）</p>
<p>C系统文件</p>
<p>C++系统文件</p>
<p>其他库头文件</p>
<p>本项目内头文件</p>
<p>这种排序方式可有效减少隐藏依赖，我们希望每一个头文件独立编译，而不依赖与本模块不相关的其它头文件（该头文件应被包含于这个头文件自身中）。最简单的实现方式是将其作为第一个.h文件包含在对应的.cpp中。</p>
<p>IDPModule.cpp和IDPModule .h通常位于相同目录下，相同目录下头文件按字母排序是不错的选择。</p>
<h1 id="2-7-Summary"><a href="#2-7-Summary" class="headerlink" title="2.7 Summary"></a>2.7 Summary</h1><ol>
<li><p>避免多重包含是学编程时最基本的要求；</p>
</li>
<li><p>向前引用声明是为了降低编译依赖，防止修改头文件引发多米诺效应；</p>
</li>
<li><p>内联函数的合理使用可提高代码执行效率；</p>
</li>
<li><p>_<inline>可提高代码可诺性（一般用不到吧:D）；</inline></p>
</li>
<li><p>标准化函数参数顺序可以提高可读性和易维护性（对函数参数的堆栈空间有轻微影响，我以前大多是相同类型放在一起）；</p>
</li>
<li><p>包含文件的名称使用.和..虽然方便却易混乱，使用比较完整的项目路径看上去很清晰、很有条理，包含文件的次序除了美观之外，最重要的是可以减少隐藏依赖，使每个头文件在“最需要编译”（对应源文件处:D）的地方编译，有人提出库文件放在最后，这样出错先是项目内的文件，头文件都放在对应源文件的最前面，这一点足以保证内部错误被及时发现。</p>
</li>
</ol>
<h1 id="第三章-作用域"><a href="#第三章-作用域" class="headerlink" title="[第三章 作用域]"></a>[第三章 作用域]</h1><h1 id="3-1命名空间（Namespaces）"><a href="#3-1命名空间（Namespaces）" class="headerlink" title="3.1命名空间（Namespaces）"></a>3.1命名空间（Namespaces）</h1><p>在.cpp源文件中，提倡使用不具名的命名空间（unnamed namespaces）。使用具名命名空间时，其名称可基于项目或路径名称，不要使用using指示符。</p>
<p>定义：命名空间将全局作用域细分为不同的、具名的作用域，可有效防止全局作用域的命名冲突。</p>
<p>优点：命名空间提供了（可嵌套可分割）的命名作用域（注：将命名分割在不同命名空间内），当然，类也提供了（可嵌套不可分割）的命名作用域（注：将命名分割在相类的作用域内）。</p>
<p>举例来说，两个不同项目的全局作用域都有一个类Foo，这样在编译或运行时造成冲突。如果每个项目将代码置于不同命名空间中，project1::Foo和project2::Foo作为不同符号自然不会冲突。</p>
<p>缺点：命名空间具有迷惑性，因为它们和类一样提供了额外的（可嵌套的）命名作用域。在头文件中使用不具名的空间容易违背C++的唯一定义原则（One Definition Rule (ODR)）。</p>
<p>结论：根据下文将要提到的策略合理使用命名空间。</p>
<p>1) 不具名命名空间（Unnamed Namespaces）</p>
<p>在.cpp文件中，提倡使用不具名命名空间，以避免运行时的命名冲突：</p>
<pre><code>namespace { // .cpp文件中

// 命名空间的内容无需缩进



enum { UNUSED, EOF, ERROR };         // 经常使用的符号

bool AtEof() { return pos_ == EOF; }       // 使用本命名空间内的符号EOF



} // namespace
</code></pre><p>然而，与特定类关联的文件作用域声明在该类中被声明为类型、静态数据成员或静态成员函数，而不是不具名命名空间的成员。像上文展示的那样，不具名命名空间结束时用注释// namespace标识。</p>
<p>不能在.h文件中使用不具名命名空间。</p>
<p>2) 具名命名空间（Named Namespaces） 具名命名空间使用方式如下：</p>
<p>命名空间将除文件包含、全局标识的声明/定义以及类的前置声明外的整个源文件封装起来，以同其他命名空间相区分。</p>
<pre><code>// .h文件

namespace mynamespace {

// 所有声明都置于命名空间中, 注意不要使用缩进

class MyClass {

public:

      ...

      void Foo();

};

} // namespace mynamespace



// .cc文件

namespace mynamespace {

// 函数定义都置于命名空间中

      void MyClass::Foo() {

      ...

}

} // namespace mynamespace
</code></pre><p>通常的.cc文件会包含更多、更复杂的绅节，包括对其他命名空间中类的引用等。</p>
<pre><code>#include &quot;a.h&quot;

DEFINE_bool(someflag, false, &quot;dummy flag&quot;);

class C; // 全局命名空间中类C的前置声明

namespace a { class A; } // 命名空间a中的类a::A的前置声明

namespace b {

      ...

      code for b... // b中的代码

} // namespace b
</code></pre><p>不要声明命名空间std下的任何内容，包括标准库类的前置声明。声明std下的实体会导致不明确的行为。</p>
<p>最好不要随意使用using指示符，以保证命名空间下的所有名称都可以正常使用。请遵循以下规则：</p>
<pre><code>// 禁止——污染命名空间

using namespace foo;
</code></pre><p>在.cc文件、.h文件的函数、方法或类中，可以使用using。</p>
<pre><code>// 允许：.cc文件中

// .h文件中，必须在函数、方法或类的内部使用

using ::foo::bar;
</code></pre><p>在.cc文件、.h文件的函数、方法或类中，也可以使用命名空间别名。</p>
<pre><code>// 允许：.cc文件中

// .h文件中，必须在函数、方法或类的内部使用

namespace fbz = ::foo::bar::baz;
</code></pre><h1 id="3-2-嵌套类（Nested-Class）"><a href="#3-2-嵌套类（Nested-Class）" class="headerlink" title="3.2 嵌套类（Nested Class）"></a>3.2 嵌套类（Nested Class）</h1><p>当公开嵌套类作为接口的一部分时，虽然可以直接将他们保持在全局作用域中，但将嵌套类的声明置于命名空间中是更好的选择。</p>
<p>定义：可以在一个类中定义另一个类，嵌套类也称成员类（member class）。</p>
<pre><code>class Foo {

private:

      // Bar是嵌套在Foo中的成员类

      class Bar {

      ...

      };

};
</code></pre><p>优点：当嵌套（成员）类只在被嵌套类（enclosing class）中使用时很有用，将其置于被嵌套类作用域作为被嵌套类的成员不会污染其他作用域同名类。可在被嵌套类中前置声明嵌套类，在.cpp文件中定义嵌套类，避免在被嵌套类中包含嵌套类的定义，因为嵌套类的定义通常只与实现相关。</p>
<p>缺点：只能在被嵌套类的定义中才能前置声明嵌套类。因此，任何使用Foo::Bar*指针的头文件必须包含整个Foo的声明。</p>
<p>结论：不要将嵌套类定义为public，除非它们是接口的一部分，比如，某方法使用了这个类的一系列选项。</p>
<h1 id="3-3-非成员函数（Nonmember）、静态成员函数（Static-Member）和全局函数（Global-Functions）"><a href="#3-3-非成员函数（Nonmember）、静态成员函数（Static-Member）和全局函数（Global-Functions）" class="headerlink" title="3.3 非成员函数（Nonmember）、静态成员函数（Static Member）和全局函数（Global Functions）"></a>3.3 非成员函数（Nonmember）、静态成员函数（Static Member）和全局函数（Global Functions）</h1><p>使用命名空间中的非成员函数或静态成员函数，尽量不要使用全局函数。</p>
<p>优点：某些情况下，非成员函数和静态成员函数是非常有用的，将非成员函数置于命名空间中可避免对全尿作用域的污染。</p>
<p>缺点：将非成员函数和静态成员函数作为新类的成员或许更有意义，当它们需要访问外部资源或具有重要依赖时更是如此。</p>
<p>结论：有时，不把函数限定在类的实体中是有益的，甚至需要者么做，要么作为静态成员，要么作为非成员函数。非成员函数不应依赖于外部发量，并尽量置于某个命名空间中。相比单纯为了封装若干不共享任何静态数据的静态成员函数而创建类，不如使用命名空间。</p>
<p>定义于同一编译单元的函数，被其他编译单元直接调用可能会引入不必要的耦合和连接依赖；静态成员函数对此尤其敏感。可以考虑提取到新类中，或者将函数置于独立于库的命名空间中。</p>
<p>如果你确实需要定义非成员函数，又只是在.cc文件中使用它，可使用不具名命名空间或static关联（如static int Foo() {…}）限定其作用域。</p>
<h1 id="3-4-局部变量（Local-Variables）"><a href="#3-4-局部变量（Local-Variables）" class="headerlink" title="3.4. 局部变量（Local Variables）"></a>3.4. 局部变量（Local Variables）</h1><p>将函数变量尽可能置于最小作用域内，在声明变量时将其初始化。</p>
<p>C++允许在函数的任何位置声明变量。我们提倡在尽可能小的作用域中声明变量，离第一次使用越近越好。这使得代码易于阅读，易于定位变量的声明位置、变量类型和初始值。特别是，应使用初始化代替声明+赋值的方式。</p>
<pre><code>int i;

i = f(); // 坏——初始化和声明分离

int i = g(); // 好——初始化时声明
</code></pre><p>注意：gcc可正确执行for (int i = 0; i &lt; 10; ++i)（i的作用域仅限for循环），因此其他for循环中可重用i。if和while等语句中，作用域声明（scope declaration）同样是正确的。</p>
<pre><code>while (const char* p = strchr(str, &apos;/&apos;)) str = p + 1;
</code></pre><p>注意：如果变量是一个对象，每次进入作用域都要调用其构造函数，每次退出作用域都要调用其析构函数。</p>
<pre><code>// 低效的实现

for (int i = 0; i &lt; 1000000; ++i) {

      Foo f; // 构造函数和析构函数分别调用1000000次！

      f.DoSomething(i);

}
</code></pre><p>类似变量放到循环作用域外面声明要高效的多：</p>
<pre><code>Foo f; // 构造函数和析构函数只调用1次

for (int i = 0; i &lt; 1000000; ++i) {

      f.DoSomething(i);

}
</code></pre><h1 id="3-5-全局变量（Global-Variables）"><a href="#3-5-全局变量（Global-Variables）" class="headerlink" title="3.5 全局变量（Global Variables）"></a>3.5 全局变量（Global Variables）</h1><p>class类型的全局变量是被禁止的，内建类型的全局变量是允许的，当然多线程代码中非常数全局变量也是被禁止的。永远不要使用函数返回值初始化全局变量。</p>
<p>不幸的是，全局变量的构造函数和析构函数以及初始化操作的调用顺序只是被部分规定，每次生成有可能会有发化，从而导致难以发现的bugs。</p>
<p>因此，禁止使用class类型的全局变量（包括STL的string, vector等等），因为它们的初始化顺序有可能导致构造出现问题。内建类型和由内建类型构成的没有构造函数的结构体可以使用，如果你一定要使用class类型的全局变量，请使用单件模式（singleton pattern）。</p>
<p>对于全局字符串常量，使用C风格的字符串，而不要使用STL的字符串：</p>
<pre><code>const char kFrogSays[] = &quot;ribbet&quot;;
</code></pre><p>虽然允许在全尿作用域中使用全局变量，使用时务必三思。大多数全局变量应该是类的静态数据成员，或者当其只在.cpp文件中使用时，将其定义到不具名命名空间中，或者使用静态关联以限制变量的作用域。</p>
<p>记住，静态成员变量视作全局变量，所以，也不能是class类型！</p>
<h1 id="3-6-Summary"><a href="#3-6-Summary" class="headerlink" title="3.6 Summary"></a>3.6 Summary</h1><ol>
<li><p>.cpp中的不具名命名空间可避免命名冲突、限定作用域，避免直接使用using提示符污染命名空间；</p>
</li>
<li><p>嵌套类符合局部使用原则，只是不能在其他头文件中前置声明，尽量不要public；</p>
</li>
<li><p>尽量不用全局函数和全局变量，考虑作用域和命名空间限制，尽量单独形成编译单元；</p>
</li>
<li><p>多线程中的全局变量（含静态成员变量）不要使用class类型（含STL容器），避免不明确行为导致的bugs。</p>
</li>
</ol>
<p>作用域的使用，除了考虑名称污染、可读性之外，主要是为降低耦合度，提高编译、执行效率。</p>
<h1 id="第四章-C-类"><a href="#第四章-C-类" class="headerlink" title="[第四章 C++类]"></a>[第四章 C++类]</h1><p>类是C++中基本的代码单元，本节列举了在写一个类时要做什么、不要做什么以及定义一个类时正确的行为。</p>
<h1 id="4-1-构造函数（Constructor）的职责"><a href="#4-1-构造函数（Constructor）的职责" class="headerlink" title="4.1 构造函数（Constructor）的职责"></a>4.1 构造函数（Constructor）的职责</h1><p>构造函数中只进行那些没有实际意义的（注：简单初始化对于程序执行没有实际的逻辑意义，因为成员发量的“有意义”的值大多不在构造函数中确定）初始化，可能的话，使用Init()方法集中初始化为有意义的（non-trivial）数据。</p>
<p>定义：在构造函数中执行初始化操作。</p>
<p>优点：排版方便，无需担心类是否初始化。</p>
<p>缺点：在构造函数中执行操作引起的问题有：</p>
<p>1) 构造函数中不易报告错误，不能使用异常。</p>
<p>2) 操作失败会造成对象初始化失败，引起不确定状态。</p>
<p>3) 构造函数内调用虚函数，调用不会派发到子类实现中，即使当前没有子类化实现，将来仍是隐患。</p>
<p>4) 如果有人创建该类型的全局变量（虽然违背了上节提到的规则），构造函数将在main()之前被调用，有可能破坏构造函数中暗含的假设条件。如，某些变量的初始化条件。</p>
<p>结论：如果对象需要有意义的（non-trivial）初始化，考虑使用另外的Init()方法或增加一个成员标记用于指示对象是否已经初始化成功。</p>
<h1 id="4-2-默认构造函数（Default-Constructors）"><a href="#4-2-默认构造函数（Default-Constructors）" class="headerlink" title="4.2 默认构造函数（Default Constructors）"></a>4.2 默认构造函数（Default Constructors）</h1><p>如果一个类定义了若干成员变量又没有其他构造函数，需要定义一个默认构造函数，否则编译器将自动生成默认构造函数。</p>
<p>定义：新建一个没有参数的对象时，默认构造函数被调用，当调用new[]（为数组）时，默认构造函数总是被调用。</p>
<p>优点：默认将结构体初始化为“不可能的”值，使调试更加容易。</p>
<p>缺点：对代码编写者来说，这是多余的工作。</p>
<p>结论：如果类中定义了成员变量，没有提供其他构造函数，你需要定义一个默认构造函数（没有参数）。默认构造函数更适合于初始化对象，使对象内部状态（internal state）一致、有效。</p>
<p>提供默认构造函数的原因是：如果你没有提供其他构造函数，又没有定义默认构造函数，编译器将为你自动生成一个，编译器生成的构造函数并不会对对象进行初始化。</p>
<p>如果你定义的类继承现有类，而你又没有增加新的成员发量，则不需要为新类定义默认构造函数。</p>
<h1 id="4-3-显式构造函数（Explicit-Constructors）"><a href="#4-3-显式构造函数（Explicit-Constructors）" class="headerlink" title="4.3 显式构造函数（Explicit Constructors）"></a>4.3 显式构造函数（Explicit Constructors）</h1><p>对单参数构造函数使用C++关键字explicit。</p>
<p>定义：通常，只有一个参数的构造函数可被用于类型转换（注：主要指隐式类型转换，下文可见），例如，定义了Foo::Foo(string name)，当向需要传入一个Foo对象的函数传入一个字符串时，构造函数Foo::Foo(string name)被调用并将该字符串转换为一个Foo临时对象传给调用函数。看上去很方便，但如果你并不希望如此通过转换生成一个新对象的话，麻烦也随之而来。为避免构造函数被调用造成隐式类型转换，可以将其声明为explicit。</p>
<p>优点：避免不合时宜的隐式类型转换。</p>
<p>缺点：无。</p>
<p>结论： 所有单参数构造函数必须是显式的。在类定义中，将关键字explicit加到单参数构造函数前：explicit Foo(string name);</p>
<p>例外：在少数情况下，拷贝构造函数可以不声明为explicit；特意作为其他类的透明包装器的类。类似的例外情况应在注释中明确说明。</p>
<h1 id="4-4-拷贝构造函数（Copy-Constructors）"><a href="#4-4-拷贝构造函数（Copy-Constructors）" class="headerlink" title="4.4 拷贝构造函数（Copy Constructors）"></a>4.4 拷贝构造函数（Copy Constructors）</h1><p>仅在代码中需要拷贝一个类对象的时候使用拷贝构造函数；不需要拷贝时应使用DISALLOW_COPY_AND_ASSIGN。</p>
<p>定义：通过拷贝新建对象时可使用拷贝构造函数（特别是对象的传值时）。</p>
<p>优点：拷贝构造函数使得拷贝对象更加容易， STL容器要求所有内容可拷贝、可赋值。</p>
<p>缺点：C++中对象的隐式拷贝是导致很多性能问题和bugs的根源。拷贝构造函数降低了代码可读性，相比按引用传递，跟踪按值传递的对象更加困难，对象修改的地方变得难以捉摸。</p>
<p>结论：大量的类并不需要可拷贝，也不需要一个拷贝构造函数或赋值操作（assignment operator）。不幸的是，如果你不主动声明它们，编译器会为你自动生成，而且是public的。</p>
<p>可以考虑在类的private中添加空的（dummy）拷贝构造函数和赋值操作，只有声明，没有定义。由于这些空函数声明为private，当其他代码试图使用它们的时候，编译器将报错。为了方便，可以使用宏DISALLOW_COPY_AND_ASSIGN：</p>
<pre><code>// 禁止使用拷贝构造函数和赋值操作的宏

// 应在类的private:中使用

#define DISALLOW_COPY_AND_ASSIGN(TypeName) \

      TypeName(const TypeName&amp;); \

      void operator=(const TypeName&amp;)



class Foo {

public:

      Foo(int f);

       ~Foo();



private:

      DISALLOW_COPY_AND_ASSIGN(Foo);

};
</code></pre><p>如上所述，绝大多数情况下都应使用DISALLOW_COPY_AND_ASSIGN，如果类确实需要可拷贝，应在该类的头文件中说明原由，并适当定义拷贝构造函数和赋值操作，注意在operator=中检测自赋值（self-assignment）情况。</p>
<p>在将类作为STL容器值得时候，你可能有使类可拷贝的冲动。类似情况下，真正该做的是使用指针指向STL容器中的对象，可以考虑使用std::tr1::shared_ptr。</p>
<h1 id="4-5-结构体和类（Structs-vs-Classes）"><a href="#4-5-结构体和类（Structs-vs-Classes）" class="headerlink" title="4.5 结构体和类（Structs vs. Classes）"></a>4.5 结构体和类（Structs vs. Classes）</h1><p>仅当只有数据时使用struct，其它一概使用class。</p>
<p>在C++中，关键字struct和class几乎含义等同，我们为其人为添加语义，以便为定义的数据类型合理选择使用哪个关键字。</p>
<p>struct被用在仅包含数据的消极对象（passive objects）上，可能包括有关联的常量，但没有存取数据成员之外的函数功能，而存取功能通过直接访问实现而无需方法调用，这里提到的方法是指只用于处理数据成员的，如构造函数、析构函数、Initialize()、Reset()、Validate()。</p>
<p>如果需要更多的函数功能，class更适合，如果不确定的话，直接使用class。</p>
<p>如果与STL结合，对于仿函数（functors）和特性（traits）可以不用class而是使用struct。</p>
<p>注意：类和结构体的成员变量使用不同的命名规则。</p>
<h1 id="4-6-继承（Inheritance）"><a href="#4-6-继承（Inheritance）" class="headerlink" title="4.6 继承（Inheritance）"></a>4.6 继承（Inheritance）</h1><p>使用组合（composition，注，这一点也是GoF在《Design Patterns》里反复强调的）通常比使用继承更适宜，如果使用继承的话，只使用公共继承。</p>
<p>定义：当子类继承基类时，子类包含了父基类所有数据及操作的定义。C++实践中，继承主要用于两种场合：实现继承（implementation inheritance），子类继承父类的实现代码；接口继承（interface inheritance），子类仅继承父类的方法名称。</p>
<p>优点：实现继承通过原封不动的重用基类代码减少了代码量。由于继承是编译时声明（compile-time declaration），编码者和编译器都可以理解相应操作并发现错误。接口继承可用于程序上增强类的特定API的功能，在类没有定义API的必要实现时，编译器同样可以侦错。</p>
<p>缺点：对于实现继承，由于实现子类的代码在父类和子类间延展，要理解其实现变得更加困难。子类不能重写父类的非虚函数，当然也就不能修改其实现。基类也可能定义了一些数据成员，还要区分基类的物理定义（physical layout）。</p>
<p>结论：所有继承必须是public的，如果想私有继承的话，应该采取包含基类实例作为成员的方式作为替代。</p>
<p>不要过多使用实现继承，组合通常更合适一些。努力做到只在“is-a”的情况下使用继承：如果Bar的确“是一种”Foo，才令Bar是Foo的子类。其他”has-a”情况下请使用组合。</p>
<p>必要的话，令析构函数为virtual，必要是指，如果该类具有虚函数，其析构函数应该为虚函数。</p>
<p>注：至于子类没有额外数据成员，甚至父类也没有任何数据成员的特殊情况下，析构函数的调用是否必要是语义争论，从编程设计规范的角度看，在含有虚函数的父类中，定义虚析构函数绝对必要。</p>
<p>限定仅在子类访问的成员函数为protected，需要注意的是数据成员应始终为私有。</p>
<p>当重定义派生的虚函数时，在派生类中明确声明其为virtual。根本原因：如果遗漏virtual，阅读者需要检索类的所有祖先以确定该函数是否为虚函数（注，虽然不影响其为虚函数的本质）。</p>
<h1 id="4-7-多重继承（Multiple-Inheritance）"><a href="#4-7-多重继承（Multiple-Inheritance）" class="headerlink" title="4.7 多重继承（Multiple Inheritance）"></a>4.7 多重继承（Multiple Inheritance）</h1><p>真正需要用到多重实现继承（multiple implementation inheritance）的时候非常少，只有当最多一个基类中含有实现，其它基类都是以Interface为后缀的纯接口类时才会使用多重继承。</p>
<p>定义：多重继承允许子类拥有多个基类，要将作为纯接口的基类和具有实现的基类区别开来。</p>
<p>优点：相比单继承，多重实现继承可令你重用更多代码。</p>
<p>缺点：真正需要用到多重实现继承的时候非常少，多重实现继承看上去是不错的解决方案，通常可以找到更加明确、清晰的、不同的解决方案。</p>
<p>结论：只有当所有超类（superclass）除第一个外都是纯接口时才能使用多重继承。为确保它们是纯接口，返些类必须以Interface为后缀。</p>
<h1 id="4-8-接口类（Interface）"><a href="#4-8-接口类（Interface）" class="headerlink" title="4.8 接口类（Interface）"></a>4.8 接口类（Interface）</h1><p>接口是指满足特定条件的类，这些类以Interface为后缀（非必需）。</p>
<p>定义：当一个类满足以下要求时，称之为纯接口：</p>
<p>1) 只含有纯虚函数（”=0”）和静态函数（析构函数除外）；</p>
<p>2) 没有非静态数据成员；</p>
<p>3) 没有定义任何构造函数。如果有，也不含参数，并且为protected；</p>
<p>4) 如果是子类，也只能继承满足上述条件并以Interface为后缀的类。</p>
<p>接口类不能被直接实例化，因为它声明了纯虚函数。为确保接口类的所有实现可被正确销毁，必须为之声明虚析构函数（作为第1条规则的例外，析构函数不能是纯虚函数）。具体细节可参考Stroustrup的《The C++ Programming Language, 3rd edition》第12.4节。</p>
<p>优点：以Interface为后缀可令他人知道不能为该接口类增加实现函数或非静态数据成员，这一点对于多重继承尤其重要。其实，对于Java或者C#这类程序员来说，接口的概念早已经深入人心。</p>
<p> 缺点：Interface后缀增加了类名长度，为阅读和理解带来不便，同时，接口特性作为实现细节不应暴露给客户。</p>
<p> 结论：只有在满足上述需要时，类才以Interface结尾，但反过来，满足上述需要的类未必一定以Interface结尾。</p>
<h1 id="4-9-操作符重载（Operator-Overloading）"><a href="#4-9-操作符重载（Operator-Overloading）" class="headerlink" title="4.9 操作符重载（Operator Overloading）"></a>4.9 操作符重载（Operator Overloading）</h1><p>除少数特定环境外，不要重载操作符。</p>
<p>定义：一个类可以定义诸如+、/等操作符，使其可以像内建类型一样直接使用。</p>
<p>优点：使代码看上去更加直观，就像内建类型（如int）那样，重载操作符比那些Equals()、Add()等黯淡无光的函数名好玩多了。为了使一些模板函数正确工作，你可能需要定义操作符。</p>
<p>缺点：虽然操作符重载令代码更加直观，但也有一些丌足</p>
<p>1) 混淆直觉，让你误以为一些耗时的操作像内建操作那样轻巧；</p>
<p>2) 查找重载操作符的调用处更加困难，查找Equals()显然比同等调用==容易的多；</p>
<p>3) 有的操作符可以对指针进行操作，容易导致bugs， Foo + 4做的是一件事，而&amp;Foo + 4可能做的是完全不同的另一件事，对于二者，编译器都不会报错，使其很难调试；</p>
<p>4) 重载还有令你吃惊的副作用，比如，重载操作符&amp;的类不能被前置引用声明。</p>
<p>结论： 一般不要重载操作符，尤其是赋值操作（operator=）比较阴险，应避免重载。如果需要的话，可以定义类似Equals()、CopyFrom()等函数。</p>
<p>然而，极少数情况下需要重载操作符以便与模板或“标准”C++类衔接（如operator&lt;&lt;(ostream&amp;, const T&amp;)），如果被证明是正当的尚可接受，但你要尽可能避免返样做。尤其是不要仅仅为了在STL容器中作为key使用就重载operator==或operator&lt;，取而代之，你应该在声明容器的时候，创建相等判断和大小比较的仿函数类型。</p>
<p>有些STL算法确实需要重载operator==时可以这么做，不要忘了提供文档说明原因。</p>
<p>参考拷贝构造函数和函数重载。</p>
<h1 id="4-10-存取控制（Access-Control）"><a href="#4-10-存取控制（Access-Control）" class="headerlink" title="4.10 存取控制（Access Control）"></a>4.10 存取控制（Access Control）</h1><p>将数据成员私有化，并提供相关存取函数，如定义变量foo_及取值函数foo()、赋值函数set_foo()。</p>
<p>存取函数的定义一般内联在头文件中。 参考继承和函数命名。</p>
<h1 id="4-11-声明次序（Declaration-Order）"><a href="#4-11-声明次序（Declaration-Order）" class="headerlink" title="4.11 声明次序（Declaration Order）"></a>4.11 声明次序（Declaration Order）</h1><p>在类中使用特定的声明次序：public:在private:之前，成员函数在数据成员（变量）前。</p>
<p>定义次序如下：public:、protected:、private:，如果没有，直接忽略即可。</p>
<p>每一块中，声明次序一般如下：</p>
<p>1) typedefs和enums；</p>
<p>2) 常量；</p>
<p>3) 构造函数；</p>
<p>4) 析构函数；</p>
<p>5) 成员函数，含静态成员函数；</p>
<p>6) 数据成员，含静态数据成员。</p>
<p>宏DISALLOW_COPY_AND_ASSIGN置亍private:块之后，作为类的最后部分。参考拷贝构造函数。</p>
<p>.cc文件中函数的定义应尽可能和声明次序一致。</p>
<p>不要将大型函数内联到类的定义中，通常，叧有那些没有特别意义的或者性能要求高的，并且是较轳短小的函数才被定义为内联函数。更多细节参考内联函数。</p>
<h1 id="4-12-编写短小函数（Write-Short-Functions）"><a href="#4-12-编写短小函数（Write-Short-Functions）" class="headerlink" title="4.12 编写短小函数（Write Short Functions）"></a>4.12 编写短小函数（Write Short Functions）</h1><p>倾向于选择短小、凝练的函数。</p>
<p>长函数有时是恰当的，因此对天一函数长度并没有严格限制。如果函数超过40行，可以考虑在不影响程序结构的情况下将其分割一下。</p>
<p>即使一个长函数现在工作的非常好，一旦有人对其修改，有可能出现新的问题，甚至导致难以发现的bugs。使函数尽量短小、简单，便于他人阅读和修改代码。</p>
<p>在处理代码时，你可能会发现复杂的长函数，布要害怕修改现有代码：如果证实这些代码使用、调试困难，戒者你需要使用其中的一小块，考虑将其分割为更加短小、易于管理的若干函数。</p>
<h1 id="4-13-Summary"><a href="#4-13-Summary" class="headerlink" title="4.13 Summary"></a>4.13 Summary</h1><ol>
<li><p>不在构造函数中做太多逻辑相关的初始化；</p>
</li>
<li><p>编译器提供的默认构造函数不会对变量进行初始化，如果定义了其它构造函数，编译器不再提供，需要编码者自行提供默认构造函数；</p>
</li>
<li><p>为避免隐式类转换，需将单参数构造函数声明为explicit；</p>
</li>
<li><p>为避免拷贝构造函数、赋值操作的滥用和编译器自动生成，可声明其为private且无需实现；</p>
</li>
<li><p>仅在作为数据集合时使用struct；</p>
</li>
<li><p>组合&gt;实现继承&gt;接口继承&gt;私有继承，子类重载的虚函数也要声明virtual关键字，虽然编译器允许不这样做；</p>
</li>
<li><p>避免使用多重继承，使用时，除一个基类含有实现外，其他基类均为纯接口；</p>
</li>
<li><p>接口类类名以Interface为后缀，除提供带实现的虚析构函数、静态成员函数外，其他均为纯虚函数，不定义非静态数据成员，不提供构造函数，提供的话，声明为protected；</p>
</li>
<li><p>为降低复杂性，尽量不重载操作符，模板、标准类中使用时提供文档说明；</p>
</li>
<li><p>存取函数一般内联在头文件中；</p>
</li>
<li><p>声明次序：public-&gt;protected-&gt;private；</p>
</li>
<li><p>函数体尽量短小、紧凑，功能单一。</p>
</li>
</ol>
<p>#[第五章 智能指针和其他C++特性]</p>
<h1 id="5-1-智能指针（Smart-Pointers）"><a href="#5-1-智能指针（Smart-Pointers）" class="headerlink" title="5.1 智能指针（Smart Pointers）"></a>5.1 智能指针（Smart Pointers）</h1><p>如果确实需要使用智能指针的话，scoped_ptr完全可以胜任。在非常特殊的情况下，例如对STL容器中对象，你应该只使用std::tr1::shared_ptr，任何情况下都不要使用auto_ptr。</p>
<p>“智能”指针看上去是指针，其实是附加了语义的对象。以scoped_ptr为例，scoped_ptr被销毁时，删除了它所指向的对象。shared_ptr也是如此，而丏，shared_ptr实现了引用计数（reference-counting），从而只有当它所指向的最后一个对象被销毁时，指针才会被删除。</p>
<p>一般来说，我们倾向于设计资源对象隶属明确的代码，最明确的资源对象隶属是根本不使用指针，直接将资源对象作为一个类的成员变量使用。另一种极端是引用计数指针不属于任何对象，这样设计的问题是容易导致循环引用或其它导致对象无法删除的情况，而且在每一次拷贝或赋值时连原子操作都会很慢。</p>
<p>虽然不推荐这么做，但有些时候，引用计数（智能）指针是最简单有效的解决方案。</p>
<p>其他C++特性</p>
<h1 id="5-2-引用参数（Reference-Arguments）"><a href="#5-2-引用参数（Reference-Arguments）" class="headerlink" title="5.2 引用参数（Reference Arguments）"></a>5.2 引用参数（Reference Arguments）</h1><p>所有按引用传递的参数必须加上const。</p>
<p>定义：在C语言中，如果函数需要修改变量的值，形参（parameter）必须为指针，如：</p>
<pre><code>int foo(int *pval)。
</code></pre><p>在C++中，函数还可以声明引用形参：</p>
<pre><code>int foo(int &amp;val)。
</code></pre><p>优点：定义形参为引用避免了像(*pval)++这样丑陋的代码，像拷贝构造函数这样的应用也是必需的，而且不像指针那样不接受空指针NULL。</p>
<p>缺点：容易引起误解，因为引用在语法上是值却拥有指针的语义。</p>
<p>结论： 函数形参表中，所有引用必须是const：</p>
<pre><code>void Foo(const string &amp;in, string *out);
</code></pre><p>事实上这是一个硬性约定：输入参数为值传递或常量引用，输出参数为指针；输入参数可以是常量指针，但不能使用非常量引用形参，想想临时变量的产生就知道了。</p>
<p>在强调参数不是拷贝而来，在对象生命期内必须一直存在时可以使用常数指针，最好将这些在注释中详细说明。bind2nd和mem_fun等STL适配器不接受引用形参，返种情况下也必须以指针形参声明函数。</p>
<h1 id="5-3-函数重载（Function-Overloading）"><a href="#5-3-函数重载（Function-Overloading）" class="headerlink" title="5.3 函数重载（Function Overloading）"></a>5.3 函数重载（Function Overloading）</h1><p>仅在输入参数类型不同、功能相同时使用重载函数（含构造函数），不要使用函数重载模仿缺省函数参数。 </p>
<p>定义：可以定义一个函数参数类型为const string&amp;，并定义其重载函数类型为const char*。</p>
<pre><code>class MyClass {

public:

      void Analyze(const string &amp;text);

      void Analyze(const char *text, size_t textlen);

};
</code></pre><p>优点：通过重载不同参数的同名函数，令代码更加直观，模板化代码需要重载，同时为访问者带来便利。</p>
<p>缺点：限制使用重载的一个原因是在特定调用处很难确定到底调用的是哪个函数，另一个原因是当派生类只重载函数的部分变量会令很多人对继承语义产生困惑。此外在阅读库的客户端代码时，因缺省函数参数造成不必要的费解。</p>
<p>结论：如果想重载一个函数，考虑让函数名包含参数信息，例如，使用AppendString()、AppendInt()而不是Append()。</p>
<h1 id="5-4-缺省参数（Default-Arguments）"><a href="#5-4-缺省参数（Default-Arguments）" class="headerlink" title="5.4 缺省参数（Default Arguments）"></a>5.4 缺省参数（Default Arguments）</h1><p>慎重使用缺省函数参数。</p>
<p>优点：经常用到一个函数带有大量缺省值，偶尔会重写一下这些值，缺省参数为很少涉及的例外情况提供了少定义一些函数的方便。</p>
<p>缺点：大家经常会通过查看现有代码确定如何使用API，缺省参数使得复制粘贴以前的代码难以呈现所有参数，当缺省参数不适用于新代码时可能导致重大问题。</p>
<p>结论：尽量明确指定函数的所有参数，尤其是定义接口函数时，要强制程序员考虑API和传入的各参数值，避免使用可能不为程序员所知的缺省参数。</p>
<h1 id="5-5-变长数组和C-style-allocator（Variable-Length-Arrays-and-C-style-allocator）"><a href="#5-5-变长数组和C-style-allocator（Variable-Length-Arrays-and-C-style-allocator）" class="headerlink" title="5.5 变长数组和C style allocator（Variable-Length Arrays and C style allocator）"></a>5.5 变长数组和C style allocator（Variable-Length Arrays and C style allocator）</h1><p>禁止使用变长数组和C style allocator 。</p>
<p>优点：变长数组具有天然的语法，变长数组和C style allocator也都很高效。</p>
<p>缺点：变长数组和C style allocator不是标准C++的组成部分，更重要的是，它们在堆栈（stack）上根据数据分配大小可能导致难以发现的内存泄漏：“在我的机器上运行的好好的，到了产品中却莫名其妙的挂掉了”。</p>
<p>结论： 使用安全的分配器（allocator），如scoped_ptr/scoped_array。</p>
<h1 id="5-6-友元（Friends）"><a href="#5-6-友元（Friends）" class="headerlink" title="5.6 友元（Friends）"></a>5.6 友元（Friends）</h1><p>合理使用友元类及友元函数。</p>
<p>通常将友元定义在同一文件下，避免读者跑到其它文件中查找其对某个类私有成员的使用。经常用到友元的一个地方是将FooBuilder声明为Foo的友元，FooBuilder以便可以正确构造Foo的内部状态，而无需将该状态暴露出来。某些情况下，将一个单元测试用类声明为待测类的友元会很方便。</p>
<p>友元延伸了（但没有打破）类的封装界线，当希望只允许另一个类访问某个成员时，使用友元通常比将其声明为public要好得多。当然，大多数类应该只提供公共成员与其交互。</p>
<h1 id="5-7-异常（Exceptions）"><a href="#5-7-异常（Exceptions）" class="headerlink" title="5.7 异常（Exceptions）"></a>5.7 异常（Exceptions）</h1><p>慎重使用C++异常。</p>
<p>优点：</p>
<p>1) 异常允许上层应用决定如何处理在底局嵌套函数中収生的“不可能发生”的失败，不像出错代码的记彔那么模糊费解；</p>
<p>2) 应用于其它很多现代编程语言中，引入异常使得C++与Python、Java及其它与C++相近的语言更加兼容；</p>
<p>3) 许多C++第三方库使用异常，关闭异常将导致难以集成这些库；</p>
<p>4) 异常是解决构造函数失败的唯一方案，虽然可以通过工厂函数（factory function）或Init()方法模拟异常，但它们分别需要堆分配或添加新的“非法”状态；</p>
<p>5) 在测试框架（testing framework）中，异常确实很好用。</p>
<p>缺点：</p>
<p>1) 在现有函数中添加throw语句时，必须检查所有调用处，即使它们至少具有基本的异常安全保护，或者程序正常结束，永远不可能捕获该异常。例如：如果f()依次调用了g()和h()，h抛出被f捕获的异常，g就要当心了，避免没有完全清理；</p>
<p>2) 通俗一点说，异常会导致程序控制流（control flow）通过查看代码无法确定：函数有可能在不确定的地方返回，从而导致代码管理和调试困难，当然，你可以通过规定何时何地如何使用异常来最小化的降低开销，却给开发人员带来掌握这些规定的负担；</p>
<p>3) 异常安全需要RAII和大量的编码实践。轻松、正确编写异常安全代码需要大量语言机制作为支撑。要使读者了解异常处理的完整调用流程，异常安全的代码必须在逻辑上独立，抛出的出错状态必须能被代码捕获。这既有好处，又得付出不菲的代价。</p>
<p>4) 加入异常使二进制执行代码体积变大，增加了编译时长（或许影响不大），还可能增加地址空间压力；</p>
<p>5) 异常的实用性可能会刺激开发人员在不恰当的时候抛出异常，或者在不安全的地方从异常中恢复，</p>
<p>结论： 从表面上看，使用异常利大于弊，尤其是在新项目中，然而，对亍现有代码，引入异常会牵连到所有依赖代码。如果允许异常在新项目中使用，在跟以前没有使用异常的代码整合时也是一个麻烦，引入带有异常处理的新代码相当困难，所以应在牢固掌握异常技术和拥有大量实践经验的基础上合理而不过分地使用异常。</p>
<p>异常也有一些替代方案，如错误代码、断言等，都会带来严重负担，仅作为代码调试使用尚可。</p>
<p>注：对于异常处理，显然不是短短几句话能够说清楚的，以构造函数为例，很多C++书籍上都提到当构造失败时只有异常可以处理。</p>
<h1 id="5-8-运行时类型识别（Run-Time-Type-Information-RTTI）"><a href="#5-8-运行时类型识别（Run-Time-Type-Information-RTTI）" class="headerlink" title="5.8 运行时类型识别（Run-Time Type Information, RTTI）"></a>5.8 运行时类型识别（Run-Time Type Information, RTTI）</h1><p>慎重使用RTTI。</p>
<p>定义：RTTI允许程序员在运行时识别C++类对象的类型。</p>
<p>优点：RTTI在某些单元测试中非常有用，如在进行工厂类测试时用于检验一个新建对象是否为期望的动态类型。 除测试外，很少用到。</p>
<p>缺点：运行时识别类型往往意味着设计本身有问题，如果需要在运行期间确定一个对象的类型，这通常说明需要重新考虑类的设计。</p>
<p>结论：除单元测试外，尽量不要使用RTTI，如果发现需要所写代码因对象类型不同而动作各异的话，考虑换一种方式识别对象类型。</p>
<p>虚函数可以实现随子类类型不同而执行不同代码，工作都是交给对象本身去完成。</p>
<p>如果工作在对象之外的代码中完成，考虑双重分发方案，如Visitor模式，可以方便的在对象本身之外确定类的类型。</p>
<p>在使用RTTI前请务必请三思，不要去手工实现一个貌似RTTI的方案（RTTI-like workaround）。</p>
<h1 id="5-9-类型转换（Casting）"><a href="#5-9-类型转换（Casting）" class="headerlink" title="5.9 类型转换（Casting）"></a>5.9 类型转换（Casting）</h1><p>使用static_cast&lt;&gt;()等C++的类型转换，不要使用int y = (int)x或int y = int(x)。</p>
<p>定义：C++引入了有别于C的，不同类型的类型转换操作。</p>
<p>优点：C语言的类型转换问题在于操作比较模糊：有时是在做强制转换（如(int)3.5），有时是在做类型转换（如(int)”hello”）。另外，C++的类型转换查找更容易、更醒目。</p>
<p>缺点：语法比较恶心（nasty）。</p>
<p>结论：使用C++风格而不要使用C风格类型转换。</p>
<p>1) static_cast：和C风格转换相似可做值的强制转换，或指针的父类到子类的明确的向上转换；</p>
<p>2) const_cast：移除const属性；</p>
<p>3) reinterpret_cast：指针类型和整型或其他指针间，不安全的相互转换，仅在对所做一切了然于心时使用；</p>
<p>4) dynamic_cast：请谨慎使用，务必判断转换结果。如果需要在运行时确定类型信息，也说明设计存在缺陷（参考RTTI）。</p>
<h1 id="5-10-流（Streams）"><a href="#5-10-流（Streams）" class="headerlink" title="5.10 流（Streams）"></a>5.10 流（Streams）</h1><p>在记录日志之外尽量少使用流。</p>
<p>定义：流是printf()和scanf()的替代。</p>
<p>优点：有了流，在输出时不需要关心对象的类型，不用担心格式化字符串与参数列表不匹配（虽然在gcc中使用printf也不存在这个问题），打开、关闭对应文件时，流可以自动构造和析构。</p>
<p>缺点：流使得pread()等功能函数很难执行，如果不使用printf之类的函数而是使用流很难对格式进行操作（尤其是常用的格式字符串%.*s），流不支持字符串操作符重新定序（%1s），而这一点对国际化很有用。</p>
<p>结论：尽量不要使用流，除非是日志接口需要，使用printf之类的代替。</p>
<p>使用流还有很多利弊，代码一致性胜过一切，尽量不要在代码中使用流。</p>
<p>拓展讨论：</p>
<p>对返一条规则存在一些争论，这儿给出深层次原因。回忆唯一性原则（Only One Way）：我们希望在人何时候都只使用一种确定的I/O类型，使代码在所有I/O处保持一致。因此，我们不希望用户来决定是使用流还是printf + read/write，我们应该决定到底用哪一种方式。把日志作为例外是因为流非常适合这么做，也有一定的历史原因。</p>
<p>流的支持者们主张流是不二之选，但观点并不是那么清晰有力，他们所指出流的所有优势也正是其劣势所在。流最大的优势是在输出时不需要关心输出对象的类型，这是一个亮点，也是一个不足：很容易用错类型，而编译器不会报警。使用流时容易造成的一类错误是：</p>
<pre><code>cout &lt;&lt; this; // Prints the address

cout &lt;&lt; *this; // Prints the contents
</code></pre><p>编译器不会报错，因为&lt;&lt;被重载，就因为这一点我们反对滥用操作符重载。</p>
<p>有人说printf的格式化丑陋不堪、易读性差，但流也好不到哪儿去。看看下面两段代码吧，哪个更加易读？</p>
<pre><code>cerr &lt;&lt; &quot;Error connecting to &apos;&quot; &lt;&lt; foo-&gt;bar()-&gt;hostname.first &lt;&lt; &quot;:&quot; &lt;&lt; foo-&gt;bar()-&gt;hostname.second &lt;&lt; &quot;: &quot; &lt;&lt; strerror(errno); 

fprintf(stderr, &quot;Error connecting to &apos;%s:%u: %s&quot;, foo-&gt;bar()-&gt;hostname.first, foo-&gt;bar()-&gt;hostname.second, strerror(errno));
</code></pre><p>你可能会说，“把流封装一下就会比较好了”，这儿可以，其它地方呢？而丏不要忘了，我们的目标是使语言尽可能小，而不是添加一些别人需要学习的新的内容。</p>
<p>每一种方式都是各有利弊，“没有最好，只有更好”，简单化的教条告诫我们从中选择其一，最后的多数决定是printf + read/write。</p>
<h1 id="5-11-前置自增和自减（Preincrement-and-Predecrement）"><a href="#5-11-前置自增和自减（Preincrement-and-Predecrement）" class="headerlink" title="5.11 前置自增和自减（Preincrement and Predecrement）"></a>5.11 前置自增和自减（Preincrement and Predecrement）</h1><p>对于迭代器和其他模板对象使用前缀形式（++i）的自增、自减运算符。</p>
<p>定义：对于变量在自增（++i或i++）或自减（–i或i–）后表达式的值又没有没用到的情况下，需要确定到底是使用前置还是后置的自增自减。</p>
<p>优点：不考虑返回值的话，前置自增（++i）通常要比后置自增（i++）效率更高，因为后置的自增自减需要对表达式的值i进行一次拷贝，如果i是迭代器或其他非数值类型，拷贝的代价是比较大的。既然两种自增方式动作一样，不考虑表达式的值的情况下，为什么不直接使用前置自增呢？</p>
<p>缺点：C语言中，当表达式的值没有使用时，传统的做法是使用后置自增，特别是在for循环中，有些人觉得后置自增更加易懂，因为这很像自然语言，主语（i）在谓语动词（++）前。</p>
<p>结论：对简单数值（非对象）来说，两种都无所谓，对迭代器和模板类型来说，要使用前置自增（自减）。</p>
<h1 id="5-12-const的使用（Use-of-const）"><a href="#5-12-const的使用（Use-of-const）" class="headerlink" title="5.12 const的使用（Use of const）"></a>5.12 const的使用（Use of const）</h1><p>我们强烈建议在任何可以使用的情况下都要使用const。</p>
<p>定义：在声明的变量或参数前加上关键字const用于指明变量值不可修改（如const int foo），为类中的函数加上const限定表明该函数不会修改类成员变量的状态（如class Foo { int Bar(char c) const; };）。</p>
<p>优点：人们更容易理解变量是如何使用的，编辑器可以更好地进行类型检测、更好地生成代码。人们对编写正确的代码更加自信，因为他们知道所调用的函数被限定了能或不能修改变量值。即使是在无锁的多线程编程中，人们也知道什么样的函数是安全的。</p>
<p>缺点：如果你向一个函数传入const变量，函数原型中也必须是const的（否则变量需要const_cast类型转换），在调用库函数时这尤其麻烦。</p>
<p>结论：const变量、数据成员、函数和参数为编译时类型检测增加了一层保障，更好的尽早发现错误。因此，强烈建议在任何可以使用的情况下使用const：</p>
<p>1) 如果函数不会修改传入的引用或指针类型的参数，这样的参数应该为const；</p>
<p>2) 尽可能将函数声明为const，访问函数应该总是const，其他函数如果不会修改任何数据成员也应该是const，不要调用非const函数，不要返回对数据成员的非const指针或引用；</p>
<p>3) 如果数据成员在对象构造之后不再改变，可将其定义为const。</p>
<p>然而，也不要对const过度使用，像const int <em> const </em> const x;就有些过了，即便这样写精确描述了x，其实写成const int** x就可以了。</p>
<p>关键字mutable可以使用，但是在多线程中是不安全的，使用时首先要考虑线程安全。</p>
<p>const位置：</p>
<p>有人喜欢int const <em>foo形式不喜欢const int</em> foo，他们认为前者更加一致因此可读性更好：遵循了const总位于其描述的对象（int）之后的原则。但是，一致性原则不适用于此，“不要过度使用”的权威抵消了一致性使用。将const放在前面才更易读，因为在自然语言中形容词（const）是在名词（int）之前的。</p>
<p>这是说，提倡const在前，并不是要求，但要兼顾代码的一致性！</p>
<h1 id="5-13-整型（Integer-Types）"><a href="#5-13-整型（Integer-Types）" class="headerlink" title="5.13 整型（Integer Types）"></a>5.13 整型（Integer Types）</h1><p>C++内建整型中，唯一用到的是int，如果程序中需要不同大小的发量，可以使用<stdint.h>中的精确宽度（precise-width）的整型，如int16_t。</stdint.h></p>
<p>定义：C++没有指定整型的大小，通常人们认为short是16位，int是32位，long是32位，long long是64位。</p>
<p>优点：保持声明统一。</p>
<p>缺点：C++中整型大小因编译器和体系结构的不同而不同。</p>
<p>结论： <stdint.h>定义了int16_t、uint32_t、int64_t等整型，在需要确定大小的整型时可以使用它们代替short、unsigned long long等，在C整型中，只使用int。适当情况下，推荐使用标准类型如size_t和ptrdiff_t。</stdint.h></p>
<p>最常使用的是，对整数来说，通常不会用到太大，如循环计数等，可以使用普通的int。你可以认为int至少为32位，但不要认为它会多亍32位，需要64位整型的话，可以使用int64_t戒uint64_t。</p>
<p>对于大整数，使用int64_t。</p>
<p>不要使用uint32_t等无符号整型，除非你是在表示一个位组（bit pattern）而不是一个数值。即使数值不会为负值也不要使用无符号类型，因为计算机只会根据变量、返回值等有无符号确定数值正负，仍然无法确定对错。使用断言（assertion）来保护数据。</p>
<p>无符号整型： 有些人，包括一些教科书作者，推荐使用无符号类型表示非负数，类型表明了数值取值形式。但是，在C语言中，这一优点被由其导致的bugs所淹没。看看：</p>
<p>for (unsigned int i = foo.Length()-1; i &gt;= 0; –i) …</p>
<p>上述代码永远不会终止！有时gcc会发现该bug幵报警，但通常不会。类似的bug还会出现在比较有符号变量和无符号变量时，主要是C的类型提升机制（type-promotion scheme，C语言中各种内建类型之间的提升转换关系）会致使无符号类型的行为出乎你的意料。</p>
<p>因此，使用断言声明变量为非负数，不要使用无符号型。</p>
<h1 id="5-14-预处理宏（Preprocessor-Macros）"><a href="#5-14-预处理宏（Preprocessor-Macros）" class="headerlink" title="5.14 预处理宏（Preprocessor Macros）"></a>5.14 预处理宏（Preprocessor Macros）</h1><p>使用宏时要谨慎，尽量以内联函数、枚举和常量代替之。</p>
<p>宏意味着你和编译器看到的代码是不同的，因此可能导致异常行为，尤其是当宏存在于全局作用域中。</p>
<p>值得庆幸的是，C++中，宏不像C中那么必要。宏内联效率关键代码（performance-critical code）可以用内联函数替代；宏存储常量可以const变量替代；宏“缩写”长变量名可以引用替代；使用宏进行条件编译，这个……，最好不要这么做，会令测试更加痛苦（#define防止头文件重复包含当然是个例外）。 宏可以做一些其它技术无法实现的事情，在一些代码库（尤其是底层库中）可以看到宏的某些特性（如字符串化（stringifying，使用#）、连接（concatenation，使用##）等等）。但在使用前，仔细考虑一下能不能不使用宏实现同样效果。</p>
<p>关于宏的高级应用，可以参考《C诧言宏的高级应用》。 </p>
<p>下面给出的用法模式可以避免一些使用宏的问题，供使用宏时参考：</p>
<p>1) 不要在.h文件中定义宏；</p>
<p>2) 使用前正确#define，使用后正确#undef；</p>
<p>3) 不要只是对已经存在的宏使用#undef，选择一个不会冲突的名称；</p>
<p>4) 不使用会导致不稳定的C++构造（unbalanced C++ constructs）的宏，至少文档说明其行为。</p>
<h1 id="5-15-0和NULL（0-and-NULL）"><a href="#5-15-0和NULL（0-and-NULL）" class="headerlink" title="5.15 0和NULL（0 and NULL）"></a>5.15 0和NULL（0 and NULL）</h1><p>整数用0，实数用0.0，指针用NULL，字符（串）用’\0’。</p>
<p>整数用0，实数用0.0，这一点是毫无争议的。</p>
<p>对于指针（地址值），到底是用0还是NULL，Bjarne Stroustrup建议使用最原始的0，我们建议使用看上去像是指针的NULL，事实上一些C++编译器（如gcc 4.1.0）与门提供了NULL的定义，可以给出有用的警告，尤其是sizeof(NULL)和sizeof(0)不相等的情况。</p>
<p>字符（串）用’\0’，不仅类型正确而且可读性好。</p>
<h1 id="5-16-sizeof（sizeof）"><a href="#5-16-sizeof（sizeof）" class="headerlink" title="5.16 sizeof（sizeof）"></a>5.16 sizeof（sizeof）</h1><p>尽可能用sizeof(varname)代替sizeof(type)。</p>
<p>使用sizeof(varname)是因为当变量类型改变时代码自动同步，有些情况下sizeof(type)或许有意义，还是要尽量避免，如果变量类型改变的话不能同步。</p>
<pre><code>Struct data;

memset(&amp;data, 0, sizeof(data));

memset(&amp;data, 0, sizeof(Struct));
</code></pre><h1 id="5-17-Boost库（Boost）"><a href="#5-17-Boost库（Boost）" class="headerlink" title="5.17 Boost库（Boost）"></a>5.17 Boost库（Boost）</h1><p>尽可能使用Boost中被认可的库。</p>
<p>定义：Boost库是一个非常受欢迎的、广泛接受的、免费的开源的C++库。</p>
<p>优点：Boost代码质量普遍较高、可移植性好，填补了C++标准库的很多空白，如traits特性（type traits）、更完善的绑定（binders）、更好的智能指针，同时还提供了TR1（标准库的扩展）的实现。</p>
<p>缺点：某些Boost库提倡的编程实践可读性差，像模板元编程（metaprogramming）和其它高级模板技术，以及过度“函数化”（”functional”）的编程风格。</p>
<p>结论：为了向阅读和维护代码的人员提供更好的可读性，我们尽可能使用Boost特性的一个成熟子集，那些业界广为接受的部分。</p>
<p>我们会积极考虑添加新的Boost特性，所以不必拘泥于该规则。</p>
<h1 id="5-18-Summary"><a href="#5-18-Summary" class="headerlink" title="5.18 Summary"></a>5.18 Summary</h1><ol>
<li><p>对于智能指针，安全第一、方便第二，尽可能使用boost版本（scoped_ptr）；</p>
</li>
<li><p>引用形参加上const，否则使用指针形参；</p>
</li>
<li><p>函数重载的使用要清晰、易读；</p>
</li>
<li><p>鉴于容易误用，谨慎使用缺省函数参数；</p>
</li>
<li><p>禁止使用变长数组；</p>
</li>
<li><p>合理使用友元；</p>
</li>
<li><p>为了方便代码管理，谨慎使用异常；</p>
</li>
<li><p>谨慎使用RTTI，先考虑重新设计代码；</p>
</li>
<li><p>使用C++风格的类型转换，除单元测试外不要使用dynamic_cast；</p>
</li>
<li><p>使用流还是printf + read/write，it is a problem；</p>
</li>
<li><p>能用前置自增/减不用后置自增/减；</p>
</li>
<li><p>const能用则用，提倡const在前；</p>
</li>
<li><p>使用确定大小的整型，除位组外不要使用无符号型； </p>
</li>
<li><p>格式化输出及结构对齐时，注意32位和64位的系统差异；</p>
</li>
<li><p>除字符串化、避免重复编译外尽量避免使用宏；</p>
</li>
<li><p>整数用0，实数用0.0，指针用NULL，字符（串）用’\0’；</p>
</li>
<li><p>用sizeof(varname)代替sizeof(type)；</p>
</li>
<li><p>尽可能使用Boost中被认可的库。</p>
</li>
</ol>
<p>#[第六章 命名约定]</p>
<p>最重要的一致性规则是命名管理，命名风格直接可以直接确定命名对象是：类型、发量、函数、常量、宏等等，无需查找对象声明，我们大脑中的模式匹配引擎依赖于这些命名规则。</p>
<p>命名规则具有一定随意性，但相比按个人喜好命名，一致性更重要，所以不管程序员怎么想，规则总归是规则。</p>
<h1 id="6-1-通用命名规则（General-Naming-Rules）"><a href="#6-1-通用命名规则（General-Naming-Rules）" class="headerlink" title="6.1 通用命名规则（General Naming Rules）"></a>6.1 通用命名规则（General Naming Rules）</h1><p>函数命名、变量命名、文件命名应具有描述性，不要过度缩写，类型和变量应该是名词，函数名可以用“命令性”动词。</p>
<p>如何命名：</p>
<p>尽可能给出描述性名称，不要节约空间，让别人很快理解你的代码更重要，好的命名选择：</p>
<pre><code>int num_errors; // Good.

int num_completed_connections; // Good.
</code></pre><p>丑陋的命名使用模糊的缩写或随意的字符：</p>
<pre><code>int n; // Bad - meaningless.

int nerr; // Bad - ambiguous abbreviation.

int n_comp_conns; // Bad - ambiguous abbreviation.
</code></pre><p>类型和变量名一般为名词：如<code>FileOpener、num_errors</code>。</p>
<p>函数名通常是动作性的，如<code>OpenFile()、set_num_errors()</code>，访问函数需要描述的更细致，要与其访问的变量相吻合。</p>
<p>缩写： 除非放到项目外也非常明了，否则不要使用缩写，例如：</p>
<pre><code>// Good

// These show proper names with no abbreviations.

int num_dns_connections; // Most people know what &quot;DNS&quot; stands for.

int price_count_reader; // OK, price count. Makes sense.



// Bad!

// Abbreviations can be confusing or ambiguous outside a small group.

int wgc_connections; // Only your group knows what this stands for.

int pc_reader; // Lots of things can be abbreviated &quot;pc&quot;.
</code></pre><p>不要用省略字母的缩写：</p>
<pre><code>int error_count; // Good.

int error_cnt; // Bad.
</code></pre><h1 id="6-2-文件命名（File-Names）"><a href="#6-2-文件命名（File-Names）" class="headerlink" title="6.2 文件命名（File Names）"></a>6.2 文件命名（File Names）</h1><p>文件名要全部小写，可以包含下划线（_）或短线（-），按项目内容来命名。</p>
<p>可接受的文件命名：</p>
<pre><code>my_useful_class.cc

my-useful-class.cc

myusefulclass.cc
</code></pre><p>C++文件以.cpp结尾，头文件以.h结尾。</p>
<p>不要使用已经存在于/usr/include下的文件名（对UNIX、Linux等系统而言），如db.h。</p>
<p>通常，尽量让文件名更加明确，<code>http_server_logs.h</code>就比logs.h要好，定义类时文件名一般成对出现，如<code>foo_bar.h</code>和<code>foo_bar.cpp</code>，对应类CFooBar。</p>
<p>内联函数必须放在.h文件中，如果内联函数比较短，就直接放在.h中。如果代码比较长，可以放到以<code>_&lt;inline&gt;.h</code>结尾的文件中。对于包含大量内联代码的类，可以有三个文件：</p>
<pre><code>url_table.h // The class declaration.

url_table.cpp // The class definition.

url_table_inline.h // Inline functions that include lots of code.
</code></pre><p>参考第一篇<code>_&lt;inline&gt;.h</code>文件一节。</p>
<h1 id="6-3-类型命名（Type-Names）"><a href="#6-3-类型命名（Type-Names）" class="headerlink" title="6.3 类型命名（Type Names）"></a>6.3 类型命名（Type Names）</h1><p>类型命名每个单词以大写字母C开头，不包含下划线：</p>
<p>CIDPHandler</p>
<p>CHostManager</p>
<p>所有类型命名——类、结构体、类型定义（typedef）、枚举丼——使用相同约定，例如：</p>
<pre><code>// classes and structs

class UrlTable { ...

class UrlTableTester { ...

struct UrlTableProperties { ...



// typedefs

typedef hash_map&lt;UrlTableProperties *, string&gt; PropertiesMap;



// enums

enum UrlTableErrors { ...
</code></pre><h1 id="6-4-变量命名（Variable-Names）"><a href="#6-4-变量命名（Variable-Names）" class="headerlink" title="6.4 变量命名（Variable Names）"></a>6.4 变量命名（Variable Names）</h1><p>变量名一律小写，单词间以下划线相连，如my_exciting_local_variable、my_exciting_member<em>variable</em>。 </p>
<p>普通变量命名：</p>
<p>举例：</p>
<pre><code>string table_name; // OK - uses underscore.

string tablename; // OK - all lowercase.

string tableName; // Bad - mixed case.
</code></pre><p>类数据成员：</p>
<p>结构体的数据成员和普通变量一样：</p>
<pre><code>struct UrlTableProperties {

      string name;

      int num_entries;

}
</code></pre><p>全局变量：</p>
<p>对全局变量没有特别要求，少用就好，可以以g_或其他易与局部变量区分的标志为前缀。</p>
<h1 id="6-5-常量命名（Constant-Names）"><a href="#6-5-常量命名（Constant-Names）" class="headerlink" title="6.5 常量命名（Constant Names）"></a>6.5 常量命名（Constant Names）</h1><p>所有编译时常量（无论是局部的、全局的还是类中的）和其它变量保持些许区别，k后接大写字母开头的单词：</p>
<pre><code>const int kDaysInAWeek = 7;
</code></pre><h1 id="6-6-函数命名（Function-Names）"><a href="#6-6-函数命名（Function-Names）" class="headerlink" title="6.6 函数命名（Function Names）"></a>6.6 函数命名（Function Names）</h1><p>普通函数大小写混合，存取函数（accessors and mutators）则要求与变量名匹配：</p>
<pre><code>MyExcitingFunction()

get_my_exciting_member_variable()

set_my_exciting_member_variable()
</code></pre><p>普通函数：</p>
<p>函数名以大写字母开头，每个单词首字母大写，没有下划线：</p>
<pre><code>AddTableEntry()

DeleteUrl()
</code></pre><p>存取函数：</p>
<p>存取函数要与存取的变量名匹配，这儿摘录一个拥有实例变量num<em>entries</em>的类：</p>
<pre><code>class MyClass {

public:

      ...

      int get_num_entries() const { return num_entries_; }

      void set_num_entries(int num_entries) { num_entries_ = num_entries; }



private:

      int num_entries_;

};
</code></pre><p>其它短小的内联函数名也可以使用小写字母，例如，在循环中调用这样的函数甚至都不需要缓存其值，小写命名就可以接受。</p>
<p>注：从这一点上可以看出，小写的函数名意味着可以直接内联使用。</p>
<h1 id="6-7-命名空间（Namespace-Names）"><a href="#6-7-命名空间（Namespace-Names）" class="headerlink" title="6.7 命名空间（Namespace Names）"></a>6.7 命名空间（Namespace Names）</h1><p>命名空间的名称是全小写的，其命名基于项目名称和模块内容：videosphere。</p>
<p>关于命名空间的讨论和如何命名，参考第二篇命名空间。</p>
<h1 id="6-8-枚举命名（Enumerator-Names）"><a href="#6-8-枚举命名（Enumerator-Names）" class="headerlink" title="6.8 枚举命名（Enumerator Names）"></a>6.8 枚举命名（Enumerator Names）</h1><p>枚举值应全部大写，单词间以下划线相连：</p>
<pre><code>MY_EXCITING_ENUM_VALUE。
</code></pre><p>枚举名称属于类型，因此大小写混合：</p>
<pre><code>UrlTableErrors。

enum UrlTableErrors {

      OK = 0,

      ERROR_OUT_OF_MEMORY,

       ERROR_MALFORMED_INPUT,

};
</code></pre><h1 id="6-9-宏命名（Macro-Names）"><a href="#6-9-宏命名（Macro-Names）" class="headerlink" title="6.9 宏命名（Macro Names）"></a>6.9 宏命名（Macro Names）</h1><p>你并不打算使用宏，对吧？如果使用，像这样：</p>
<pre><code>MY_MACRO_THAT_SCARES_SMALL_CHILDREN。
</code></pre><p>参考第四篇预处理宏，通常是不使用宏的，如果一定要用，其命名像枚举命名一样全部大写、使用下划线：</p>
<pre><code>#define ROUND(x) ...

#define PI_ROUNDED 3.0

MY_EXCITING_ENUM_VALUE
</code></pre><h1 id="6-10例外（Exceptions）"><a href="#6-10例外（Exceptions）" class="headerlink" title="6.10例外（Exceptions）"></a>6.10例外（Exceptions）</h1><p>当命名与现有C/C++实体相似的对象时，可参考现有命名约定：</p>
<p>类似系统调用函数名，参考系统调用open()</p>
<p>typedef类型定义</p>
<p>struct或class</p>
<p>STL相似实体；参考STL命名约定</p>
<p><code>LONGLONG_MAX</code> 常量，类似<code>INT_MAX</code></p>
<h1 id="6-11-Summary"><a href="#6-11-Summary" class="headerlink" title="6.11 Summary"></a>6.11 Summary</h1><ol>
<li><p>总体规则：不要随意缩写，如果说ChangeLocalValue写作ChgLocVal还有情可原的话，把ModifyPlayerName写作MdfPlyNm就太过分了，除函数名可适当为动词外，其它命名尽量使用清晰易懂的名词；</p>
</li>
<li><p>宏、枚举等使用全部大写+下划线；</p>
</li>
<li><p>变量（含类、结构体成员变量）、文件、命名空间、存取函数等使用全部小写+下划线，类成员发量以下划线结尾，全局变量以g_开头；</p>
</li>
<li><p>普通函数、类型（含类与结构体、枚举类型）、常量等使用大小写混合，不含下划线；</p>
</li>
<li><p>参考现有或相近命名约定。</p>
</li>
</ol>
<p>#[第七章 代码注释]</p>
<p>注释</p>
<p>注释虽然写起来很痛苦，但对保证代码可读性至为重要，下面的规则描述了应该注释什么、注释在哪儿。当然也要记住，注释的确很重要，但最好的代码本身就是文档（self-documenting），类型和变量命名意义明确要比通过注释解释模糊的命名好得多。</p>
<p>注释是为别人（下一个需要理解你的代码的人）而写的，认真点吧，下一个可能就是你！</p>
<h1 id="7-1-注释风格（Comment-Style）"><a href="#7-1-注释风格（Comment-Style）" class="headerlink" title="7.1 注释风格（Comment Style）"></a>7.1 注释风格（Comment Style）</h1><p>使用//或/<em> </em>/，统一就好。</p>
<p>//或/<em> </em>/都可以，//用的更加广泛，注意在如何注释和注释风格上确保统一。</p>
<h1 id="7-2-文件注释（File-Comments）"><a href="#7-2-文件注释（File-Comments）" class="headerlink" title="7.2 文件注释（File Comments）"></a>7.2 文件注释（File Comments）</h1><p>在每一个文件开头加入版权公告，然后是文件内容描述。</p>
<p>法律公告和作者信息：</p>
<p>每一个文件注释包含以下项，依次是：</p>
<p>1) 版权（copyright statement）：如Copyright 2008 MarchNetworks.；</p>
<p>2) 许可版本（license boilerplate）：为项目选择合适的许可证版本，如Apache 2.0、BSD、LGPL、GPL；</p>
<p>3) 作者（author line）：标识文件的原始作者。</p>
<p>如果你对其他人创建的文件做了重大修改，将你的信息添加到作者信息里，这样当其他人对该文件有疑问时可以知道该联系谁。</p>
<p>文件内容：</p>
<p>每一个文件版权许可及作者信息后，都要对文件内容进行注释说明。</p>
<p>通常，.h文件要对所声明的类的功能和用法作简单说明，.cpp文件包含了更多的实现细节或算法讨论，如果你感觉返些实现细节或算法讨论对亍阅读有帮助，可以把.cpp中的注释放到.h中，并在.cpp中指出文档在.h中。</p>
<p>不要单纯在.h和.cpp间复制注释，复制的注释偏离了实际意义。</p>
<h1 id="7-3-类注释（Class-Comments）"><a href="#7-3-类注释（Class-Comments）" class="headerlink" title="7.3 类注释（Class Comments）"></a>7.3 类注释（Class Comments）</h1><p>每个类的定义要附着描述类的功能和用法的注释。</p>
<pre><code>// Iterates over the contents of a GargantuanTable. Sample usage:

// GargantuanTable_Iterator* iter = table-&gt;NewIterator();

// for (iter-&gt;Seek(&quot;foo&quot;); !iter-&gt;done(); iter-&gt;Next()) {

// process(iter-&gt;key(), iter-&gt;value());

// }

// delete iter;



class GargantuanTable_Iterator {

       ...

};
</code></pre><p>如果你觉得已经在文件顶部详绅描述了该类，想直接简单的来上一句“完整描述见文件顶部”的话，还是多少在类中加点注释吧。</p>
<p>如果类有任何同步前提（synchronization assumptions），文档说明之。如果该类的实例可被多线程访问，使用时务必注意文档说明。</p>
<h1 id="7-4-函数注释（Function-Comments）"><a href="#7-4-函数注释（Function-Comments）" class="headerlink" title="7.4 函数注释（Function Comments）"></a>7.4 函数注释（Function Comments）</h1><p>函数声明处注释描述函数功能，定义处描述函数实现。</p>
<p>函数声明：</p>
<p>注释于声明之前，描述函数功能及用法，注释使用描述式（”It opens the file”）而非命令式（”Open file”）；</p>
<p>注释只是为了描述函数而不是告诉函数做什么。通常，注释不会描述函数如何实现，那是定义部分的事情。</p>
<p>函数声明处注释的内容：</p>
<p>1) inputs（输入）及outputs（输出）；</p>
<p>2) 对类成员函数而言：函数调用期间对象是否需要保持引用参数，是否会释放这些参数；</p>
<p>3) 如果函数分配了空间，需要由调用者释放；</p>
<p>4) 参数是否可以为NULL；</p>
<p>5) 是否存在函数使用的性能隐患（performance implications）；</p>
<p>6) 如果函数是可重入的（re-entrant），其同步前提（synchronization assumptions）是什么？</p>
<p>举例如下：</p>
<pre><code>// Returns an iterator for this table. It is the client&apos;s

// responsibility to delete the iterator when it is done with it,

// and it must not use the iterator once the GargantuanTable object

// on which the iterator was created has been deleted.

//

// The iterator is initially positioned at the beginning of the table.

//

// This method is equivalent to:

// Iterator* iter = table-&gt;NewIterator();

// iter-&gt;Seek(&quot;&quot;);

// return iter;

// If you are going to immediately seek to another place in the 

// returned iterator, it will be faster to use NewIterator()

// and avoid the extra seek.

Iterator* GetIterator() const;
</code></pre><p>但不要有无谓冗余或显而易见的注释，下面的注释就没有必要加上“returns false otherwise”，因为已经暗含其中了：</p>
<pre><code>// Returns true if the table cannot hold any more entries.

bool IsTableFull();
</code></pre><p>注释构造/析构函数时，记住，读代码的人知道构造/析构函数是什么，所以“destroys this object”者样的注释是没有意义的。说明构造函数对参数做了什么（例如，是否是指针的拥有者）以及析构函数清理了什么，如果都是无关紧要的内容，直接省掉注释，析构函数前没有注释是徆正常的。</p>
<p>函数定义：</p>
<p>每个函数定义时要以注释说明函数功能和实现要点，如使用的漂亮代码、实现的简要步骤、如此实现的理由、为什么前半部分要加锁而后半部分不需要。</p>
<p>不要从.h文件或其他地方的函数声明处直接复制注释，简要说明函数功能是可以的，但重点要放在如何实现上。</p>
<h1 id="7-5-变量注释（Variable-Comments）"><a href="#7-5-变量注释（Variable-Comments）" class="headerlink" title="7.5 变量注释（Variable Comments）"></a>7.5 变量注释（Variable Comments）</h1><p>通常变量名本身足以很好说明变量用途，特定情况下，需要额外注释说明。</p>
<p>类数据成员：</p>
<p>每个类数据成员（也叫实例变量或成员变量）应注释说明用途，如果变量可以接受NULL或-1等敏感值（sentinel values），须说明之，如：</p>
<pre><code>private:

// Keeps track of the total number of entries in the table.

// Used to ensure we do not go over the limit. -1 means

// that we don&apos;t yet know how many entries the table has.

int num_total_entries_;
</code></pre><p>全局变量（常量）：</p>
<p>和数据成员相似，所有全局变量（常量）也应注释说明含义及用途，如：</p>
<pre><code>// The total number of tests cases that we run through in this regression test.

const int kNumTestCases = 6;
</code></pre><h1 id="7-6-实现注释（Implementation-Comments）"><a href="#7-6-实现注释（Implementation-Comments）" class="headerlink" title="7.6 实现注释（Implementation Comments）"></a>7.6 实现注释（Implementation Comments）</h1><p>对于实现代码中巧妙的、晦涩的、有趣的、重要的地方加以注释。</p>
<p>代码前注释：</p>
<p>出彩的或复杂的代码块前要加注释，如：</p>
<pre><code>// Divide result by two, taking into account that x

// contains the carry from the add.

for (int i = 0; i &lt; result-&gt;size(); i++) {

      x = (x &lt;&lt; 8) + (*result)[i];

      (*result)[i] = x &gt;&gt; 1;

      x &amp;= 1;

}
</code></pre><p>行注释：</p>
<p>比较隐晦的地方要在行尾加入注释，可以在代码之后空两格加行尾注释，如：</p>
<pre><code>// If we have enough memory, mmap the data portion too.

mmap_budget = max&lt;int64&gt;(0, mmap_budget - index_-&gt;length());

if (mmap_budget &gt;= data_size_ &amp;&amp; !MmapData(mmap_chunk_bytes, mlock))

      return;   // Error already logged.
</code></pre><p>注意，有两块注释描述这段代码，当函数返回时注释提及错误已经被记入日志。</p>
<p>前后相邻几行都有注释，可以适当调整使之可读性更好：</p>
<pre><code>...

DoSomething(); // Comment here so the comments line up.

DoSomethingElseThatIsLonger(); // Comment here so there are two spaces between

                                                        // the code and the comment.



...

NULL、true/false、1、2、3……：
</code></pre><p>向函数传入、布尔值或整数时，要注释说明含义，或使用常量让代码望文知意，比较一下：</p>
<pre><code>bool success = CalculateSomething(interesting_value, 10, false, NULL); // What are these arguments??
</code></pre><p>和：</p>
<pre><code>bool success = CalculateSomething(interesting_value,

                                                                               10, // Default base value.

                                                                               false, // Not the first time we&apos;re calling this.

                                                                               NULL); // No callback.
</code></pre><p>使用常量或描述性变量：</p>
<pre><code>const int kDefaultBaseValue = 10;

const bool kFirstTimeCalling = false;

Callback *null_callback = NULL;

bool success = CalculateSomething(interesting_value,

                                                          kDefaultBaseValue,

                                                          kFirstTimeCalling, 

                                                          null_callback);
</code></pre><p>不要： 注意永远不要用自然语言翻译代码作为注释，要假设读你代码的人C++比你强:D：</p>
<pre><code>// Now go through the b array and make sure that if i occurs,

// the next element is i+1.

...

// Geez. What a useless comment.
</code></pre><h1 id="7-7-标点、拼写和语法（Punctuation-Spelling-and-Grammar）"><a href="#7-7-标点、拼写和语法（Punctuation-Spelling-and-Grammar）" class="headerlink" title="7.7  标点、拼写和语法（Punctuation, Spelling and Grammar）"></a>7.7  标点、拼写和语法（Punctuation, Spelling and Grammar）</h1><p>留意标点、拼写和语法，写的好的注释比差的要易读的多。</p>
<p>注释一般是包含适当大写和句点（.）的完整的句子，短一点的注释（如代码行尾的注释）可以随意点，依然要注意风格的一致性。完整的句子可读性更好，也可以说明该注释是完整的而不是不成熟的想法。</p>
<p>虽然被别人指出该用分号（semicolon）的时候用了逗号（comma）有点尴尬。清晰易读的代码还是很重要的，适当的标点、拼写和语法对此会有所帮助。</p>
<h1 id="7-8-TODO注释（TODO-Comments）"><a href="#7-8-TODO注释（TODO-Comments）" class="headerlink" title="7.8 TODO注释（TODO Comments）"></a>7.8 TODO注释（TODO Comments）</h1><p>对那些临时的、短期的解决方案，或已经够好但并不完美的代码使用TODO注释。</p>
<p>这样的注释要使用全大写的字符串TODO，后面括号（parentheses）里加上你的大名、邮件地址等，还可以加上冒号（colon）：目的是可以根据统一的TODO格式进行查找：</p>
<pre><code>// TODO(kl@gmail.com): Use a &quot;*&quot; here for concatenation operator.

// TODO(Zeke) change this to use relations.
</code></pre><p>如果是为了在“将来某一天做某事”，可以加上一个特定的时间（”Fix by November 2005”）或事件</p>
<pre><code>（&quot;Remove this code when all clients can handle XML responses.&quot;）。
</code></pre><h1 id="7-9-Summary"><a href="#7-9-Summary" class="headerlink" title="7.9 Summary"></a>7.9 Summary</h1><ol>
<li><p>关于注释风格，很多C++的coders更喜欢行注释，C coders或许对块注释依然情有独钟，或者在文件头大段大段的注释时使用块注释；</p>
</li>
<li><p>文件注释可以炫耀你的成就，也是为了捅了篓子别人可以找你；</p>
</li>
<li><p>注释要言简意赅，不要拖沓冗余，复杂的东西简单化和简单的东西复杂化都是要被鄙视的；</p>
</li>
<li><p>对于Chinese coders来说，用英文注释还是用中文注释，it is a problem，但不管怎样，注释是为了让别人看懂，难道是为了炫耀编程语言之外的你的母语或外语水平吗；</p>
</li>
<li><p>注释不要太乱，适当的缩进才会让人乐意看，但也没有必要规定注释从第几列开始，UNIX/LINUX下还可以约定是使用tab还是space，个人倾向亍space；</p>
</li>
<li><p>TODO很不错，有时候，注释确实是为了标记一些未完成的或完成的不尽如人意的地方，这样一搜索，就知道还有哪些活要干，日志都省了。</p>
</li>
</ol>
<p>#[第八章 格式]</p>
<p>代码风格和格式确实比较随意，但一个项目中所有人遵循同一风格是非常容易的，作为编程人员未必遵守下述格式规则的每一条，但整个项目服从统一的编程风格是很重要的，这样做才能让所有人在阅读和理解代码时更加容易。</p>
<h1 id="8-1-行长度（Line-Length）"><a href="#8-1-行长度（Line-Length）" class="headerlink" title="8.1 行长度（Line Length）"></a>8.1 行长度（Line Length）</h1><p>每一行代码字符数不超过80。</p>
<p>这条规则是存有争议的，但如此多的代码都遵照这一规则，一致性更重要。</p>
<p>优点：提倡该原则的人认为强迫他们调整编辑器窗口大小很野蛮。好热闹多人同时并排开几个窗口，根本没有多余空间拓宽某个窗口，人们将窗口最大尺寸加以限定，一致使用80列宽，为什么要改变呢？</p>
<p>缺点：反对该原则的人则认为更宽的代码行更易阅读，80列的限制是上个世纪60年代的大型机的古板缺陷；现代设备具有更宽的显示屏，很轻松的可以显示更多代码。</p>
<p>结论：80个字符是最大值。例外：</p>
<p>1) 如果一行注释包含了超过80字符的命令或URL，出亍复制粘贴的方便可以超过80字符；</p>
<p>2) 包含长路径的可以超出80列，尽量避免；</p>
<p>3) 头文件保护（防止重复包含第一篇）可以无视该原则。</p>
<h1 id="8-2-非ASCII字符（Non-ASCII-Characters）"><a href="#8-2-非ASCII字符（Non-ASCII-Characters）" class="headerlink" title="8.2 非ASCII字符（Non-ASCII Characters）"></a>8.2 非ASCII字符（Non-ASCII Characters）</h1><p>尽量不使用非ASCII字符，使用时必须使用UTF-8格式。</p>
<p>哪怕是英文，也不应将用户界面的文本硬编码到源代码中，因此非ASCII字符要少用。特殊情况下可以适当包含此类字符，如，代码分析外部数据文件时，可以适当硬编码数据文件中作为分隔符的非ASCII字符串；更常用的是单元测试代码可能包含非ASCII字符串。此类情况下，应使用UTF-8格式，因为很多工具都可以理解和处理其编码，十六迕制编码也可以，尤其是在增强可读性的情况下——如”\xEF\xBB\xBF”是Unicode的zero-width no-break space字符，以UTF-8格式包含在源文件中是不可见的。</p>
<h1 id="8-3-空格还是制表位（Spaces-vs-Tabs）"><a href="#8-3-空格还是制表位（Spaces-vs-Tabs）" class="headerlink" title="8.3 空格还是制表位（Spaces vs. Tabs）"></a>8.3 空格还是制表位（Spaces vs. Tabs）</h1><p>只使用空格，每次缩进2个空格。</p>
<p>使用空格进行缩进，步要在代码中使用tabs，设定编辑器将tab转为空格。</p>
<h1 id="8-4-函数声明与定义（Function-Declarations-and-Definitions）"><a href="#8-4-函数声明与定义（Function-Declarations-and-Definitions）" class="headerlink" title="8.4 函数声明与定义（Function Declarations and Definitions）"></a>8.4 函数声明与定义（Function Declarations and Definitions）</h1><p>返回类型和函数名在同一行，合适的话，参数也放在同一行。</p>
<p>函数看上去像这样：</p>
<pre><code>ReturnType ClassName::FunctionName(Type par_name1, Type par_name2) {

      DoSomething();

      ...

}
</code></pre><p>如果同一行文本较多，容不下所有参数：</p>
<pre><code>ReturnType ClassName::ReallyLongFunctionName(Type par_name1,

                                                                                          Type par_name2,

                                                                                          Type par_name3) {

      DoSomething();

      ...

}
</code></pre><p>甚至还第一个参数都放不下：</p>
<pre><code>ReturnType LongClassName::ReallyReallyReallyLongFunctionName(

             Type par_name1, // 4 space indent

             Type par_name2,

             Type par_name3) {

      DoSomething(); // 2 space indent

      ...

}
</code></pre><p>注意以下几点：</p>
<p>1) 返回值总是和函数名在同一行；</p>
<p>2) 左圆括号（open parenthesis）总是和函数名在同一行；</p>
<p>3) 函数名和左圆括号间没有空格；</p>
<p>4) 圆括号与参数间没有空格；</p>
<p>5) 左大括号（open curly brace）总在最后一个参数同一行的末尾处；</p>
<p>6) 右大括号（close curly brace）总是单独位于函数最后一行；</p>
<p>7) 右圆括号（close parenthesis）和左大括号间总是有一个空格；</p>
<p>8) 函数声明和实现处的所有形参名称必须保持一致；</p>
<p>9) 所有形参应尽可能对齐；</p>
<p>10) 缺省缩进为2个空格；</p>
<p>11) 独立封装的参数保持4个空格的缩进。</p>
<p>如果函数为const的，关键字const应与最后一个参数位于同一行。</p>
<pre><code>// Everything in this function signature fits on a single line

ReturnType FunctionName(Type par) const {

      ...

}



// This function signature requires multiple lines, but

// the const keyword is on the line with the last parameter.

ReturnType ReallyLongFunctionName(Type par1, Type par2) const {

      ...

}
</code></pre><p>如果有些参数没有用到，在函数定义处将参数名注释起来：</p>
<pre><code>// Always have named parameters in interfaces.

class Shape {

public:

      virtual void Rotate(double radians) = 0;

}



// Always have named parameters in the declaration.

class Circle : public Shape {

public:

      virtual void Rotate(double radians);

}



// Comment out unused named parameters in definitions.

void Circle::Rotate(double /*radians*/) {}

// Bad - if someone wants to implement later, it&apos;s not clear what the

// variable means.

void Circle::Rotate(double) {}
</code></pre><p>注：关于UNIX/Linux风格为什么要把左大括号置亍行尾（.cpp文件的函数实现处，左大括号位于行首），我的理解是代码看上去比较简约，想想行首除了函数体被一对大括号封在一起之外，只有右大括号的代码看上去确实也舒服；Windows风格将左大括号置亍行首的优点是匹配情况一目了然。</p>
<h1 id="8-5-函数调用（Function-Calls）"><a href="#8-5-函数调用（Function-Calls）" class="headerlink" title="8.5 函数调用（Function Calls）"></a>8.5 函数调用（Function Calls）</h1><p>尽量放在同一行，否则，将实参封装在圆括号中。</p>
<p>函数调用遵循如下形式：</p>
<pre><code>bool retval = DoSomething(argument1, argument2, argument3);
</code></pre><p>如果同一行放不下，可断为多行，后面每一行都和第一个实参对齐，左圆括号后和右圆括号前不要留空格：</p>
<pre><code>bool retval = DoSomething(averyveryveryverylongargument1, argument2, argument3);
</code></pre><p>如果函数参数比较多，可以出于可读性的考虑每行只放一个参数：</p>
<pre><code>bool retval = DoSomething(argument1,

                                            argument2,

                                            argument3,

                                            argument4);
</code></pre><p>如果函数名太长，以至于超过行最大长度，可以将所有参数独立成行：</p>
<pre><code>if (...) {

      ...

      ...

      if (...) {

             DoSomethingThatRequiresALongFunctionName(

                           very_long_argument1, // 4 space indent

                           argument2,

                           argument3,

                           argument4);

      }

}
</code></pre><h1 id="8-6-条件语句（Conditionals）"><a href="#8-6-条件语句（Conditionals）" class="headerlink" title="8.6 条件语句（Conditionals）"></a>8.6 条件语句（Conditionals）</h1><p>更提倡不在圆括号中添加空格，关键字else另起一行。</p>
<p>对基本条件语句有两种可以接受的格式，一种在圆括号和条件之间有空格，一种没有。</p>
<p>最常见的是没有空格的格式，哪种都可以，还是一致性为主。如果你是在修改一个文件，参考当前已有格式；如果是写新的代码，参考目录下或项目中其它文件的格式。如果还在徘徊的话，就不要加空格了。</p>
<pre><code>if (condition) { // no spaces inside parentheses .

      .. // 2 space indent.

} else { // The else goes on the same line as the closing brace.

      ...

}
</code></pre><p>如果你倾向与在圆括号内部加空格：</p>
<pre><code>if ( condition ) { // spaces inside parentheses – rare

      ... // 2 space indent.

} else { // The else goes on the same line as the closing brace.

      ...

}
</code></pre><p>注意所有情况下if和左圆括号间有个空格，右圆括号和左大括号（如果使用的话）间也要有个空格：</p>
<pre><code>if(condition) // Bad - space missing after IF.

if (condition){ // Bad - space missing before {.

if(condition){ // Doubly bad.

if (condition) { // Good - proper space after IF and before {.
</code></pre><p>有些条件语句写在同一行以增强可读性，只有当语句简单并且没有使用else子句时使用：</p>
<pre><code>if (x == kFoo) return new Foo();

if (x == kBar) return new Bar();
</code></pre><p>如果语句有else分支是不允许的：</p>
<pre><code>// Not allowed - IF statement on one line when there is an ELSE clause

if (x) DoThis();

else DoThat();
</code></pre><p>通常，单行语句不需要使用大括号，如果你喜欢也无可厚非，也有人要求if必须使用大括号：</p>
<pre><code>if (condition)

      DoSomething(); // 2 space indent.



if (condition) {

      DoSomething(); // 2 space indent.

}
</code></pre><p>但如果语句中哪一分支使用了大括号的话，其它部分也必须使用：</p>
<pre><code>// Not allowed - curly on IF but not ELSE

if (condition) {

      foo;

} else

bar;



// Not allowed - curly on ELSE but not IF

if (condition)

      foo;

else {

bar;

}



// Curly braces around both IF and ELSE required because

// one of the clauses used braces.

 if (condition) {

      foo;

} else {

      bar;

}
</code></pre><h1 id="8-7-循环和开关选择语句（Loops-and-Switch-Statements）"><a href="#8-7-循环和开关选择语句（Loops-and-Switch-Statements）" class="headerlink" title="8.7 循环和开关选择语句（Loops and Switch Statements）"></a>8.7 循环和开关选择语句（Loops and Switch Statements）</h1><p>switch语句可以使用大括号分块；空循环体应使用{}或continue。</p>
<p>switch语句中的case块可以使用大括号也可以不用，取决于你的喜好，使用时要依下文所述。</p>
<p>如果有不满足case枚举条件的值，要总是包含一个default（如果有输入值没有case去处理，编译器将报警）。如果default永不会执行，可以简单的使用assert：</p>
<pre><code>switch (var) {

      case 0: { // 2 space indent

             ... // 4 space indent

             break;

      }

      case 1: {

             ...

             break;

      }

      default: {

             assert(false);

      }

}
</code></pre><p>空循环体应使用{}或continue，而不是一个简单的分号：</p>
<pre><code>while (condition) {

      // Repeat test until it returns false.

}



for (int i = 0; i &lt; kSomeNumber; ++i) {} // Good - empty body.

while (condition) continue; // Good - continue indicates no logic.

while (condition); // Bad - looks like part of do/while loop.
</code></pre><h1 id="8-8-指针和引用表达式（Pointers-and-Reference-Expressions）"><a href="#8-8-指针和引用表达式（Pointers-and-Reference-Expressions）" class="headerlink" title="8.8 指针和引用表达式（Pointers and Reference Expressions）"></a>8.8 指针和引用表达式（Pointers and Reference Expressions）</h1><p>句点（.）或箭头（-&gt;）前后不要有空格，指针/地址操作符（*、&amp;）后不要有空格。</p>
<p>面是指针和引用表达式的正确范例：</p>
<pre><code>x = *p;

p = &amp;x;

x = r.y;

x = r-&gt;y;
</code></pre><p>注意：</p>
<p>1) 在访问成员时，句点或箭头前后没有空格；</p>
<p>2) 指针操作符*或&amp;后没有空格。 在声明指针发量或参数时，星号与类型或变量名紧挨都可以：</p>
<pre><code>// These are fine, space preceding.

char *c;

const string &amp;str;



// These are fine, space following.

char* c; // but remember to do &quot;char* c, *d, *e, ...;&quot;!

const string&amp; str;

char * c; // Bad - spaces on both sides of *

const string &amp; str; // Bad - spaces on both sides of &amp;
</code></pre><h1 id="8-9-布尔表达式（Boolean-Expressions）"><a href="#8-9-布尔表达式（Boolean-Expressions）" class="headerlink" title="8.9 布尔表达式（Boolean Expressions）"></a>8.9 布尔表达式（Boolean Expressions）</h1><p>如果一个布尔表达式超过标准行宽（80字符），如果断行要统一一下。</p>
<p>下例中，逻辑与（&amp;&amp;）操作符总位于行尾：</p>
<pre><code>if (this_one_thing &gt; this_other_thing &amp;&amp;

             a_third_thing == a_fourth_thing &amp;&amp;

             yet_another &amp; last_one) {

      ...

}
</code></pre><p>两个逻辑与（&amp;&amp;）操作符都位于行尾，可以考虑额外插入圆括号，合理使用的话对增强可读性是很有帮助的。</p>
<p>注：个人比较习惯逻辑运算符位于行首，逻辑关系一目了然，各人喜好，至于加不加圆括号的问题，如果你对优先级了然于胸的话可以不加，但可读性总是差了些。</p>
<h1 id="8-10-函数返回值（Return-Values）"><a href="#8-10-函数返回值（Return-Values）" class="headerlink" title="8.10 函数返回值（Return Values）"></a>8.10 函数返回值（Return Values）</h1><p>return表达式中不要使用圆括号。</p>
<p>函数返回时不要使用圆括号：</p>
<pre><code>return x; // not return(x);
</code></pre><h1 id="8-11-变量及数组初始化（Variable-and-Array-Initialization）"><a href="#8-11-变量及数组初始化（Variable-and-Array-Initialization）" class="headerlink" title="8.11 变量及数组初始化（Variable and Array Initialization）"></a>8.11 变量及数组初始化（Variable and Array Initialization）</h1><p>选择=还是()。</p>
<p>需要做二者之间做出选择，下面的形式都是正确的：</p>
<pre><code>int x = 3;

int x(3);

string name(&quot;Some Name&quot;);

string name = &quot;Some Name&quot;;
</code></pre><h1 id="8-12-预处理指令（Preprocessor-Directives）"><a href="#8-12-预处理指令（Preprocessor-Directives）" class="headerlink" title="8.12 预处理指令（Preprocessor Directives）"></a>8.12 预处理指令（Preprocessor Directives）</h1><p>预处理指令不要缩进，从行首开始。</p>
<p>即使预处理指令位于缩进代码块中，指令也应从行首开始。</p>
<pre><code>// Good - directives at beginning of line

if (lopsided_score) {

#if DISASTER_PENDING // Correct -- Starts at beginning of line

      DropEverything();

#endif

      BackToNormal();

}



// Bad - indented directives

if (lopsided_score) {

      #if DISASTER_PENDING // Wrong! The &quot;#if&quot; should be at beginning of line

      DropEverything();

      #endif // Wrong! Do not indent &quot;#endif&quot;

      BackToNormal();

}
</code></pre><h1 id="8-13-类格式（Class-Format）"><a href="#8-13-类格式（Class-Format）" class="headerlink" title="8.13 类格式（Class Format）"></a>8.13 类格式（Class Format）</h1><p>声明属性依次序是public:、protected:、private:，每次缩进1个空格（也有人提倡private在前，对于声明了哪些数据成员一目了然，还有人提倡依逻辑关系将变量与操作放在一起，都有道理:-)）。</p>
<p>类声明（对类注释不了解的话，参考第六篇中的类注释一节）的基本格式如下：</p>
<pre><code>class MyClass : public OtherClass {

public: // Note the 1 space indent!

      MyClass(); // Regular 2 space indent.

      explicit MyClass(int var);

      ~MyClass() {}



      void SomeFunction();

      void SomeFunctionThatDoesNothing() {

      }

      void set_some_var(int var) { some_var_ = var; }

      int some_var() const { return some_var_; }



private:

      bool SomeInternalFunction();

      int some_var_;

      int some_other_var_;

      DISALLOW_COPY_AND_ASSIGN(MyClass);

};
</code></pre><p>注意：</p>
<p>1) 基类名应在80列限制下尽量与子类名放在同一行；</p>
<p>2) 关键词public:、protected:、private:要缩进1个空格</p>
<p>3) 除第一个关键词（一般是public）外，其它关键词前空一行，如果类比较小的话也可以不空；</p>
<p>4) 这些关键词后不要空行；</p>
<p>5) public放在最前面，然后是protected和private；</p>
<p>6) 关于声明次序参考第三篇声明次序一节。</p>
<p>8.14 初始化列表（Initializer Lists）</p>
<p>构造函数初始化列表放在同一行或空四格缩进并排几行。</p>
<p>两种可以接受的初始化列表格式：</p>
<pre><code>// When it all fits on one line:

MyClass::MyClass(int var) : some_var_(var), some_other_var_(var + 1) {
</code></pre><p>或</p>
<pre><code>// When it requires multiple lines, indent 4 spaces, putting the colon on

// the first initializer line:

MyClass::MyClass(int var)

             : some_var_(var), // 4 space indent

             some_other_var_(var + 1) { // lined up

      ...

      DoSomething();

      ...

}
</code></pre><h1 id="8-15-命名空间格式化（Namespace-Formatting）"><a href="#8-15-命名空间格式化（Namespace-Formatting）" class="headerlink" title="8.15 命名空间格式化（Namespace Formatting）"></a>8.15 命名空间格式化（Namespace Formatting）</h1><p>命名空间内容丌缩迕。</p>
<p>命名空间丌添加额外缩迕局次，例如：</p>
<pre><code>namespace {

void foo() { // Correct. No extra indentation within namespace.

      ...

}



} // namespace
</code></pre><p>丌要缩迕：</p>
<pre><code>namespace { // Wrong. Indented when it should not be.

      void foo() {

             ...

      }

} // namespace
</code></pre><h1 id="8-16-水平空白（Horizontal-Whitespace）"><a href="#8-16-水平空白（Horizontal-Whitespace）" class="headerlink" title="8.16 水平空白（Horizontal Whitespace）"></a>8.16 水平空白（Horizontal Whitespace）</h1><p>水平空白的使用因地制宜。不要在行尾添加无谓的空白。</p>
<p>普通：</p>
<pre><code>void f(bool b) { // Open braces should always have a space before them.

...

int i = 0; // Semicolons usually have no space before them.

int x[] = { 0 }; // Spaces inside braces for array initialization are

int x[] = {0}; // optional. If you use them, put them on both sides!



// Spaces around the colon in inheritance and initializer lists.

class Foo : public Bar {

 public:

      // For inline function implementations, put spaces between the braces

      // and the implementation itself.

      Foo(int b) : Bar(), baz_(b) {} // No spaces inside empty braces.

      void Reset() { baz_ = 0; } // Spaces separating braces from implementation.

      ...
</code></pre><p>添加冗余的留白会给其他人编辑时造成额外负担，因此，不要加入多余的空格。如果确定一行代码已经修改完毕，将多余的空格去掉；或者在专门清理空格时去掉（确信没有其他人在使用）。</p>
<p>循环和条件语句：</p>
<pre><code>if (b) { // Space after the keyword in conditions and loops.

} else { // Spaces around else.

}



while (test) // There is usually no space inside parentheses



switch (i) {

for (int i = 0; i &lt; 5; ++i) {

switch ( i ) { // Loops and conditions may have spaces inside

if ( test ) { // parentheses, but this is rare. Be consistent.

for ( int i = 0; i &lt; 5; ++i ) {

for ( ; i &lt; 5 ; ++i) { // For loops always have a space after the 

      ... // semicolon, and may have a space before the semicolon.

switch (i) {

      case 1: // No space before colon in a switch case.

             ...

      case 2: break; // Use a space after a colon if there&apos;s code after it.
</code></pre><p>操作符：</p>
<pre><code>x = 0; // Assignment operators always have spaces around them

x = -5; // No spaces separating unary operators and their arguments.

++x;

if (x &amp;&amp; !y)

      ...

v = w * x + y / z; // Binary operators usually have spaces around them,

v = w*x + y/z; // but it&apos;s okay to remove spaces around factors.

v = w * (x + z); // Parentheses should have no spaces inside them.
</code></pre><p>模板和转换：</p>
<pre><code>vector&lt;string&gt; x; // No spaces inside the angle

y = static_cast&lt;char*&gt;(x); // brackets (&lt; and &gt;), before &lt;, or between &gt;( in a cast.

vector&lt;char *&gt; x; // Spaces between type and pointer are okay, but be consistent.

set&lt;list&lt;string&gt; &gt; x; // C++ requires a space in &gt; &gt;.

set&lt; list&lt;string&gt; &gt; x; // You may optionally make use symmetric spacing in &lt; &lt;.
</code></pre><h1 id="8-17-垂直空白（Vertical-Whitespace）"><a href="#8-17-垂直空白（Vertical-Whitespace）" class="headerlink" title="8.17 垂直空白（Vertical Whitespace）"></a>8.17 垂直空白（Vertical Whitespace）</h1><p>垂直空白越少越好。</p>
<p>这不仅仅是规则而是原则问题了：不是非常有必要的话就不要使用空行。尤其是：不要在两个函数定义之间空超过2行，函数体头、尾不要有空行，函数体中也不要随意添加空行。</p>
<p>基本原则是：同一屏可以显示越多的代码，程序的控制流就越容易理解。当然，过于密集的代码块和过于疏松的代码块同样难看，取决于你的判断，但通常是越少越好。</p>
<p>函数头、尾不要有空行：</p>
<pre><code>void Function() {

      // Unnecessary blank lines before and after

}
</code></pre><p>代码块头、尾不要有空行：</p>
<pre><code>while (condition) {

      // Unnecessary blank line after

}

if (condition) {

      // Unnecessary blank line before

}



if-else块之间空一行还可以接受：

if (condition) {

      // Some lines of code too small to move to another function,

      // followed by a blank line.



} else {

      // Another block of code

}
</code></pre><h1 id="8-18-Summary"><a href="#8-18-Summary" class="headerlink" title="8.18 Summary"></a>8.18 Summary</h1><ol>
<li><p>行宽原则上不超过80列，把22寸的显示屏都占完，怎么也说不过去；</p>
</li>
<li><p>尽量不使用非ASCII字符，如果使用的话，参考UTF-8格式（尤其是UNIX/Linux下，Windows下可以考虑宽字符），尽量不将字符串常量耦合到代码中，比如独立出资源文件，这不仅仅是风格问题了；</p>
</li>
<li><p>UNIX/Linux下无条件使用空格；</p>
</li>
<li><p>函数参数、逻辑条件、初始化列表：要么所有参数和函数名放在同一行，要么所有参数并排分行；</p>
</li>
<li><p>除函数定义的左大括号可以置于行首外，包括函数/类/结构体/枚举声明、各种语句的左大括号置于行尾，所有右大括号独立成行；</p>
</li>
<li><p>./-&gt;操作符前后不留空格，*/&amp;不要前后都留，一个就可，靠左靠右依各人喜好；</p>
</li>
<li><p>预处理指令/命名空间不使用额外缩进，类/结构体/枚举/函数/语句使用缩进；</p>
</li>
<li><p>初始化用=还是()依个人喜好，统一就好；</p>
</li>
<li><p>return不要加()；</p>
</li>
<li><p>水平/垂直留白不要滥用，怎么易读怎么来。</p>
</li>
</ol>
<h1 id="8-19-补充"><a href="#8-19-补充" class="headerlink" title="8.19 补充"></a>8.19 补充</h1><p>参考常识，保持一致。</p>
<p>编辑代码时，花点时间看看项目中的其它代码并确定其风格，如果其他代码if语句中使用空格，那么你也要使用。如果其中的注释用星号（*）围成一个盒子状，你也这样做：</p>
<pre><code>/**********************************

* Some comments are here.

* There may be many lines.

**********************************/
</code></pre><p>编程风格规范的使用要点在于提供一个公共的编码规范，所有人可以把精力集中在实现内容而不是表现形式上。我们给出了全局的风格规范，但局部的风格也很重要，如果你在一个文件中新加的代码和原有代码风格相去甚迖的话，就破坏了文件本身的整体美观也影响阅读，所以要尽量避免。</p>
<p>#第二部分 高级主题：C++设计参考</p>
<p>说明：本部分汇集多部经典著作和多位C++领域顶级大师的思想精华，作为使用C++进行项目开发时的设计参考，需开发人员具有扎实的语言基础和相当的编码经验方能理解并加以运用，可在开发过程中边学习边应用边提高。深刻理解本部分的条例，在项目开发中熟练运用，可在C++面向对象编程思想的理解上高屋建瓴，在项目研发上无坚不摧，在个人技术修为上一览众山：）</p>
<p>本部分可以看作是第一部分的延伸和深入。</p>
<p>#[第9章 声明]</p>
<p>本章为不同 C++ 声明类型的使用及形式提供指南。</p>
<h1 id="9-1-名字空间"><a href="#9-1-名字空间" class="headerlink" title="9.1  名字空间"></a>9.1  名字空间</h1><p>C++ 语言中namespace存在之前，管理名称的作用域只有有限的几种手段；因此，全局名字空间的使用过于泛滥，导致众多的冲突，这使同一程序中难以同时使用一些库。新的名字空间语言特征解决了全局名字空间的干扰问题。</p>
<h1 id="9-1-1-只有namespace的声明才能是全局声明"><a href="#9-1-1-只有namespace的声明才能是全局声明" class="headerlink" title="9.1.1 只有namespace的声明才能是全局声明"></a>9.1.1 只有namespace的声明才能是全局声明</h1><p>这意味着只有namespace的名称可以是全局的；所有其他的声明都必须在某个namespace的作用域内。</p>
<p>忽略了这一规则可能最终导致名称冲突。</p>
<h1 id="9-1-2-使用名字空间划分非类功能"><a href="#9-1-2-使用名字空间划分非类功能" class="headerlink" title="9.1.2 使用名字空间划分非类功能"></a>9.1.2 使用名字空间划分非类功能</h1><p>逻辑上划分非类功能类的类别，或作用域远大于类的功能（如库或子系统），使用名字空间逻辑上统一的声明（请参见“使用名字空间由系统或库划分潜在的全局名称”）。</p>
<p>名称表达了功能的逻辑划分。</p>
<p>示例</p>
<p>namespace transport_layer_interface { /<em> …</em>/ };<br>namespace math_definitions { /<em> …</em>/ };<br>9.1.3 尽量不使用全局和名字空间范围的数据。</p>
<p>使用全局和名字空间范围内数据与封装原则是背道而驰的。</p>
<h1 id="9-2-类"><a href="#9-2-类" class="headerlink" title="9.2  类"></a>9.2  类</h1><p>C++ 中类是基本的设计实现单元。使用它们纪录领域与设计的抽象，并作为实现抽象数据类型 (ADT) 的封装机制。</p>
<h1 id="9-2-1-使用-class-而不是-struct-来实现抽象数据类型"><a href="#9-2-1-使用-class-而不是-struct-来实现抽象数据类型" class="headerlink" title="9.2.1 使用 class 而不是 struct 来实现抽象数据类型"></a>9.2.1 使用 class 而不是 struct 来实现抽象数据类型</h1><p>使用 class（类的关键字）而不是 struct 来实现一个表示抽象数据类型的类。</p>
<p>使用 struct（类的关键字）来定义类似 C 中的旧式数据结构 (POD)，尤其是在与 C 代码程序接口时。</p>
<p>虽然 class 和 struct 是等价的，可以互换，但 class 具有更好的默认访问控制 (private)，这样就提供了更好的封装。</p>
<p>基本原理</p>
<p>区分 class 与 struct 的统一做法引入了以上的语义差别，并且还超出了语言规则的范围：class 是纪录抽象与封装最先考虑的结构；而 struct 代表一个纯数据结构，它可以在混合编程语言程序中交换使用。</p>
<h1 id="9-2-2-以可访问权限逐次降低的顺序声明类的成员"><a href="#9-2-2-以可访问权限逐次降低的顺序声明类的成员" class="headerlink" title="9.2.2 以可访问权限逐次降低的顺序声明类的成员"></a>9.2.2 以可访问权限逐次降低的顺序声明类的成员</h1><p>类声明中的访问限定符应以顺序 public, protected, private 出现。</p>
<p>基本原理</p>
<p>以 public、protected、private 顺序排列的成员声明保证了类用户最感兴趣的信息置于最前列，因此减少了类用户访问不相关信息或实现细节。</p>
<h1 id="9-2-3-抽象数据类型避免声明public或protected数据成员"><a href="#9-2-3-抽象数据类型避免声明public或protected数据成员" class="headerlink" title="9.2.3 抽象数据类型避免声明public或protected数据成员"></a>9.2.3 抽象数据类型避免声明public或protected数据成员</h1><p>public或protected数据成员的使用降低了类的封装性并影响了系统抵抗变化的能力：公共数据成员将类的实现暴露给了它的用户；保护数据成员将类的实现暴露给了从它继承的类。类公共数据成员或保护数据成员的任何改变都会影响到用户和继承类。</p>
<h1 id="9-2-4-使用友元保留封装性"><a href="#9-2-4-使用友元保留封装性" class="headerlink" title="9.2.4 使用友元保留封装性"></a>9.2.4 使用友元保留封装性</h1><p>初次碰到时，它好像是违反直觉的：友元关系将一个类的私有部分暴露给了它的友元，还如何实现封装呢？当类之间高度相互依赖，需要相互间的内部信息时，最好是赋予它们间友元关系而不是通过类的接口将其内部细节暴露出来。</p>
<p>不希望如同公共成员一样暴露类的内部细节以提供给类客户访问权。将保护成员暴露给潜在的继承类，鼓励了分级设计，但这也是不希望的。友元关系有选择性的赋予了对私有成员的访问权，而不用实现子类限制。因此在所需访问之外保留了封装。</p>
<p>将友元关系赋予友元测试类很好的说明了友元关系保留了封装特性。友元测试类通过访问类的内部可完成相应的测试代码，之后，友元测试类可从交付的代码中删除。因此，没有丢失封装，也没有向可交付代码增加代码。</p>
<h1 id="9-2-5-避免在类声明中定义函数"><a href="#9-2-5-避免在类声明中定义函数" class="headerlink" title="9.2.5 避免在类声明中定义函数"></a>9.2.5 避免在类声明中定义函数</h1><p>类的声明应当只包含函数的声明,永远不要进行函数定义(实现)。</p>
<p>基本原理</p>
<p>类声明中定义函数干扰了类对其实现细节的规约；使类的接口难以辨认并难以阅读;并增加了编译依赖。</p>
<p>类声明中的函数定义也减少了对内嵌函数的控制（请参照“使用 No_Inline 条件编译符禁止内嵌编译”）。</p>
<h1 id="9-2-6-为明确声明构造函数的类提供默认构造函数"><a href="#9-2-6-为明确声明构造函数的类提供默认构造函数" class="headerlink" title="9.2.6 为明确声明构造函数的类提供默认构造函数"></a>9.2.6 为明确声明构造函数的类提供默认构造函数</h1><p>为了在数组中或任何 STL 容器中使用类，类必须提供public的默认构造函数或允许编译器生成一个构造函数。</p>
<p>注意:</p>
<p>这个规则有一种意外情况：当类有非静态引用类型的数据成员时,此时通常不可能创建一个有意义的默认构造函数。因此，使用对象数据成员的引用就是不可靠的。</p>
<h1 id="9-2-7-带有指针类型数据成员的类要声明其复制构造函数和赋值操作符"><a href="#9-2-7-带有指针类型数据成员的类要声明其复制构造函数和赋值操作符" class="headerlink" title="9.2.7 带有指针类型数据成员的类要声明其复制构造函数和赋值操作符"></a>9.2.7 带有指针类型数据成员的类要声明其复制构造函数和赋值操作符</h1><p>如果需要，并且没有明确声明时，编译器会为类暗中生成一个复制构造函数和一个赋值操作符。编译器定义的复制构造函数和赋值操作符，在 Smalltalk 术语中这通常称为“shallow-copy”（浅拷贝）：明确的说，即按成员拷贝以及对指针按位拷贝。使用编译器生成的复制构造函数和默认的赋值操作符肯定会造成内存泄漏。</p>
<p>示例</p>
<pre><code>//摘自 [Meyers, 92].
void f()
{
String hello(&quot;Hello&quot;);//假设 String 类型
                      //由指向 char 型
                      //数组的指针来实现。
{
//进入新的域（程序块）
String world(&quot;World&quot;);    
world = hello;        //赋值语句使 world 丢失了
                      //它最初指向的内存单元
}     //从域中退出时
       //解构 world；
       //此时也间接的解构了 hello
String hello2 = hello; //将已解构过的 hello 赋给
                       // hello2
}   
</code></pre><p>以上代码中，储存字符串“World”的内存单元在赋值语句之后丢失了。结束内部程序块时，销毁了world；因此，由 hello 引用的内存单元也丢失了。已经析构的 hello 赋给了 hello2。</p>
<p>示例</p>
<pre><code>//摘自 [Meyers, 1992]。
void foo(String bar) {};
void f()
{
String lost = &quot;String that will be lost!&quot;;
foo(lost);
}     
</code></pre><p>以上代码中，当调用函数 foo 使用实参 lost 时，利用编译器定义的复制构造函数将 lost 复制到 foo 中。因为复制 lost 时对指向“String that will be lost!”的指针进行逐位复制，当从 foo 中退出时，对 lost 的复制（即形参 bar，译者注）将会被销毁（假设析构函数正确的释放了内存单元），同时存储字符串“String that will be lost! ”的内存单元也会被释放。</p>
<h1 id="9-2-8-不要重新声明构造函数参数使其有默认值"><a href="#9-2-8-不要重新声明构造函数参数使其有默认值" class="headerlink" title="9.2.8 不要重新声明构造函数参数使其有默认值"></a>9.2.8 不要重新声明构造函数参数使其有默认值</h1><p>示例</p>
<pre><code>//示例摘自 [X3J16, 95; section 12.8]
class X {
public:
X(const X&amp;, int);       // int 参数没有
                               //初始化
                               //没有用户声明的复制构造函数，因此
                               //编译器暗中声明了一个。
};
//int 参数滞后的初始化
//将构造函数变成了复制构造函数。
//
X::X(const X&amp; x, int i = 0) { ...} 
</code></pre><p>基本原理</p>
<p>编译器在类声明中没有发现“标准”的复制构造函数时会暗中声明一个复制构造函数。但是，默认参数滞后的初始化可能将构造函数改变成复制构造函数：使用复制构造函数时导致混淆。因为这种混淆，任何复制构造函数的使用都因此而变为病态的。[X3J16, 95; section 12.8].</p>
<h1 id="9-2-9-将析构函数总是声明为-virtual-类型"><a href="#9-2-9-将析构函数总是声明为-virtual-类型" class="headerlink" title="9.2.9 将析构函数总是声明为 virtual 类型"></a>9.2.9 将析构函数总是声明为 virtual 类型</h1><p>除非明确将类的设计为不可继承的，否则应将析构函数声明为 virtual 类型。</p>
<p>基本原理</p>
<p>如果基类的析构函数没有声明为 virtual 类型，则通过基类的指针或引用删除派生类对象将导致不确定的行为。</p>
<p>示例</p>
<pre><code>//为了简便起见，这里使用了不好的命名风格
class B {
public:
B(size_t size) { tp = new T[size]; }
~B() { delete [] tp; tp = 0; }
//...
private:
T* tp;
};

class D : public B {
public:
D(size_t size) : B(size) {}
~D() {}
//...
};

void f()
{
B* bp = new D(10);
delete bp; //由于基类
                  //的析构函数没有定义成 virtual 类型，
              //这里的行为是不确定的
}     
</code></pre><h1 id="9-2-10-避免声明太多的转换操作符和单参数构造函数"><a href="#9-2-10-避免声明太多的转换操作符和单参数构造函数" class="headerlink" title="9.2.10            避免声明太多的转换操作符和单参数构造函数"></a>9.2.10            避免声明太多的转换操作符和单参数构造函数</h1><p>使用限定符 explicit 可防止单参数构造函数用于隐式转换。</p>
<h1 id="9-2-11-不要重定义非虚函数"><a href="#9-2-11-不要重定义非虚函数" class="headerlink" title="9.2.11            不要重定义非虚函数"></a>9.2.11            不要重定义非虚函数</h1><p>非虚函数实现固定的行为，并且不希望专用于派生类。违反这一原则将导致不可预料的行为：同一对象不同时间可能表现不同的行为。</p>
<p>非虚函数是静态绑定的；以下示例中，对象函数的调用由变量（指向 A 或 B 的指针）的静态类型控制，而不是对象的实际类型。</p>
<p>示例</p>
<pre><code>// Adapted from [Meyers, 92].
class A {
public:
oid f(); //非虚函数：静态绑定
};
class B : public A {
public:
void f(); //非虚函数：静态绑定
};
void g()
{
B x;
A* pA = &amp;x; //静态类型，指向 A 的指针
B* pB = &amp;x; //静态类型，指向 B 的指针
pA-&gt;f(); //调用 A::f
pB-&gt;f(); //调用 B::f
}     
</code></pre><h1 id="9-2-12-谨慎使用非虚函数"><a href="#9-2-12-谨慎使用非虚函数" class="headerlink" title="9.2.12            谨慎使用非虚函数"></a>9.2.12            谨慎使用非虚函数</h1><p>因为非虚函数通过限制重载和多态的使用来限制子类，声明为非虚拟之前，必须注意确保操作对所有子类确实是固定不变的。</p>
<h1 id="9-2-13-在构造函数中使用构造函数初始化而不使用赋值语句"><a href="#9-2-13-在构造函数中使用构造函数初始化而不使用赋值语句" class="headerlink" title="9.2.13            在构造函数中使用构造函数初始化而不使用赋值语句"></a>9.2.13            在构造函数中使用构造函数初始化而不使用赋值语句</h1><p>对象构造时其状态的初始化应由构造函数初始化（一个成员初始化列表）完成,而不是通过构造函数内的赋值操作符完成。</p>
<p>示例</p>
<p>代码如下:</p>
<pre><code>class X
{
public:
X();
private
Y the_y;
};
X::X() : the_y(some_y_expression) { }
//
// “the_y”由初始化构造函数进行初始化
而不是如下进行初始化
X::X() { the_y = some_y_expression; }
//
// “the_y”由赋值操作符进行初始化
</code></pre><p>基本原理</p>
<p>对象的构造涉及到在执行构造函数体之前构造所有的基类以及数据成员。使用构造函数初始化只需要一个操作（由初值构造），而在构造函数体中初始化数据成员需要两个操作（构造以及赋值）。</p>
<p>对有多重嵌套的类（类包含类，所包含的类又包含其他的类），多个操作（构造＋成员赋值）造成的性能的开支就十分重要了。</p>
<h1 id="9-2-14-构造函数初始化时不要调用成员函数"><a href="#9-2-14-构造函数初始化时不要调用成员函数" class="headerlink" title="9.2.14            构造函数初始化时不要调用成员函数"></a>9.2.14            构造函数初始化时不要调用成员函数</h1><p>示例</p>
<pre><code>class A
{
public:
A(int an_int);
};
class B : public A
{
public:
int f();
B();
};

B::B() : A(f()) {}
//不确定：调用成员函数时A
//尚未初始化[X3J16, 95].
</code></pre><p>基本原理</p>
<p>当所有基类的成员初始化完成之前如果构造函数初始化直接或间接的调用了成员函数，此操作的结果是不确定的。[X3J16, 95].</p>
<h1 id="9-2-15-注意构造函数和析构函数调用成员函数时的情况"><a href="#9-2-15-注意构造函数和析构函数调用成员函数时的情况" class="headerlink" title="9.2.15            注意构造函数和析构函数调用成员函数时的情况"></a>9.2.15            注意构造函数和析构函数调用成员函数时的情况</h1><p>构造函数中调用成员函数时要格外注意（即使调用的是虚函数时也要注意）。执行的将是在类或其基类的构造函数、析构函数中定义的操作。</p>
<h1 id="9-2-16-整形类常量使用-static-const"><a href="#9-2-16-整形类常量使用-static-const" class="headerlink" title="9.2.16            整形类常量使用 static const"></a>9.2.16            整形类常量使用 static const</h1><p>定义整形（整数）类常量时，使用 static const 数据成员，不要使用 #define 或全局常量。如果编译器不支持 static const，则使用 enum。</p>
<p>示例</p>
<p>要这样做：</p>
<pre><code>class X {
static const buffer_size = 100;
char buffer[buffer_size];
};
static const buffer_size;
或：
class C {
enum { buffer_size = 100 };
char buffer[buffer_size];
};
但不要这样：
#define BUFFER_SIZE 100
class C {
char buffer[BUFFER_SIZE];
};    
</code></pre><h1 id="9-3-函数"><a href="#9-3-函数" class="headerlink" title="9.3  函数"></a>9.3  函数</h1><h1 id="9-3-1-一定要明确声明函数的返回值类型"><a href="#9-3-1-一定要明确声明函数的返回值类型" class="headerlink" title="9.3.1 一定要明确声明函数的返回值类型"></a>9.3.1 一定要明确声明函数的返回值类型</h1><p>这可以防止编译器发现函数未声明返回值类型时所造成的模糊不清。</p>
<h1 id="9-3-2-函数声明中要提供正式参数名称"><a href="#9-3-2-函数声明中要提供正式参数名称" class="headerlink" title="9.3.2 函数声明中要提供正式参数名称"></a>9.3.2 函数声明中要提供正式参数名称</h1><p>函数的声明和定义中要使用相同的名称；这可使混淆程度降至最小。提供参数名称有利于提高代码的文档化程度和易读性。</p>
<h1 id="9-3-3-函数要尽量只有一个返回点"><a href="#9-3-3-函数要尽量只有一个返回点" class="headerlink" title="9.3.3 函数要尽量只有一个返回点"></a>9.3.3 函数要尽量只有一个返回点</h1><p>返回语句在程序体中自由放置与 goto 语句的情况类似，会造成代码难以阅读和维护。</p>
<p>只有在少数几种函数中才能容忍出现多个返回语句，此时可以同时看到所有的return语句/并且代码还有非常规则的结构：</p>
<pre><code>type_t foo()
{

if (this_condition)
return this_value;
else
return some_other_value;
}     
</code></pre><p>函数的返回类型为 void 时不应有return语句。</p>
<h1 id="9-3-4-避免创建对全局有副作用的函数"><a href="#9-3-4-避免创建对全局有副作用的函数" class="headerlink" title="9.3.4 避免创建对全局有副作用的函数"></a>9.3.4 避免创建对全局有副作用的函数</h1><p>应尽量避免创建对全局有副作用的函数，因为它可能改变并不知情的数据而非它们内部对象的状态，如全局和名字空间数据（另请参见“尽量不使用全局或名字空间范围的数据”）但如果这是不可避免的，则应明确记录下所有的副作用以作为函数规约的一部分。</p>
<p>将所需的对象作为参数传递可以增加代码的上下文无关性，并提高了它的强壮性和易理解性。</p>
<h1 id="9-3-5-以重要性和活跃性递减的顺序声明函数的参数"><a href="#9-3-5-以重要性和活跃性递减的顺序声明函数的参数" class="headerlink" title="9.3.5 以重要性和活跃性递减的顺序声明函数的参数"></a>9.3.5 以重要性和活跃性递减的顺序声明函数的参数</h1><p>从调用者的角度讲，参数声明的顺序是非常重要的：</p>
<ul>
<li>首先以重要性递减的顺序定义非默认参数；</li>
<li>再以被修改可能性递减的顺序定义有默认值的参数。<br>这种顺序使用了参数默认值的优点来减少函数调用中实参的个数。</li>
</ul>
<h1 id="9-3-6-避免声明带有不定参数个数的函数"><a href="#9-3-6-避免声明带有不定参数个数的函数" class="headerlink" title="9.3.6 避免声明带有不定参数个数的函数"></a>9.3.6 避免声明带有不定参数个数的函数</h1><p>带有不定参数个数的函数无法对其实参进行类型检查。</p>
<h1 id="9-3-7-避免重新声明带有默认参数的函数"><a href="#9-3-7-避免重新声明带有默认参数的函数" class="headerlink" title="9.3.7 避免重新声明带有默认参数的函数"></a>9.3.7 避免重新声明带有默认参数的函数</h1><p>函数的进一步重新声明中应避免添加默认值：除了预先声明（forward），一个函数只应声明一次。否则，如果读者没有意识到此后的声明，这将会造成混淆。</p>
<h1 id="9-3-8-函数声明中尽可能多地使用-const"><a href="#9-3-8-函数声明中尽可能多地使用-const" class="headerlink" title="9.3.8 函数声明中尽可能多地使用 const"></a>9.3.8 函数声明中尽可能多地使用 const</h1><p>检查函数是否有常量行为（返回常数值；接受常量实参；或其操作不带有副作用），如果有则使用限定符 const 表明其行为。</p>
<p>示例</p>
<pre><code>const T f(...); //函数返回一个常量
                       //对象。
T f(T* const arg);               //函数接受一个常量指针
                               //为其参数。
//可以改变指针所指的对象，
//但不可以改变指针本身。
T f(const T* arg);      //函数参数为指针类型
T f(const T&amp; arg);      // 函数参数为引用类型
                        //它们都指向一个常量对象。指针可以
                        //改变，但所指的对象
                        //不能改变。
T f(const T* const arg);  //函数参数为
                          //常量指针，它指向常量对象。
                          //指针和它所指的对象
                          //都不改变。
T f(...) const;  //函数没有副作用：
                 //不改变它对象的状态
                 //所以可应用于
                 //常量对象。
</code></pre><h1 id="9-3-9-避免利用值传递对象"><a href="#9-3-9-避免利用值传递对象" class="headerlink" title="9.3.9 避免利用值传递对象"></a>9.3.9 避免利用值传递对象</h1><p>利用值传递和返回对象可能带来构造函数和析构函数的大量开支。可通过引用传递和返回对象，这样可避免构造函数和析构函数的开支。</p>
<p>可用 const 引用指定通过引用传递的实参是不可改变的。复制构造函数和赋值操作符是典型的示例：</p>
<pre><code>C::C(const C&amp; aC);
C&amp; C::operator=(const C&amp; aC);
示例：

考虑以下例子：

the_class the_class::return_by_value(the_class a_copy)
{
return a_copy;
}
the_class an_object;
return_by_value(an_object);
</code></pre><p>调用函数 <code>return_by_value</code>，其实参为 <code>an_object</code>，此时调用 <code>the_class</code> 的复制构造函数将 <code>an_object</code> 复制到 <code>a_copy</code>。再次调用 <code>the_class</code> 的复制构造函数将 <code>a_copy</code> 复制到函数返回的临时对象中。从函数返回时调用 <code>the_class</code> 的析构函数销毁 <code>a_copy</code>。一段时间之后再次调用 <code>the_class</code> 的析构函数销毁 <code>return_by_value</code> 返回的对象。以上不完成任何事的函数的所有开支是两个构造函数和两个析构函数。</p>
<p>如果 <code>the_class</code> 是个派生类且包含其他类的成员数据，情况会更糟：会调用基类以及所包含类的构造函数和析构函数，因此函数调用所带来的构造函数和析构函数的调用就会随之急剧增长。</p>
<p>注意：</p>
<p>以上指南似乎旨在建议开发人员在传递和返回对象时总是使用引用类型，但应格外当心不要返回对局部对象的引用。返回对局部对象的引用会造成灾难性后果，因为函数返回时，所返回的引用绑定到了已销毁的对象上。</p>
<h1 id="9-3-10-不能返回对局部对象的引用"><a href="#9-3-10-不能返回对局部对象的引用" class="headerlink" title="9.3.10            不能返回对局部对象的引用"></a>9.3.10            不能返回对局部对象的引用</h1><p>离开函数作用域时会销毁局部对象；使用销毁了的对象会造成灾难。</p>
<h1 id="9-3-11-不可返回由-new-初始化的de-referenced指针"><a href="#9-3-11-不可返回由-new-初始化的de-referenced指针" class="headerlink" title="9.3.11            不可返回由 new 初始化的de-referenced指针"></a>9.3.11            不可返回由 new 初始化的de-referenced指针</h1><p>违背这一原则将导致内存泄漏</p>
<p>示例</p>
<pre><code>class C {
public:
...
friend C&amp; operator+( const C&amp; left,
const C&amp; right);
};
C&amp; operator+(const C&amp; left, const C&amp; right)
{
C* new_c = new C(left..., right...);
return *new_c;
}
C a, b, c, d;
C sum;
sum = a + b + c + d;
</code></pre><p>因为在计算加和 sum 值时没有存储操作符“+”的中间结果，因此中间对象不能删除，否则会导致内存泄漏。</p>
<h1 id="9-3-12-不要返回对成员数据的非常量引用或指向成员数据的指针"><a href="#9-3-12-不要返回对成员数据的非常量引用或指向成员数据的指针" class="headerlink" title="9.3.12            不要返回对成员数据的非常量引用或指向成员数据的指针"></a>9.3.12            不要返回对成员数据的非常量引用或指向成员数据的指针</h1><p>违背了这一原则也就违背了数据的封装性，可能导致不好的结果。</p>
<h1 id="9-3-13-使用内嵌定义函数而不使用-define-来实现宏扩展功能"><a href="#9-3-13-使用内嵌定义函数而不使用-define-来实现宏扩展功能" class="headerlink" title="9.3.13            使用内嵌定义函数而不使用 #define 来实现宏扩展功能"></a>9.3.13            使用内嵌定义函数而不使用 #define 来实现宏扩展功能</h1><p>但要有选择的使用内嵌定义：只对非常小的函数才使用；内嵌定义大型函数可能导致代码膨胀。</p>
<p>由于用户代码编译时需要内嵌定义函数的实现，因此内嵌定义函数也增加了模块间编译的依赖。</p>
<p>[Meyers, 1992] 提供了以下不良宏使用极端示例的详细讨论：</p>
<p>示例</p>
<p>不要这样做：</p>
<pre><code>#define MAX(a, b) ((a) &gt; (b) ?(a) : (b))
</code></pre><p>而应这样做：</p>
<pre><code>inline int max(int a, int b) { return a &gt; b ? a : b; }
宏 MAX 有好几个问题：它不是安全的类型；它的行为不是确定的：
int a = 1, b = 0;
MAX(a++, b);     // a 增 1 了两次
MAX(a++, b+10);  // a 增 1 了一次
MAX(a, &quot;Hello&quot;); //比较整形和指针
9.3.14            使用默认参数而不使用函数重载
</code></pre><p>当只使用一个算法并且此算法可由少量几个参数进行参数化时，使用默认参数而不使用函数重载。</p>
<p>使用默认参数有利于减少重载函数的数量、提高可维护性、减少函数调用时所需的实参数量、以及提高代码的可读性。</p>
<h1 id="9-3-15-使用函数重载表达常用语义"><a href="#9-3-15-使用函数重载表达常用语义" class="headerlink" title="9.3.15            使用函数重载表达常用语义"></a>9.3.15            使用函数重载表达常用语义</h1><p>当同一语义操作需要多个实现时使用函数重载，但重载使用不同的实参类型。</p>
<p>重载操作符时保留其传统语义。不要忘记定义关系操作符，如操作符 operator== 和 operator!=。</p>
<h1 id="9-3-16-避免重载以指针和整形数为实参的函数"><a href="#9-3-16-避免重载以指针和整形数为实参的函数" class="headerlink" title="9.3.16            避免重载以指针和整形数为实参的函数"></a>9.3.16            避免重载以指针和整形数为实参的函数</h1><p>避免使用带单一整形实参的函数来重载带单一指针实参的函数：</p>
<pre><code>void f(char* p);
void f(int i);
</code></pre><p>以下调用可能会导致混淆：</p>
<pre><code>PRE&gt;f(NULL); f(0);
</code></pre><p>此重载解析为 f(int) 而不是 f(char*)。</p>
<h1 id="9-3-17-操作符-operator-必须返回对-this-的引用"><a href="#9-3-17-操作符-operator-必须返回对-this-的引用" class="headerlink" title="9.3.17            操作符 operator= 必须返回对 *this 的引用"></a>9.3.17            操作符 operator= 必须返回对 *this 的引用</h1><p>C++ 允许赋值链：</p>
<pre><code>String x, y, z;
x = y = z = &quot;A string&quot;;
</code></pre><p>因为复制操作符是右结合的，将字符串“A string”赋给 z，再将 z 赋给 y，最后将 y 赋给 x。以从右到左的顺序，对每个在 = 右端的表达式有效的调用一次 operator= 。这也意味着每一次 operator= 运算的结果都是一个对象，但其左端或右端的对象都有可能成为返回值。</p>
<p>使用复制操作符好的做法总有以下形式：</p>
<pre><code>C&amp; C::operator=(const C&amp;);
</code></pre><p>只有左端的对象是可能的（rhs 为常量引用，lhs 为变量引用），因此应返回 *this。详情请参见[Meyers, 1992]。</p>
<h1 id="9-3-18-在-operator-中必须检查自赋值"><a href="#9-3-18-在-operator-中必须检查自赋值" class="headerlink" title="9.3.18            在 operator=中必须检查自赋值"></a>9.3.18            在 operator=中必须检查自赋值</h1><p>执行检查有两点重要的理由：首先，派生类对象的赋值涉及到调用每一个基类（在继承层次结构中位于此类的上方）的赋值操作符，跳过这些操作符就可以节省很多运行时间。其次，在复制“rvalue”对象前，赋值涉及到解构“lvalue”对象。在自赋值时，rvalue 对象在赋值前就已销毁了，因此赋值的结果是不确定的。</p>
<h1 id="9-3-19-尽可能减少复杂性"><a href="#9-3-19-尽可能减少复杂性" class="headerlink" title="9.3.19            尽可能减少复杂性"></a>9.3.19            尽可能减少复杂性</h1><p>不要书写过长的函数，例如其代码超过 60 行。</p>
<p>尽可能减少返回语句的数量，1 是理想值。</p>
<p>尽量使循环复杂性降到 10 以下（对单一出口函数 = 判定语句总数 + 1）。</p>
<p>尽量使扩展循环复杂性降到 15 以下（对单一出口函数 = 判定语句＋逻辑操作符＋1）。</p>
<p>尽量减小引用的平均最大作用范围（局部对象声明与对象第一次使用间的行距）。</p>
<h1 id="9-4-类型"><a href="#9-4-类型" class="headerlink" title="9.4  类型"></a>9.4  类型</h1><h1 id="9-4-1-定义项目范围的全局系统类型"><a href="#9-4-1-定义项目范围的全局系统类型" class="headerlink" title="9.4.1 定义项目范围的全局系统类型"></a>9.4.1 定义项目范围的全局系统类型</h1><p>大型项目中通常有整个系统中经常使用的类型的集合；这种情况下，将这些类型收集入一个或多个低级全局utility名字空间中，这样做是明智的（请参见“避免使用基本类型”的示例）。</p>
<h1 id="9-4-2-避免使用基本类型"><a href="#9-4-2-避免使用基本类型" class="headerlink" title="9.4.2 避免使用基本类型"></a>9.4.2 避免使用基本类型</h1><p>当对可移植性要求较高、需要控制数字对象占据的内存空间或需要一个具体范围的值时，不使用基本类型。这种情况下最好通过使用适当的基本类型明确声明带有大小限制的类型的名称。</p>
<p>确保基本类型不会通过循环计数器、数组下标等潜回代码中。</p>
<p>示例</p>
<pre><code>namespace system_types {
typedef unsigned char byte;
typedef short int integer16; //16 位有符号整数
typedef int integer32; //32 位有符号整数
typedef unsigned short int natural16; //16 位无符号整数
typedef unsigned int natural32; //32 位无符号整数
...
}   
</code></pre><p>基本原理</p>
<p>基本类型的表示依赖于具体实现。</p>
<h1 id="9-4-3-使用-typedef-创建同义词来加强局部含义"><a href="#9-4-3-使用-typedef-创建同义词来加强局部含义" class="headerlink" title="9.4.3 使用 typedef 创建同义词来加强局部含义"></a>9.4.3 使用 typedef 创建同义词来加强局部含义</h1><p>对现有名称使用 typedef 创建同义词，提供更有意义的局部名称并提高易读性（这样做不会增加运行时间）。</p>
<p>typedef 也可用来提供受限名称的速记法。</p>
<p>示例</p>
<pre><code>//标准库的向量声明
//
namespace std {
template &lt;class T, class Alloc = allocator&gt;
    class vector {
    public:
    typedef typename Alloc::types&lt;T&gt;reference reference;
    typedef typename Alloc::types&lt;T&gt;const_reference const_reference;
    typedef typename Alloc::types&lt;T&gt;pointer iterator;
    typedef typename Alloc::types&lt;T&gt;const_pointer const_iterator;
    ...
    }
}    
</code></pre><p>使用 typedef 创建的名称时，同一代码段中不要混合使用原名称和它的同义词。</p>
<h1 id="9-5-常量与对象"><a href="#9-5-常量与对象" class="headerlink" title="9.5  常量与对象"></a>9.5  常量与对象</h1><h1 id="9-5-1-避免使用字符串值"><a href="#9-5-1-避免使用字符串值" class="headerlink" title="9.5.1 避免使用字符串值"></a>9.5.1 避免使用字符串值</h1><p>使用引用形式的已命名常量</p>
<h1 id="9-5-2-避免使用-define-预处理指示符来定义常量"><a href="#9-5-2-避免使用-define-预处理指示符来定义常量" class="headerlink" title="9.5.2 避免使用 #define 预处理指示符来定义常量"></a>9.5.2 避免使用 #define 预处理指示符来定义常量</h1><p>代之以 const 或 enum。</p>
<p>不要这样做：</p>
<pre><code>#define LIGHT_SPEED 3E8
</code></pre><p>而应这样做：</p>
<pre><code>const int light_speed = 3E8;
</code></pre><p>或对于数组大小可以这样做：</p>
<pre><code>enum { small_buffer_size = 100,
large_buffer_size = 1000 };
</code></pre><p>基本原理</p>
<p>因为由 #defines 引入的名称在编译预处理时会被替换掉，不出现在符号表中，因此调试就更加困难了。</p>
<h1 id="9-5-3-对象声明靠近其第一次使用点"><a href="#9-5-3-对象声明靠近其第一次使用点" class="headerlink" title="9.5.3 对象声明靠近其第一次使用点"></a>9.5.3 对象声明靠近其第一次使用点</h1><h1 id="9-5-4-声明时总要初始化-const-对象"><a href="#9-5-4-声明时总要初始化-const-对象" class="headerlink" title="9.5.4 声明时总要初始化 const 对象"></a>9.5.4 声明时总要初始化 const 对象</h1><p>未声明为 extern 的 const 对象有内部链接，声明时初始化这些常量对象允许在编译时使用初始化函数。</p>
<h1 id="9-5-5-永远不要cast掉常量对象的“不变性”"><a href="#9-5-5-永远不要cast掉常量对象的“不变性”" class="headerlink" title="9.5.5 永远不要cast掉常量对象的“不变性”"></a>9.5.5 永远不要cast掉常量对象的“不变性”</h1><p>常量对象可能存在于只读存储器中。</p>
<h1 id="9-5-6-定义时初始化对象"><a href="#9-5-6-定义时初始化对象" class="headerlink" title="9.5.6 定义时初始化对象"></a>9.5.6 定义时初始化对象</h1><p>如果对象不是自初始化的，在对象定义中指定初始值。如果不可能指定一个有意义的初始值，则赋值“nil”或考虑后面再作定义。</p>
<p>对大型对象，通常不建议先构造对象，此后再使用赋值语句初始化的作法。因为这样做的代价高昂（请参见“使用初始化构造函数而不使用构造函数中的赋值语句”）。</p>
<p>如果构造时不可能合适的初始化对象，则使用传统的“nil”值进行对象初始化，它意味着“未初始化”。只在初始化过程中声明“不可用但值已知”的对象时才使用 nil 值。但算法在受控模式下可以拒绝接受：在对象合适的初始化之前使用它时可以指出这是未经初始化的变量错误。</p>
<p>注意有时不可能所有类型都声明为 nil 值，尤其是在模运算类型中，例如角度。这种情况下选择最不可能出现的值。</p>
<p>#[第10章 表达式和语句]</p>
<p>本章对不同种类的 C++ 表达式和语句提供指南。</p>
<h1 id="10-1-表达式"><a href="#10-1-表达式" class="headerlink" title="10.1                  表达式"></a>10.1                  表达式</h1><h1 id="10-1-1-使用冗余的圆括号使复合表达式含义更加清晰"><a href="#10-1-1-使用冗余的圆括号使复合表达式含义更加清晰" class="headerlink" title="10.1.1             使用冗余的圆括号使复合表达式含义更加清晰"></a>10.1.1             使用冗余的圆括号使复合表达式含义更加清晰</h1><h1 id="10-1-2-避免表达式的过深嵌套"><a href="#10-1-2-避免表达式的过深嵌套" class="headerlink" title="10.1.2             避免表达式的过深嵌套"></a>10.1.2             避免表达式的过深嵌套</h1><p>表达式的嵌套层数定义为：忽略操作符优先级原则时，从左到右求表达式的值所需圆括号对的嵌套数。</p>
<p>嵌套层数过多会使表达式难以理解。</p>
<h1 id="10-1-3-不要假定任何特殊的表达式计算次序"><a href="#10-1-3-不要假定任何特殊的表达式计算次序" class="headerlink" title="10.1.3             不要假定任何特殊的表达式计算次序"></a>10.1.3             不要假定任何特殊的表达式计算次序</h1><p>除非计算次序由操作符指定（如逗号操作符、三元表达式、以及连接和分离），否则不要假定任何特殊的计算次序，因为这种假定可能导致严重的混淆并降低可移植性。</p>
<p>例如，同一语句中不要同时使用变量和变量的增 1 和减 1 操作。</p>
<p>示例</p>
<pre><code>foo(i, i++);
array[i] = i--;
10.1.4             空指针使用 0 而不使用 NULL
</code></pre><p>空指针应使用 0 还是 NULL 是一个有高度争议的论题。</p>
<p>C 和 C++ 中定义任何零值常量表达式都可解释为空指针。因为零难以阅读，并且不赞成使用常量，传统上程序员使用宏 NULL 作为空指针。不幸的是，NULL 没有可移植的定义。一些 ANSI C 编译器使用 (void *)0，但对 C++ 来说这不是一个好的选择：</p>
<pre><code>char* cp = (void*)0; /* C 合法但 C++ 不合法*/
</code></pre><p>因此任何形如 (T*)0 而非一个 0 的 NULL 定义，在C++ 中都需要类型转换。历史上，很多指南都拥护使用 0 代替空指针以减少类型转换、增强代码的可移植性。但许多 C++ 开发人员还是感觉使用 NULL 比 0 更加舒服，也争辩说当今多数的编译器（准确的说是多数头文件）将 NULL 实现为 0。</p>
<p>本指南倾向使用 0，因为不管 NULL 的值是多少，0 都是有效的。但由于争议，这一点降级为一个小技巧，可在适当的时候遵循或忽略它。</p>
<h1 id="10-1-5-不要使用旧式的类型转换"><a href="#10-1-5-不要使用旧式的类型转换" class="headerlink" title="10.1.5             不要使用旧式的类型转换"></a>10.1.5             不要使用旧式的类型转换</h1><p>使用新式类型转换符<code>(dynamic_cast、static_cast、reinterpret_cast、const_cast)</code>而不要使用旧式类型转换符。</p>
<p>如果您没有新式类型转换符，就应该完全避免使用类型转换，特别是向下转换（将基类对象转换成派生类对象）。</p>
<p>使用转换操作符如下：</p>
<ul>
<li><code>dynamic_cast</code>        — 类同一层次（子类型）成员间的的转换，使用运行类型信息（对带虚函数的类，运行类型信息是可用的）。这种类间的转换一定是安全的。</li>
<li><code>static_cast</code>            — 类同一层次成员间的的转换，不使用运行类型信息；所以这可能是不安全的。如果程序员不能保证类型的安全性，则使用 <code>dynamic_cast</code>。</li>
<li><code>reinterpret_cast</code>    — 不相关指针类型和整形（整数）间的转换；这是不安全的，只应在所提及的类型间使用。</li>
<li><code>const_cast</code>            — 将指定为 const 型函数实参的“不变性”转换掉。注意：<code>const_cast</code> 不打算将确实定义为常量对象（它可能位于只读存储器中）的“不变性”转换掉。<br>不要使用 typeid 实现类型转换逻辑：使类型转换操作符完成类型检查和转换的操作不可再分，详情请参见 [Stroustrup, 1994]。</li>
</ul>
<p>示例</p>
<p>不要这样做：</p>
<pre><code>void foo (const base&amp; b)
{
if (typeid(b) == typeid(derived1)) {
    do_derived1_stuff();
    else if (typeid(b) == typeid(derived2)) {
    do_derived2_stuff();
    else if () {
    }
}     
</code></pre><p>基本原理</p>
<p>旧式类型转换使类型系统失效，可能导致编译器难以察觉的缺陷：内存管理系统可能会崩溃，虚函数表可能遭严重错误修改，当对象作为派生类对象访问时无关对象可能会遭破坏。注意即使读访问也可能造成破坏，因为有可能引用了并不存在的指针或区域。</p>
<p>新式类型转换操作符使类型转换更加安全（多数情况下）、更加明确。</p>
<h1 id="10-1-6-Boolean（布尔）表达式使用新的-bool-类型"><a href="#10-1-6-Boolean（布尔）表达式使用新的-bool-类型" class="headerlink" title="10.1.6             Boolean（布尔）表达式使用新的 bool 类型"></a>10.1.6             Boolean（布尔）表达式使用新的 bool 类型</h1><p>不要使用旧的 Boolean 宏或常数：没有标准的布尔值 true（真）。代之以新的 bool 类型。</p>
<h1 id="10-1-7-不要直接与布尔值-true（真）做比较"><a href="#10-1-7-不要直接与布尔值-true（真）做比较" class="headerlink" title="10.1.7             不要直接与布尔值 true（真）做比较"></a>10.1.7             不要直接与布尔值 true（真）做比较</h1><p>因为传统上 true 值 (1 或 !0) 没有标准值，非零表达式和真值的比较就可能无效。</p>
<p>代之以使用布尔表达式。</p>
<p>示例</p>
<p>不要这样做：</p>
<pre><code>if (someNonZeroExpression == true)  //可能不会解释为真值条件
</code></pre><p>最好这样做：</p>
<pre><code>if (someNonZeroExpression)  //一定会解释为一个真值条件
</code></pre><h1 id="10-1-8-不在同一数组中的对象的指针不要做比较"><a href="#10-1-8-不在同一数组中的对象的指针不要做比较" class="headerlink" title="10.1.8             不在同一数组中的对象的指针不要做比较"></a>10.1.8             不在同一数组中的对象的指针不要做比较</h1><p>这种操作的结果几乎都是毫无意义的。</p>
<h1 id="10-1-9-已删除的对象指针要赋予空指针值"><a href="#10-1-9-已删除的对象指针要赋予空指针值" class="headerlink" title="10.1.9             已删除的对象指针要赋予空指针值"></a>10.1.9             已删除的对象指针要赋予空指针值</h1><p>设置已删除对象的指针为空指针可避免灾难的发生：重复删除非空指针是有害的，但重复删除空指针是无害的。</p>
<p>即使在函数返回前，删除操作后也总要赋一个空指针，因为以后可能添加新的代码。</p>
<h1 id="10-2-语句"><a href="#10-2-语句" class="headerlink" title="10.2                  语句"></a>10.2                  语句</h1><h1 id="10-2-1-当分支条件为布尔表达式时使用-if-语句"><a href="#10-2-1-当分支条件为布尔表达式时使用-if-语句" class="headerlink" title="10.2.1             当分支条件为布尔表达式时使用 if 语句"></a>10.2.1             当分支条件为布尔表达式时使用 if 语句</h1><h1 id="10-2-2-当分支条件为离散时使用-switch-语句"><a href="#10-2-2-当分支条件为离散时使用-switch-语句" class="headerlink" title="10.2.2             当分支条件为离散时使用 switch 语句"></a>10.2.2             当分支条件为离散时使用 switch 语句</h1><p>当分支条件为离散值时使用 switch 语句而不使用一系列的“else if”。</p>
<h1 id="10-2-3-一定为-switch-语句提供一个-default-分支以捕获错误"><a href="#10-2-3-一定为-switch-语句提供一个-default-分支以捕获错误" class="headerlink" title="10.2.3             一定为 switch 语句提供一个 default 分支以捕获错误"></a>10.2.3             一定为 switch 语句提供一个 default 分支以捕获错误</h1><p>switch 语句应总包含一个 default 分支，default 分支应用于捕获错误。</p>
<p>这一原则保证了当引入新的 switch 值而处理这一新值的分支被忽略时，现有的 default 分支可以捕获到错误。</p>
<h1 id="10-2-4-当循环需要迭代前测试时使用-for-语句或-while-语句"><a href="#10-2-4-当循环需要迭代前测试时使用-for-语句或-while-语句" class="headerlink" title="10.2.4             当循环需要迭代前测试时使用 for 语句或 while 语句"></a>10.2.4             当循环需要迭代前测试时使用 for 语句或 while 语句</h1><p>当迭代和循环的结束是根据循环计数器的值时使用 for 语句不使用 while 语句。</p>
<h1 id="10-2-5-当循环需要迭代后测试时使用-do-while-语句"><a href="#10-2-5-当循环需要迭代后测试时使用-do-while-语句" class="headerlink" title="10.2.5             当循环需要迭代后测试时使用 do while 语句"></a>10.2.5             当循环需要迭代后测试时使用 do while 语句</h1><h1 id="10-2-6-循环中避免使用-jump-语句"><a href="#10-2-6-循环中避免使用-jump-语句" class="headerlink" title="10.2.6             循环中避免使用 jump 语句"></a>10.2.6             循环中避免使用 jump 语句</h1><p>避免使用除循环结束条件以外的循环退出方式（使用 break、return 或 goto），不要使用 continue 的跳转到下一迭代上。这减少了控制路径流程的数量，使代码更易理解。</p>
<h1 id="10-2-7-不要使用-goto-语句"><a href="#10-2-7-不要使用-goto-语句" class="headerlink" title="10.2.7             不要使用 goto 语句"></a>10.2.7             不要使用 goto 语句</h1><h1 id="10-2-8-避免嵌套作用域内隐藏标识符"><a href="#10-2-8-避免嵌套作用域内隐藏标识符" class="headerlink" title="10.2.8             避免嵌套作用域内隐藏标识符"></a>10.2.8             避免嵌套作用域内隐藏标识符</h1><p>这会使读者模糊不清，维护时造成潜在的危险。</p>
<p>#[第11章  特殊主题]</p>
<p>本章为内存管理与错误报告提供指南</p>
<h1 id="11-1-内存管理"><a href="#11-1-内存管理" class="headerlink" title="11.1                  内存管理"></a>11.1                  内存管理</h1><h1 id="11-1-1-避免混合使用C-和-C-内存操作"><a href="#11-1-1-避免混合使用C-和-C-内存操作" class="headerlink" title="11.1.1             避免混合使用C 和 C++ 内存操作"></a>11.1.1             避免混合使用C 和 C++ 内存操作</h1><p>C 库函数 malloc、calloc 和 realloc 不应用于分配对象空间：此时应使用 C++ 操作符 new。</p>
<p>只有在内存传递给C 库函数处理时，才使用 C 函数分配内存。</p>
<p>不要使用 delete 来释放由 C 函数分配的内存，或用free来释放由 new 创建的对象。</p>
<h1 id="11-1-2-删除由-new-创建的数组对象时总使用-delete"><a href="#11-1-2-删除由-new-创建的数组对象时总使用-delete" class="headerlink" title="11.1.2             删除由 new 创建的数组对象时总使用 delete[]"></a>11.1.2             删除由 new 创建的数组对象时总使用 delete[]</h1><p>使用 delete 删除数组对象时如果不使用空方括号（“<code>[]</code>”），则只删除数组的第一个元素，因此导致内存泄漏。</p>
<h1 id="11-2-错误处理和异常"><a href="#11-2-错误处理和异常" class="headerlink" title="11.2                  错误处理和异常"></a>11.2                  错误处理和异常</h1><p>C++ 标准定义了两大类错误：逻辑错误和运行错误。逻辑错误是可避免的编程错误。运行错误定义为程序范围外事件导致的错误。</p>
<p>使用异常的通用规则为：正常条件下的系统如果没有重载或硬件错误则不应当产生任何异常。</p>
<h1 id="11-2-1-开发过程中多使用“断言语句”以发现错误"><a href="#11-2-1-开发过程中多使用“断言语句”以发现错误" class="headerlink" title="11.2.1             开发过程中多使用“断言语句”以发现错误"></a>11.2.1             开发过程中多使用“断言语句”以发现错误</h1><p>开发过程中使用函数的前置和后置条件“断言语句”以发现“倒毙”错误。</p>
<p>在实现最终错误处理代码前，“断言语句”提供了简单有用的临时错误监测机制。“断言语句”还有额外的好处，使用“NDEBUG”预处理符，可在编译时去掉这些“断言”（请参见“用具体值定义 NDEBUG 预处理符”）。</p>
<p>传统上使用宏 assert 达到这一目的；但文献 [Stroustrup, 1994] 提供了一个可替代的模板如下。</p>
<p>示例</p>
<pre><code>template&lt;class T, class Exception&gt;
inline void assert ( T a_boolean_expression,
Exception the_exception)
{
    if (! NDEBUG)
    if (! a_boolean_expression)
    throw the_exception;
}   
</code></pre><h1 id="11-2-2-只在确实是异常的情况下使用异常"><a href="#11-2-2-只在确实是异常的情况下使用异常" class="headerlink" title="11.2.2             只在确实是异常的情况下使用异常"></a>11.2.2             只在确实是异常的情况下使用异常</h1><p>对经常的、预料中的事件不要使用异常：异常打断了代码的正常控制流程，使它难以理解和维护。</p>
<p>预料中的事件应用代码的正常控制流程处理；需要时使用函数返回值或“out”参数状态码。</p>
<p>异常也不应用于实现控制结构：这会是另一种形式的“goto”语句。</p>
<h1 id="11-2-3-从标准异常中派生项目自己的异常"><a href="#11-2-3-从标准异常中派生项目自己的异常" class="headerlink" title="11.2.3             从标准异常中派生项目自己的异常"></a>11.2.3             从标准异常中派生项目自己的异常</h1><p>这保证了所有异常都支持常用操作的最小集合并可由一小组高级处理程序处理。</p>
<p>使用逻辑错误（域错误、非法实参错误、长度错误和越界错误）表示应用程序域错误、函数调用传递了非法实参、对象构造超出了它们允许的大小以及实参值不在允许范围内。</p>
<p>使用运行错误（范围错误和溢出错误）表示只有在运行时才能查出的算术和配置错误、数据已遭破坏或资源耗尽错误。</p>
<h1 id="11-2-4-给定抽象尽量少使用异常"><a href="#11-2-4-给定抽象尽量少使用异常" class="headerlink" title="11.2.4             给定抽象尽量少使用异常"></a>11.2.4             给定抽象尽量少使用异常</h1><p>大型系统中，每一层都不得不处理大量的异常会使代码难以阅读和维护。异常处理可能会严重影响了正常处理。</p>
<p>减少异常数目的方法有：</p>
<p>通过使用少量的异常种类在抽象间共享异常。</p>
<p>引发派生于标准异常的特殊异常，处理更通用的异常。</p>
<p>为对象添加“异常”状态，提供明确检查对象合法性的原语。</p>
<h1 id="11-2-5-将所有异常声明为thrown"><a href="#11-2-5-将所有异常声明为thrown" class="headerlink" title="11.2.5             将所有异常声明为thrown"></a>11.2.5             将所有异常声明为thrown</h1><p>产生异常（而不仅仅是传递异常）的函数应在它们的异常规约中将所有异常声明为thrown：它们不应平静的产生异常而不警告它们的用户。</p>
<h1 id="11-2-6-在异常首次出现时就报告它"><a href="#11-2-6-在异常首次出现时就报告它" class="headerlink" title="11.2.6             在异常首次出现时就报告它"></a>11.2.6             在异常首次出现时就报告它</h1><p>开发过程中，采用合适的记录机制尽早报告异常，包括在“异常引发点”。</p>
<h1 id="11-2-7-按照从派生结构最底端到最顶端的顺序定义异常处理"><a href="#11-2-7-按照从派生结构最底端到最顶端的顺序定义异常处理" class="headerlink" title="11.2.7             按照从派生结构最底端到最顶端的顺序定义异常处理"></a>11.2.7             按照从派生结构最底端到最顶端的顺序定义异常处理</h1><p>定义异常处理要按照从派生结构最底端到最顶端（即从最终子类到最初父类）的顺序，这样可以避免编写无法到达的处理过程；请参见下面的示例 how-not-to-it。因为是以声明的顺序匹配处理过程的，所以这也保证了异常由最合适的处理过程捕获。</p>
<p>示例</p>
<p>不要这样做：</p>
<pre><code>class base { ...};
class derived : public base { ...};
...
try {
    ...
    throw derived(...);
    //
    //引发一个派生类异常
}
catch (base&amp; a_base_failure)
//
//但基类异常处理过程“捕获”了它，因为
//基类处理过程首先匹配！
{
...
    }
catch (derived&amp; a_derived_failure)
//
//这一处理过程是无法达到的！
{
    ...
}     
</code></pre><h1 id="11-2-8-避免使用捕获所有异常的处理过程"><a href="#11-2-8-避免使用捕获所有异常的处理过程" class="headerlink" title="11.2.8             避免使用捕获所有异常的处理过程"></a>11.2.8             避免使用捕获所有异常的处理过程</h1><p>避免使用捕获所有异常的处理过程（处理过程声明使用 “…”），除非会重引发了异常，只有在做本地内务管理时才使用捕获所有异常的处理过程，这时应重引发异常以避免掩盖了本层不能处理此异常的事实。</p>
<pre><code>try {
    ...
}
catch (...)
{
    if (io.is_open(local_file))
    {
        io.close(local_file);
    }
    throw;
}  
</code></pre><h1 id="11-2-9-确保函数状态代码有合适的值"><a href="#11-2-9-确保函数状态代码有合适的值" class="headerlink" title="11.2.9             确保函数状态代码有合适的值"></a>11.2.9             确保函数状态代码有合适的值</h1><p>当状态代码作为函数参数返回时，要赋值给参数作为程序体中的第一个可执行语句。系统的设置所有状态的默认值为成功或失败。考虑函数所有可能的出口，包括异常处理。</p>
<h1 id="11-2-10-本地执行安全检查；不要希望您的客户会这样做"><a href="#11-2-10-本地执行安全检查；不要希望您的客户会这样做" class="headerlink" title="11.2.10         本地执行安全检查；不要希望您的客户会这样做"></a>11.2.10         本地执行安全检查；不要希望您的客户会这样做</h1><p>如果没有合适的输入，函数就会产生错误输出，在函数中装载代码以受控方式监测和报告非法输入。不要依赖于标注来告知客户传递合适的值。事实上标注迟早会被忽略掉，如果检测到非法参数就会导致难以调试的错误。</p>
<p>#[第12章  可移植性]</p>
<p>本章论述先验不可移植的语言特征。</p>
<h1 id="12-1-路径名"><a href="#12-1-路径名" class="headerlink" title="12.1                  路径名"></a>12.1                  路径名</h1><h1 id="12-1-1-不要使用硬编码的文件路径名"><a href="#12-1-1-不要使用硬编码的文件路径名" class="headerlink" title="12.1.1             不要使用硬编码的文件路径名"></a>12.1.1             不要使用硬编码的文件路径名</h1><p>各操作系统中的路径名不是以标准形式表示的。使用它们将会引入对平台的依赖。</p>
<p>示例</p>
<pre><code>#include &quot;somePath/filename.hh&quot; // Unix
#include &quot;somePath\filename.hh&quot; // MSDOS
</code></pre><h1 id="12-2-数据表示"><a href="#12-2-数据表示" class="headerlink" title="12.2                  数据表示"></a>12.2                  数据表示</h1><p>类型的表示和alignment高度依赖于机器的结构。对表示和排列的假设会导致混淆，降低可移植性。</p>
<h1 id="12-2-1-不要对类型的表示做假设"><a href="#12-2-1-不要对类型的表示做假设" class="headerlink" title="12.2.1             不要对类型的表示做假设"></a>12.2.1             不要对类型的表示做假设</h1><p>特别的，不可以在 int、长整形或任何其他数字类型中存储指针类型，因为这是高度不可移植的。</p>
<h1 id="12-2-2-不要对类型的alignment作假设"><a href="#12-2-2-不要对类型的alignment作假设" class="headerlink" title="12.2.2             不要对类型的alignment作假设"></a>12.2.2             不要对类型的alignment作假设</h1><h1 id="12-2-3-不要依赖于一个特殊的下溢或上溢行为"><a href="#12-2-3-不要依赖于一个特殊的下溢或上溢行为" class="headerlink" title="12.2.3             不要依赖于一个特殊的下溢或上溢行为"></a>12.2.3             不要依赖于一个特殊的下溢或上溢行为</h1><h1 id="12-2-4-尽可能使用“可伸缩”常量"><a href="#12-2-4-尽可能使用“可伸缩”常量" class="headerlink" title="12.2.4             尽可能使用“可伸缩”常量"></a>12.2.4             尽可能使用“可伸缩”常量</h1><p>可伸缩常量避免了字长变化的问题。</p>
<p>示例</p>
<pre><code>const int all_ones = ~0;
const int last_3_bits = ~0x7;
</code></pre><h1 id="12-3-类型转换"><a href="#12-3-类型转换" class="headerlink" title="12.3                  类型转换"></a>12.3                  类型转换</h1><h1 id="12-3-1-不要从一个“短”类型转换成一个“长类型”"><a href="#12-3-1-不要从一个“短”类型转换成一个“长类型”" class="headerlink" title="12.3.1             不要从一个“短”类型转换成一个“长类型”"></a>12.3.1             不要从一个“短”类型转换成一个“长类型”</h1><p>机器结构可能指定了某种类型的排列方式。从需要较松散排列的类型转换为需要较严密排列的类型可能会导致程序错误。</p>
<p>#[第13章  复用]</p>
<p>本章为 C++ 代码复用提供指南。</p>
<h1 id="13-1-尽可能使用标准库构件"><a href="#13-1-尽可能使用标准库构件" class="headerlink" title="13.1                  尽可能使用标准库构件"></a>13.1                  尽可能使用标准库构件</h1><p>如果没有标准库，则基于标准库接口创建类，这有利于将来的移植。</p>
<h1 id="13-2-使用template实现独立于数据的行为的复用"><a href="#13-2-使用template实现独立于数据的行为的复用" class="headerlink" title="13.2                  使用template实现独立于数据的行为的复用"></a>13.2                  使用template实现独立于数据的行为的复用</h1><p>当行为不依赖于一个具体的数据类型时，使用template方式来复用行为。</p>
<h1 id="13-3-使用公共继承复用类接口（子类型化）"><a href="#13-3-使用公共继承复用类接口（子类型化）" class="headerlink" title="13.3                  使用公共继承复用类接口（子类型化）"></a>13.3                  使用公共继承复用类接口（子类型化）</h1><p>使用 public 继承表达“is a”关系并复用基类接口，还可有选择的复用它们的实现。</p>
<h1 id="13-4-使用包含而不是私有继承复用类的实现"><a href="#13-4-使用包含而不是私有继承复用类的实现" class="headerlink" title="13.4                  使用包含而不是私有继承复用类的实现"></a>13.4                  使用包含而不是私有继承复用类的实现</h1><p>当复用实现或建模“部分/整体”关系时，避免使用私有继承。复用未重新定义的实现最好由包含而非私有继承来实现。</p>
<p>当需要重新定义基类的操作时使用私有继承。</p>
<h1 id="13-5-谨慎使用多继承"><a href="#13-5-谨慎使用多继承" class="headerlink" title="13.5                  谨慎使用多继承"></a>13.5                  谨慎使用多继承</h1><p>多继承应谨慎使用，因为它带来了许多额外的复杂性。[Meyers, 1992] 提供了对潜在名称歧义和重复继承所带来复杂性的详细讨论。复杂性来自于：</p>
<p>歧义，当多个类使用相同的名称时，任何对名称不加限定的引用天生就是产生歧义的。可通过使用类名称限定其成员名称来解决歧义的问题。但这也带来了不幸的后果：使多态无效且将虚函数准变成了静态绑定函数。</p>
<p>从同一基类重复继承（派生类通过继承结构的不同路径多次继承一个基类）多组数据成员产生了如下问题：应当使用多组数据成员中的哪一个？</p>
<p>可使用虚继承（对虚基类的继承）防止多继承数据成员。那么为什么不总使用虚继承呢？虚继承有负面影响，会改变基础对象表示并降低访问的效率。</p>
<p>要求所有的继承都是虚拟的，同时也就强加了包罗一切的空间，带来了时间上的低效，实现这样的政策过于独断了。</p>
<p>因此，为了决定是使用虚继承还是非虚继承，多继承需要类的设计者对将来类的使用有敏锐的洞察力</p>
<p>#[第14章  编译问题]</p>
<p>本章为编译问题指南</p>
<h1 id="14-1-尽量减少对编译的依赖"><a href="#14-1-尽量减少对编译的依赖" class="headerlink" title="14.1                  尽量减少对编译的依赖"></a>14.1                  尽量减少对编译的依赖</h1><p>模块规约中不要包含只是此模块实现所需的其他头文件。</p>
<p>避免在只需要指针或引用可见时就为了能看到其他类而在规约中包含头文件；代之以预先声明。</p>
<p>示例</p>
<pre><code>//模块 A 规约，包含于文件“A.hh”中
#include &quot;B.hh&quot; //当只有实现需要时
                //不要包含。
#include &quot;C.hh&quot; //只有引用需要时不要包含；
                //代之以预先声明。
class C;
class A
{
    C* a_c_by_reference; //有 a 的引用。
};
// “A.hh”结束
</code></pre><p>注意：</p>
<p>尽量减少对编译的依赖是某些设计代码模式或模式的基本原理，如不同的命名：Handle（句柄）或 Envelope（信包）[Meyers, 1992]，或 Bridge（桥）[Gamma] 类。将类抽象的责任在两个关联类间分割，一个提供类接口，另一个提供类实现；因为任何实现（实现类）上的改变都不再需要客户重新编译，因此类与其客户间的依赖关系就最小化了。</p>
<p>示例</p>
<pre><code>//模块 A 规约，包含于文件“A.hh”中
class A_implementation;
class A
{
    A_implementation* the_implementation;
};
//“A.hh”结束
这一做法也允许接口类和实现类特殊化为两个单独的类层次结构。
</code></pre><h1 id="14-2-用具体值定义-NDEBUG"><a href="#14-2-用具体值定义-NDEBUG" class="headerlink" title="14.2                  用具体值定义 NDEBUG"></a>14.2                  用具体值定义 NDEBUG</h1><p>通常使用符号 NDEBUG 在编译过程中去掉由宏 assert 实现的声明代码。传统做法是当需要消除声明语句时定义这一符号；但是，开发人员经常没有意识到声明的存在，因此没有定义符号。</p>
<p>我们支持使用声明的模板版本；这种情况下符号 NDEBUG 必须明确的赋值：需要声明代码时为 0；要消除时为非 0。任何没有提供符号 NDEBUG 以具体值的声明代码最终编译时将产生编译错误；因此，提醒了开发人员注意声明代码的存在。</p>
<h1 id="14-3-采用统一的系统配置头文件compiler-h"><a href="#14-3-采用统一的系统配置头文件compiler-h" class="headerlink" title="14.3                  采用统一的系统配置头文件compiler.h"></a>14.3                  采用统一的系统配置头文件compiler.h</h1><p>将所有操作系统、硬件平台、编译器等相关的的内容都放到compiler.h中，每一个c/c++源文件的头上，必须第一个包含compiler.h。</p>
<p>#[第15章  后记]</p>
<h1 id="15-1-参考文献"><a href="#15-1-参考文献" class="headerlink" title="15.1                  参考文献"></a>15.1                  参考文献</h1><ul>
<li>《C++ Primer》<blockquote>
<p>Stanley.B.Lippman  Josee Lajoice  Barbara E. Moo</p>
</blockquote>
</li>
</ul>
<ul>
<li>《Thinking In C++》</li>
</ul>
<blockquote>
<p>Bruce Eckel &amp; Chuck Allison</p>
</blockquote>
<ul>
<li>《The Design and Evolution of C++》</li>
</ul>
<blockquote>
<p>Bjarne Stroustrup</p>
</blockquote>
<ul>
<li>《Effective C++》《More Effective C++》</li>
</ul>
<blockquote>
<p>Scott Meyers</p>
</blockquote>
<ul>
<li>《Inside the C++ Object Module》</li>
</ul>
<blockquote>
<p>Stanley.B.Lippman</p>
</blockquote>
<ul>
<li>《Design Patterns – Elements of Reusable Object-Oriented Software》</li>
</ul>
<blockquote>
<p>Gof4</p>
</blockquote>
<ul>
<li>《C++ Coding Standards: 101 Rules, Guidelines, and Best Practices》</li>
</ul>
<blockquote>
<p>Herb Sutter &amp; Andrei Alexandrescu</p>
</blockquote>
<ul>
<li>《Secure Coding in C and C++》</li>
</ul>
<blockquote>
<p>Robert C. Seacord</p>
</blockquote>
<ul>
<li>《Google C++ Style Guide》</li>
</ul>
<blockquote>
<p>Google</p>
</blockquote>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2016/05/28/C-C-经验累积-C-代码编写规范及设计参考/" data-id="ciusiv0sb00eauk63w02tk97y" class="article-share-link">分享到</a><div class="tags"><a href="/tags/C-C-经验累积/">C&amp;C++经验累积</a></div><div class="post-nav"><a href="/2016/05/28/C-C-经验累积-设计模式心得/" class="pre">设计模式心得</a><a href="/2016/05/28/C-C-经验累积-C语言可变参数宏/" class="next">C语言可变参数宏</a></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C-C-经验累积/">C&C++经验累积</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Docker学习/">Docker学习</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux使用/">Linux使用</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux内核学习/">Linux内核学习</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux系统编程/">Linux系统编程</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux网络编程/">Linux网络编程</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Q-A/">Q&A</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Sip协议/">Sip协议</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux内核驱动与文件系统/">linux内核驱动与文件系统</a><span class="category-list-count">24</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/project-note/">project_note</a><span class="category-list-count">13</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/project-note/decode/">decode</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/project-note/think-about/">think_about</a><span class="category-list-count">4</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/开发环境搭建/">开发环境搭建</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂项/">杂项</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/渗透测试/">渗透测试</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/源码分析/">源码分析</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法学习/">算法学习</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/系统性能/">系统性能</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/">阅读笔记</a><span class="category-list-count">258</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/C-11新特性/">C++11新特性</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/C-Templates/">C++Templates</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/C程序设计语言/">C程序设计语言</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/EffectiveC/">EffectiveC++</a><span class="category-list-count">50</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/EffectiveSTL/">EffectiveSTL</a><span class="category-list-count">51</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/InsideC-ObjectModel/">InsideC++ObjectModel</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/Linux多线程服务器编程/">Linux多线程服务器编程</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/Linux性能优化大师/">Linux性能优化大师</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/Linux设备驱动程序/">Linux设备驱动程序</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/MoreEffectiveC/">MoreEffectiveC++</a><span class="category-list-count">26</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/TCPIP详解Vol1/">TCPIP详解Vol1</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/TheC-StandardLibraryEd1/">TheC++StandardLibraryEd1</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/TheC-StandardLibraryEd2/">TheC++StandardLibraryEd2</a><span class="category-list-count">23</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/http权威指南/">http权威指南</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/unix网络编程Ed3/">unix网络编程Ed3</a><span class="category-list-count">28</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/wireshark数据包分析实战/">wireshark数据包分析实战</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/实战LinuxShell编程与服务器管理/">实战LinuxShell编程与服务器管理</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/程序员的自我修养/">程序员的自我修养</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/网络安全基础/">网络安全基础</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/面向模式的软件体系结构Vol1/">面向模式的软件体系结构Vol1</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/高级C-C-编译技术/">高级C&C++编译技术</a><span class="category-list-count">2</span></li></ul></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/C程序设计语言/" style="font-size: 15px;">C程序设计语言</a> <a href="/tags/C-C-经验累积/" style="font-size: 15px;">C&C++经验累积</a> <a href="/tags/Linux使用/" style="font-size: 15px;">Linux使用</a> <a href="/tags/Linux内核学习/" style="font-size: 15px;">Linux内核学习</a> <a href="/tags/Linux系统编程/" style="font-size: 15px;">Linux系统编程</a> <a href="/tags/Q-A/" style="font-size: 15px;">Q&A</a> <a href="/tags/Linux网络编程/" style="font-size: 15px;">Linux网络编程</a> <a href="/tags/Sip协议/" style="font-size: 15px;">Sip协议</a> <a href="/tags/开发环境搭建/" style="font-size: 15px;">开发环境搭建</a> <a href="/tags/杂项/" style="font-size: 15px;">杂项</a> <a href="/tags/linux内核驱动与文件系统/" style="font-size: 15px;">linux内核驱动与文件系统</a> <a href="/tags/渗透测试/" style="font-size: 15px;">渗透测试</a> <a href="/tags/算法学习/" style="font-size: 15px;">算法学习</a> <a href="/tags/系统性能/" style="font-size: 15px;">系统性能</a> <a href="/tags/阅读笔记/" style="font-size: 15px;">阅读笔记</a> <a href="/tags/源码分析/" style="font-size: 15px;">源码分析</a> <a href="/tags/decode/" style="font-size: 15px;">decode</a> <a href="/tags/think-about/" style="font-size: 15px;">think_about</a> <a href="/tags/C-11新特性/" style="font-size: 15px;">C++11新特性</a> <a href="/tags/Docker学习/" style="font-size: 15px;">Docker学习</a> <a href="/tags/InsideC-ObjectModel/" style="font-size: 15px;">InsideC++ObjectModel</a> <a href="/tags/C-Templates/" style="font-size: 15px;">C++Templates</a> <a href="/tags/Linux性能优化大师/" style="font-size: 15px;">Linux性能优化大师</a> <a href="/tags/Linux设备驱动程序/" style="font-size: 15px;">Linux设备驱动程序</a> <a href="/tags/MoreEffectiveC/" style="font-size: 15px;">MoreEffectiveC++</a> <a href="/tags/Linux多线程服务器编程/" style="font-size: 15px;">Linux多线程服务器编程</a> <a href="/tags/EffectiveC/" style="font-size: 15px;">EffectiveC++</a> <a href="/tags/TheC-StandardLibraryEd1/" style="font-size: 15px;">TheC++StandardLibraryEd1</a> <a href="/tags/TCPIP详解Vol1/" style="font-size: 15px;">TCPIP详解Vol1</a> <a href="/tags/EffectiveSTL/" style="font-size: 15px;">EffectiveSTL</a> <a href="/tags/unix网络编程Ed3/" style="font-size: 15px;">unix网络编程Ed3</a> <a href="/tags/http权威指南/" style="font-size: 15px;">http权威指南</a> <a href="/tags/wireshark数据包分析实战/" style="font-size: 15px;">wireshark数据包分析实战</a> <a href="/tags/实战LinuxShell编程与服务器管理/" style="font-size: 15px;">实战LinuxShell编程与服务器管理</a> <a href="/tags/网络安全基础/" style="font-size: 15px;">网络安全基础</a> <a href="/tags/程序员的自我修养/" style="font-size: 15px;">程序员的自我修养</a> <a href="/tags/高级C-C-编译技术/" style="font-size: 15px;">高级C&C++编译技术</a> <a href="/tags/TheC-StandardLibraryEd2/" style="font-size: 15px;">TheC++StandardLibraryEd2</a> <a href="/tags/面向模式的软件体系结构Vol1/" style="font-size: 15px;">面向模式的软件体系结构Vol1</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/10/27/算法学习-基础算法学习-九-——-图的最小生成树/">算法学习-基础算法学习-九-——-图的最小生成树</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/27/算法学习-基础算法学习-十-——-图的最短路径/">算法学习-基础算法学习-十-——-图的最短路径</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/27/Linux内核学习-Linux内核初探-之-进程-三-——进程调度算法/">Linux内核初探 之 进程(三) —— 进程调度算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/27/杂项-系统安全性设计/">系统安全性设计</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/25/算法学习-基础算法学习-七-——-图的数据结构/">基础算法学习(七) —— 图的数据结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/25/算法学习-基础算法学习-八-——-图的遍历/">基础算法学习(八) —— 图的遍历</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/25/Linux内核学习-Linux内核初探-之-进程-二-——进程管理/">Linux内核初探 之 进程(二) —— 进程管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/24/Linux内核学习-Linux内核初探-之-进程-一-——-进程基础/">Linux内核初探 之 进程(一) —— 进程基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/21/算法学习-基础算法学习-六-——-图的基本概念/">基础算法学习(六) —— 图的基本概念</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/20/算法学习-基础算法学习-五-——-树的排序、查找与平衡/">基础算法学习(五) —— 树的排序、查找与平衡</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://easy.ac.cn/" title="easy" target="_blank">easy</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">dupengair的blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>