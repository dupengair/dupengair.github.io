<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="keep it simple, stupid"><title>四、高级IO | dupengair的blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/3.0.3/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">四、高级IO</h1><a id="logo" href="/.">dupengair的blog</a><p class="description">日拱一卒 精而悟道</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">四、高级IO</h1><div class="post-meta">May 28, 2016<span> | </span><span class="category"><a href="/categories/Linux网络编程/">Linux网络编程</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#IO复用——select和poll"><span class="toc-number">1.</span> <span class="toc-text">IO复用——select和poll</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#一、I-O复用"><span class="toc-number">2.</span> <span class="toc-text">一、I/O复用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、I-O模型"><span class="toc-number">3.</span> <span class="toc-text">二、I/O模型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、select"><span class="toc-number">4.</span> <span class="toc-text">三、select</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四、shutdown"><span class="toc-number">5.</span> <span class="toc-text">四、shutdown</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#五、拒绝服务DoS"><span class="toc-number">6.</span> <span class="toc-text">五、拒绝服务DoS</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#六、pselect"><span class="toc-number">7.</span> <span class="toc-text">六、pselect</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#七、poll"><span class="toc-number">8.</span> <span class="toc-text">七、poll</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#高级IO"><span class="toc-number">9.</span> <span class="toc-text">高级IO</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#一、套接字超时"><span class="toc-number">10.</span> <span class="toc-text">一、套接字超时</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、recv和send"><span class="toc-number">11.</span> <span class="toc-text">二、recv和send</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、readv和writev"><span class="toc-number">12.</span> <span class="toc-text">三、readv和writev</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四、recvmsg和sendmsg"><span class="toc-number">13.</span> <span class="toc-text">四、recvmsg和sendmsg</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#五、5组IO接口的差异"><span class="toc-number">14.</span> <span class="toc-text">五、5组IO接口的差异</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#六、辅助数据-控制信息"><span class="toc-number">15.</span> <span class="toc-text">六、辅助数据/控制信息</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#七、排队的数据量"><span class="toc-number">16.</span> <span class="toc-text">七、排队的数据量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#八、套接字和标准IO"><span class="toc-number">17.</span> <span class="toc-text">八、套接字和标准IO</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#九、高级轮询"><span class="toc-number">18.</span> <span class="toc-text">九、高级轮询</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#十、kqueue"><span class="toc-number">19.</span> <span class="toc-text">十、kqueue</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#非阻塞IO"><span class="toc-number">20.</span> <span class="toc-text">非阻塞IO</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#一、套接字调用的阻塞与非阻塞"><span class="toc-number">21.</span> <span class="toc-text">一、套接字调用的阻塞与非阻塞</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、非阻塞connect"><span class="toc-number">22.</span> <span class="toc-text">二、非阻塞connect</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、非阻塞accept"><span class="toc-number">23.</span> <span class="toc-text">三、非阻塞accept</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ioctl操作"><span class="toc-number">24.</span> <span class="toc-text">ioctl操作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#一、ioctl函数"><span class="toc-number">25.</span> <span class="toc-text">一、ioctl函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、套接字操作"><span class="toc-number">26.</span> <span class="toc-text">二、套接字操作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、文件操作"><span class="toc-number">27.</span> <span class="toc-text">三、文件操作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四、接口配置"><span class="toc-number">28.</span> <span class="toc-text">四、接口配置</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#五、接口操作"><span class="toc-number">29.</span> <span class="toc-text">五、接口操作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#六、ARP高速缓存"><span class="toc-number">30.</span> <span class="toc-text">六、ARP高速缓存</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#七、路由表操作"><span class="toc-number">31.</span> <span class="toc-text">七、路由表操作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#信号驱动IO"><span class="toc-number">32.</span> <span class="toc-text">信号驱动IO</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#一、设置套接字的信号驱动IO"><span class="toc-number">33.</span> <span class="toc-text">一、设置套接字的信号驱动IO</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、信号产生条件"><span class="toc-number">34.</span> <span class="toc-text">二、信号产生条件</span></a></li></ol></div></div><div class="post-content"><hr>
<h1 id="IO复用——select和poll"><a href="#IO复用——select和poll" class="headerlink" title="IO复用——select和poll"></a>IO复用——select和poll</h1><hr>
<h1 id="一、I-O复用"><a href="#一、I-O复用" class="headerlink" title="一、I/O复用"></a>一、I/O复用</h1><ol>
<li>I/O复用： 内核发现指定的I/O条件就绪，立即通知进程的过程</li>
<li>I/O复用的场合<ul>
<li>同时处理多个描述符</li>
<li>同时处理多个套接字</li>
<li>同时处理监听套接字和已连接套接字</li>
<li>同时处理TCP和UDP</li>
<li>同时处理多个服务和多个协议</li>
</ul>
</li>
</ol>
<h1 id="二、I-O模型"><a href="#二、I-O模型" class="headerlink" title="二、I/O模型"></a>二、I/O模型</h1><ul>
<li><p>Unix下可用的5种IO：</p>
<blockquote>
<p>阻塞式IO</p>
<p>非阻塞式IO</p>
<p>IO复用(select/poll/epoll)</p>
<p>型号驱动(SIGIO)</p>
<p>异步(aio_xxx)</p>
</blockquote>
</li>
<li><p>输入操作的两个阶段:</p>
<blockquote>
<p>等待数据准备</p>
<p>从内核向进程复制数据</p>
</blockquote>
</li>
<li><p>同步IO与异步IO</p>
<blockquote>
<p>同步IO：真正的IO操作将阻塞进程（由进程完成）</p>
<p>异步IO：IO操作由内核完成，不阻塞进程</p>
</blockquote>
</li>
</ul>
<ol>
<li><p>阻塞式IO</p>
<ul>
<li>从进程空间切换到内核空间等待数据，阻塞在IO系统调用上</li>
<li>最常见错误是系统调用被信号中断</li>
</ul>
</li>
<li><p>非阻塞式IO</p>
<ul>
<li>polling：应用程序持续轮询内核</li>
<li>无数据是返回EWOULDBLOCK错误</li>
</ul>
</li>
<li><p>IO复用</p>
<ul>
<li>阻塞在select/poll/epoll上，而不是IO系统调用</li>
</ul>
</li>
<li><p>信号驱动IO</p>
<ul>
<li>开启套接字信号驱动-&gt;安装信号处理函数-&gt;数据准备好时内核产生信号</li>
<li>IO操作由应用程序完成（内核通知数据准备好）</li>
<li>进程不受等待信号处理的影响</li>
<li>处理能力有限</li>
</ul>
</li>
<li><p>异步IO</p>
<ul>
<li>aio_传递缓冲区-&gt;IO操作完成时内核产生信号</li>
<li>IO操作由内核完成（内核通知IO完成）</li>
</ul>
</li>
</ol>
<h1 id="三、select"><a href="#三、select" class="headerlink" title="三、select"></a>三、select</h1><pre><code>#include &lt;sys/select.h&gt;
#include &lt;sys/time.h&gt;
int select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout);
成功返回就绪描述符数目，超时返回0，出错返回-1
</code></pre><ol>
<li><p>timeval</p>
<pre><code>struct timeval {
    long tv_sec;
    long tv_usec;
};
</code></pre><ul>
<li>有3种可能<ul>
<li>为NULL时永远等待(阻塞)</li>
<li>为0时不等待(轮询)</li>
<li>等待固定时间(阻塞超时)</li>
</ul>
</li>
<li>Berkeley内核绝不自动重启被中断的select</li>
<li>内核支持的真实分辨率比usec粗糙得多，多数为10ms的倍数</li>
<li>通过EINVAL表示不支持的值(超大值)</li>
<li>const表示时间值不会被修改</li>
</ul>
</li>
<li><p>文件描述符集</p>
<ul>
<li>readset、writeset、exceptset：读、写、异常</li>
<li>目前支持的异常条件只有两个：<ul>
<li>套接字带外数据到达</li>
<li>某个已置为分组模式的伪终端存在可以从其主端读取的控制状态信息（@#￥%…&amp;*~）</li>
</ul>
</li>
<li>描述符集通常是一个整数数组，每个整数的每一位对应一个描述符，元素1对应0~31,2对应32~63…</li>
<li>Poll使用可变长度的结构体数组，每个结构体代表一个描述符</li>
<li>对不感兴趣的条件设为空指针，如果三个指针都为空则是一个高精度定时器</li>
<li>maxfdp1为待测试的最大描述符+1，使得内核可以不复制描述符集中进程不需要的部分，从而避免测试总为0的那些位</li>
<li>头文件<sys select.h="">中定义的FD_SETSIZE值为fd_set中描述符的总数，通常值为1024</sys></li>
<li>fd_set的三个参数为值-结果参数，函数返回后使用FD_ISSET宏进行测试，每次重新调用select时，都要将关系的描述符重新置位</li>
<li>返回值为描述符集已就绪的总位数</li>
<li>常见的编程错误：<ul>
<li>没有对最大描述符+1</li>
<li>重复调用时，忘记对fd_set再次置位</li>
</ul>
</li>
</ul>
</li>
<li><p>描述符就绪条件</p>
<ul>
<li>套接字可读<ul>
<li>接收缓冲区数据超过低水位标记<ul>
<li>读返回大于0(数据量)</li>
<li>可以使用SO_RCVLOWAT设置低水位标记，TCP和UDP默认为1</li>
</ul>
</li>
<li>连接的读半部关闭，TCP连接收到FIN<ul>
<li>读返回0(EOF)</li>
</ul>
</li>
<li>监听套接字已完成队列大于0<ul>
<li>accept通常不阻塞</li>
</ul>
</li>
<li>套接字产生待处理错误<ul>
<li>读返回-1，设置errno</li>
<li>可以通过指定SO_ERROR套接字选项，并调用getsockopt获取并清除</li>
</ul>
</li>
</ul>
</li>
<li>套接字可写<ul>
<li>发送缓冲区数据超过低水位标记<ul>
<li>写返回大于0(数据量)</li>
<li>可以使用SO_SNDLOWAT设置低水位标记，TCP和UDP默认为2048</li>
</ul>
</li>
<li>连接的写半部关闭<ul>
<li>写收到RST响应，继续产生SIGPIPE</li>
</ul>
</li>
<li>非阻塞式connect已建立连接，或者connect失败</li>
<li>套接字产生待处理错误<ul>
<li>写返回-1，设置errno</li>
<li>可以通过指定SO_ERROR套接字选项，并调用getsockopt获取并清除 </li>
</ul>
</li>
</ul>
</li>
<li>套接字存在带外数据时，为异常</li>
<li>套接字错误时，同时可读写</li>
<li>接收发送低水位标记的目的在于，允许进程控制select返回时的缓冲区数据量</li>
<li>UDP套接字只要低水位标记小于缓冲区大小就总是可写，因为UDP不需要连接，不控制流量</li>
</ul>
</li>
</ol>
<h1 id="四、shutdown"><a href="#四、shutdown" class="headerlink" title="四、shutdown"></a>四、shutdown</h1><ol>
<li><p>close的限制</p>
<ul>
<li>引用计数-1，为0时才关闭套接字，shutdown可以直接触发TCP关闭序列</li>
<li>同时终止读写两个方向，无法保证链路徽中的数据完成传输(通常要先关闭写，再关闭读)</li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li><code>SHUT_RD</code><ul>
<li>读关闭</li>
<li>接收缓冲区数据丢弃</li>
<li>关闭后收到的对端数据都被确认，然后丢弃(RST-&gt;SIGPIPE?)</li>
</ul>
</li>
<li><code>SHUT_WR</code><ul>
<li>写关闭(半关闭)</li>
<li>发送缓冲区数据都被发送，然后终止连接</li>
</ul>
</li>
<li><code>SHUT_RDWR</code><ul>
<li>同时关闭读写</li>
<li>相当于先调用SHUT_RD，再调用SHUT_WR</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="五、拒绝服务DoS"><a href="#五、拒绝服务DoS" class="headerlink" title="五、拒绝服务DoS"></a>五、拒绝服务DoS</h1><ol>
<li>当一个服务器处理多个客户时，绝对不能阻塞于只与单个客户相关的函数调用，否则可能导致服务器挂起，拒绝为其它客户提供服务</li>
<li>可能的解决办法<ul>
<li>使用非阻塞IO</li>
<li>per client per thread</li>
<li>IO操作设置超时</li>
</ul>
</li>
</ol>
<h1 id="六、pselect"><a href="#六、pselect" class="headerlink" title="六、pselect"></a>六、pselect</h1><pre><code>#include &lt;sys/select.h&gt;
#include &lt;signal.h&gt;
#include &lt;time.h&gt;

int pselect(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timespec *timeout, const sigset_t *sigmask);
成功返回就绪描述符数目，超时返回0，出错返回-1
</code></pre><ol>
<li><p>对于select的变化</p>
<ul>
<li><p>使用timespec结构，tv_nsec为纳秒</p>
<pre><code>struct timespec {
    time_t tv_sec;
    long   tv_nsec;
}
</code></pre></li>
<li><p>增加了新参数*sigmask，指向信号掩码，调用时以原子操作安装该信号掩码，返回时恢复原来的信号屏蔽字</p>
<ul>
<li>如果该指针为空，则和select一样。</li>
<li>以允许应用程序先屏蔽信号，再测试由信号改变的全局变量，然后调用pselect并重新设置信号掩码。</li>
</ul>
</li>
</ul>
</li>
<li><p>举例</p>
<p> SIG_INT信号设置全局变量<code>intr_flag</code></p>
<ul>
<li>出现竞争条件的情况</li>
</ul>
</li>
</ol>
<pre><code>        if(select(...) &lt; 0) {
            if(error == EINTR) {
                if(intr_flag)
                    handle_intr();
            }
            ...
        }

    + 在测试intr_flag之后，下次调用select之前如果有信号发生，如果select永远阻塞，则信号可能会丢失

* 改用pselect

        sigset_t newmask, oldmask, zeromask;

        sigemptyset(&amp;zeromask);
        sigemptyset(&amp;newmask);
        sigaddset(&amp;newmask, SIGINT);

        // 阻塞SIGINT
        sigprocmask(SIG_BLOCK, &amp;newmask, &amp;oldmask);
        // 调用pselect以后不阻塞任何信号,直到返回
        if(pselect(..., &amp;zeromask) &lt; 0) { 
            if(error == EINTR) {
                if(intr_flag)
                    handle_intr();
            }
            ...
        }

    + 当pselect被调用时，先以空集zeromask替代进程的信号掩码(不阻塞任何信号，可以捕获SIGINT)，再检查描述符并可能进入睡眠。pselect返回时，进程的信号掩码又被重置为调用pselect之前的值(阻塞SIGINT)，从而避免了SIGINT信号的丢失
</code></pre><h1 id="七、poll"><a href="#七、poll" class="headerlink" title="七、poll"></a>七、poll</h1><pre><code>#include &lt;poll.h&gt;
int poll(struct poll *fdarray, unsigned long nfds, int timeout);
返回就绪描述符数目，超时返回0，出错返回-1
</code></pre><ol>
<li><p>fdarray</p>
<pre><code>struct pollfd {
    int fd;
    short events;        // interested
    short revents;        // occurred
};
</code></pre><ul>
<li>fdarray为结构体数组，events调用条件，revents返回结果，不再是值-结果参数</li>
<li><p>events</p>
<hr>
<ul>
<li>POLLIN：normal或priority band数据可读</li>
<li>POLLRDNORM：normal数据可读</li>
<li>POLLRDBAND：priority band数据可读</li>
<li>POLLPRI：high priority数据可读</li>
</ul>
<hr>
<ul>
<li>POLLOUT：normal数据可写</li>
<li>POLLWRNORM：normal数据可写</li>
<li>POLLWRBAND：优先级带数据可写</li>
</ul>
<hr>
<ul>
<li>POLLERR：发生错误，只作结果返回</li>
<li>POLLHUP：发生挂起，只作结果返回</li>
<li>POLLNVAL：描述符不是一个打开的文件，只作结果返回</li>
</ul>
</li>
<li><p>有三类数据：normal、priority band、high priority</p>
</li>
<li>有多种方法可以返回相同的条件：<ul>
<li>所有TCP和UDP正规数据为normal</li>
<li>带外数据为priority band</li>
<li>TCP连接的读半部关闭为normal</li>
<li>TCP连接的错误可以为normal，或者POLLERR，随后的读操作返回-1并设置error，可用于接收RST或发生超时</li>
<li>监听套接字上有新连接，可认为是normal或high priority</li>
<li>非阻塞式connect完成为套接字可写</li>
</ul>
</li>
</ul>
</li>
<li><p>nfds指明结构数组的元素个数</p>
</li>
<li><p>timeout为ms值</p>
<pre><code>INFTM：永远等待     
0：立即返回，非阻塞     
&gt;0：ms值
</code></pre><ul>
<li>任何timeout值都受限于时钟分辨率(通常为10ms)</li>
</ul>
</li>
<li><p>如果不再关心某个特定fd，把结构中的fd成员设置为-1</p>
</li>
</ol>
<hr>
<h1 id="高级IO"><a href="#高级IO" class="headerlink" title="高级IO"></a>高级IO</h1><hr>
<p><strong>read和write的三个变体：</strong></p>
<ul>
<li>recv和send：允许通过第四个参数向内核传递标志</li>
<li>readv和writev：允许指定往其中输入数据或从其中输出数据的缓冲区向量</li>
<li>recvmsg和sendmsg：结合IO函数的特性，并且具备收发辅助数据的能力</li>
</ul>
<h1 id="一、套接字超时"><a href="#一、套接字超时" class="headerlink" title="一、套接字超时"></a>一、套接字超时</h1><ol>
<li>设置套接字超时的方法<ul>
<li>调用alarm，超时产生SIGALARM信号<ul>
<li>不同实现可能存在差异，可能干扰进程的alarm处理</li>
<li>使用alarm设置超时总能减少connect的超时时间，但无法延长，典型的内核实现为75s</li>
<li>Alarm利用了系统调用connect的可中断能力，使得总能在内核超时前返回。这样的前提是执行的是系统调用，并且能够直接处理返回的EINTR错误</li>
</ul>
</li>
<li>select中阻塞等待IO<ul>
<li>connect用select设置超时的先决条件是套接字为非阻塞模式</li>
</ul>
</li>
<li>设置套接字的<code>SO_RCVTIMO</code>和<code>SO_SNDTIMEO</code>选项<ul>
<li>好处是对套接字只需设置一次</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="二、recv和send"><a href="#二、recv和send" class="headerlink" title="二、recv和send"></a>二、recv和send</h1><pre><code>#include &lt;sys/socket.h&gt;
ssize_t recv(int sockfd, void *buff, size_t nbytes, int flags);
ssize_t send(int sockfd, const void *buff, size_t nbytes, int flags);
</code></pre><ol>
<li>前3个参数同read/write</li>
<li><p>flags</p>
<ul>
<li><code>MSG_DONTROUTE</code><ul>
<li>告诉内核<strong>目的主机在某个直连的本地网络</strong>上，无需进行路由表查找</li>
<li>对本次操作生效，也可以设置套接字的SO_DONTROUTE标志，对套接字生效</li>
</ul>
</li>
<li><code>MSG_DONTWAIT</code><ul>
<li>本次操作非阻塞</li>
<li>也可以对套接字设置非阻塞</li>
</ul>
</li>
<li><code>MSG_OOB</code><ul>
<li>对send指明发送带外数据，TCP连接上只有一个字节可以作为带外数据发送</li>
<li>对recv指明读入为带外数据，非普通数据</li>
</ul>
</li>
<li><code>MSG_PEEK</code><ul>
<li>允许查看已可读取的数据，而且系统不在recv或recvfrom返回后丢弃这些数据</li>
</ul>
</li>
<li><code>MSG_WAITALL</code><ul>
<li>阻塞直到读取到指定数目的数据</li>
</ul>
</li>
</ul>
</li>
<li><p>flag按值传递，无法从内核传递回来，TCP/IP基本不需要，OSI的某些协议需要传递回来<code>MSG_EOR</code>标志，只能调用recvmsg</p>
</li>
</ol>
<h1 id="三、readv和writev"><a href="#三、readv和writev" class="headerlink" title="三、readv和writev"></a>三、readv和writev</h1><pre><code>#include &lt;sys/uio.h&gt;
ssize_t readv(int sockfd, const struct iovec *iov, int iovcnt);
ssize_t writev(int sockfd, const struct iovec *iov, int iovcnt);
</code></pre><ol>
<li><p>允许单个系统调用读取或者写入自一个或多个缓冲区</p>
<ul>
<li>scatter read(分散读)：来自读操作的输入数据被分散到多个应用缓冲区</li>
<li>gather write(集中写)：来自多个应用缓冲区的输出数据被集中提交给单个写操作</li>
</ul>
</li>
<li><p>iovec</p>
<p> struct iovec {</p>
<pre><code>void *iov_base;        // address
size_t iov_len;        // length
</code></pre><p> };</p>
<ul>
<li>iovec数目存在限制，POSIX在<code>&lt;sys/uio.h&gt;</code>中定义IOV_MAX值至少为16个</li>
</ul>
</li>
<li><p>可用于任何描述符</p>
</li>
<li>是原子操作<ul>
<li>对于基于记录的协议(如UDP)，一次writev调用只产生单个UDP数据报</li>
<li>可以解决多次小分组发送触发Nagle算法的问题</li>
</ul>
</li>
</ol>
<h1 id="四、recvmsg和sendmsg"><a href="#四、recvmsg和sendmsg" class="headerlink" title="四、recvmsg和sendmsg"></a>四、recvmsg和sendmsg</h1><p><strong>最通用的IO函数，可以替换所有的类似read/readv/recv/recvfrom的函数</strong></p>
<pre><code>#include &lt;sys/socket.h&gt;
ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);
ssize_t sendmsg(int sockfd, struct msghdr *msg, int flags);

struct msghdr {
    void         *msg_name；            // protocol address
    socklen_t     msg_namelen;
    struct iovec *msg_iov;            // scatter/gather array
    int            msg_iovlen;
    void        *msg_control;        // ancillary data
    socklen_t     msg_controllen;
    int            msg_flags;            // return by revcmsg
};
</code></pre><ol>
<li><p><code>msg_name</code>和<code>msg_namelen</code></p>
<ul>
<li>用于未连接套接字，类似recvfrom和sendto的from和to参数</li>
<li><code>msg_name</code>指向套接字地址结构sockaddr，存放目的地址(sendmsg)或源地址（recvmsg）</li>
<li>对于已连接套接字，<code>msg_name</code>为空</li>
<li><code>msg_len</code>对sendmsg是值参数，对recvmsg是值-结果参数</li>
</ul>
</li>
<li><p><code>msg_iov</code>和<code>msg_iovlen</code></p>
<ul>
<li>指定输入或输出缓冲区数组</li>
<li>iovec结构数组</li>
</ul>
</li>
<li><p><code>msg_control</code>和<code>msg_controllen</code></p>
<ul>
<li>指定可选辅助数据的位置和大小</li>
<li><code>msg_controllen</code>对recvmsg是值-结果参数</li>
<li>为struct cmsghdr</li>
</ul>
</li>
<li><p><code>msg_flags</code></p>
<ul>
<li>只有recvmsg使用<code>msg_flags</code>成员，sendmsg设置不起作用</li>
<li>recvmsg调用时将flags参数复制到这个成员，内核根据函数执行的结果更新<code>msg_flags</code>。即这个成员返回函数执行的结果，不用设置</li>
<li>sendmsg执行时直接使用flags参数设置的值</li>
<li>recvmsg和sendmsg都只用设置flags成员</li>
</ul>
</li>
<li><p>flags</p>
<ul>
<li><code>MSG_BCAST</code>    只recv返回，数据报是链路层广播，或其目的IP为广播地址。用于判断UDP是否发往广播地址，是比<code>IP_RECVDSTADDR</code>更好的选择</li>
<li><code>MSG_MCAST</code>    只recv返回，数据报是链路层多播</li>
<li><code>MSG_TRUNC</code>    只recv返回，数据报被截断，由于内核返回的数据报超过应用程序缓冲区大小</li>
<li><code>MSG_CTRUNC</code>    只recv返回，数据报的辅助数据被截断，由于内核返回的辅助数据超过进程事先分配的空间(<code>msg_controllen</code>)</li>
<li><code>MSG_EOR</code>        send检查，recv返回，返回数据结束的一个逻辑记录，TCP作为字节流协议，不使用这个标志</li>
<li><code>MSG_OOB</code>        send检查，recv检查并返回，不作为TCP带外数据返回，用于其它协议族</li>
<li><code>MSG_NOTIFICATION</code>    SCTP，略</li>
</ul>
</li>
<li><p>flags与send、recv</p>
<pre><code>send：send/sendto/sendmsg
recv：recv/recvfrom/recvmsg
</code></pre></li>
</ol>
<pre><code>标志                send检查        recv检查        msg_flags返回
MSG_DONTROUTE        Y        
MSG_DONTWAIT        Y            Y
MSG_PEEK                        Y
MSG_WAITALL                        Y
-----------------------------------------------------
MSG_EOR                Y                        Y
MSG_OOB                Y            Y            Y
-----------------------------------------------------
MSG_BCAST                                    Y
MSG_MCAST                                    Y
MSG_TRUNC                                    Y
MSG_CTRUNC                                    Y
MSG_NOTIFICATION                            Y
</code></pre><h1 id="五、5组IO接口的差异"><a href="#五、5组IO接口的差异" class="headerlink" title="五、5组IO接口的差异"></a>五、5组IO接口的差异</h1><pre><code>                  read    readv    recv    recvfrom    recvmsg
                  write    writev    send    sendto        sendmsg
任何描述符       Y        Y
仅套接字                         Y       Y           Y
单缓冲区         Y                 Y       Y
分散/集中读写               Y                           Y
可选标志                         Y       Y           Y
可选对端地址                             Y           Y
可选控制信息                                         Y
</code></pre><h1 id="六、辅助数据-控制信息"><a href="#六、辅助数据-控制信息" class="headerlink" title="六、辅助数据/控制信息"></a>六、辅助数据/控制信息</h1><ol>
<li><p>通过调用sendmsg/recvmsg，使用msghdr结构的msg_control和msg_controllen发送和接收</p>
<pre><code>struct cmsghdr {
    socklen_t    cmsg_len;
    int            cmsg_level;
    int            cmsg_type;
};
</code></pre><ul>
<li><p>cmsg_level、cmsg_type</p>
<pre><code>协议       cmsg_level       cmsg_type       用途
IPv4    IPPROTO_IP        IP_RECVDSTADDR    随UDP数据报接收的目的地址
                        IP_RECVIF        随UDP数据报接收的接口索引
--------------------------------------------------------------
IPv6    IPPROTO_IPV6    IPV6_DSTOPTS    指定/接收目的地选项
                        IPV6_HOPLIMIT    指定/接收跳限
                        IPV6_HOPOPTS    指定/接收步跳选项
                        IPV6_NEXTHOP    指定下一跳地址
                        IPV6_PKTINFO    指定/接收分组信息
                        IPV6_PTHDR        指定/接收路由首部
                        IPV6_TCLASS        指定/接收分组流通类别
---------------------------------------------------------------
Unix    SOL_SOCKET        SCM_RIGHTS        发送/接收描述符
                        SCM_CREDS        发送/接收用户凭证
</code></pre></li>
<li><p>由msg_control指向的辅助数据可含有任意数目的辅助数据对象，这些对象必须为cmsghdr结构适当对齐</p>
<pre><code>| cmsg_len | cmsg_level | cmsg_type | dummy | data | dummy |  cmsg_len | cmsg_level | cmsg_type | dummy | data |
| &lt;-            cmsghdr          -&gt; |                      | &lt;-            cmsghdr          -&gt; |
| &lt;--           cmsg_len/CMSG_LEN()            --&gt; |       | &lt;--           cmsg_len/CMSG_LEN()             --&gt; |
| &lt;---                                            msg_controllen                                              ---&gt; |
</code></pre><ul>
<li>辅助数据总长度由<code>msg_controllen</code>指定，<code>msg_control</code>指向第一个辅助数据对象</li>
<li>每个对象开头是一个描述对象的cmsghdr结构，这个结构和实际数据之间可以有填充数据</li>
<li>每个对象之间可以有填充数据</li>
</ul>
</li>
<li><p>简化辅助数据处理的宏</p>
<pre><code>#include &lt;sys/socket.h&gt;
#include &lt;sys/param.h&gt;
struct cmsghdr *CMSG_FIRSTHDR(struct msghdr *mhdrptr)
        // 返回指向第一个cmsghdr对象的指针，无辅助数据返回NULL(也可能是cmsg_len小于一个cmsghdr大小)
struct cmsghdr *CMSG_NEXTHDR(struct msghdr *mhdrptr, struct cmsghdr *cmsgptr);
        // 返回指向下一个cmsghdr对象的指针，不在有辅助数据时返回NULL
unsigned char *CMSG_DATA(struct cmsghdr *cmsgptr);
        // 返回指向cmsghdr对象的数据的地址
unsighed int CMSG_LEN(unsigned int length);
        // 返回给定数据量下存放到cmsg_len中的值(不计对象后面的填充数据)
unsighed int CMSG_SPACE(unsigned int length);
        // 返回给定数据量下一个辅助数据对象的总大小(包含对象后面的填充数据)

struct msghdr msg;
struct cmsghdr *cmsgptr;

for(cmsgptr = CMSG_FIRSTHDR(&amp;msg); cmsgptr != NULL; cmsgptr = CMSG_NXTHDR(&amp;msg, cmgptr)) {
    if(cmsgprt-&gt;cmsg_level = IPPROTO_IP &amp;&amp; cmsgptr-&gt;type = IP_RECVDSTADDR) {
        u_char *ptr;                
        ptr = CMSG_DATA(cmsgptr);
        ...
    }
}
</code></pre><ul>
<li>CMSG_LEN 不包含数据对象后的填充数据，即cmsg_len成员的值</li>
<li>CMSG_SPACE 包括Data后面的填充字节，所以是数据对象动态分配的空间大小</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="七、排队的数据量"><a href="#七、排队的数据量" class="headerlink" title="七、排队的数据量"></a>七、排队的数据量</h1><p><strong>不真正读取数据的情况下，了解套接字上排队等待读取的数据：</strong></p>
<ol>
<li>想避免读操作阻塞在内核中<ul>
<li>可以使用非阻塞式IO</li>
</ul>
</li>
<li>即想查看数据，又想数据保留在接受队列以后读取<ul>
<li>使用MSG_PEEK标志 </li>
<li>结合非阻塞IO使用该标志</li>
<li>结合使用<code>MSG_PEEK</code>和<code>MSG_DONTWAIT</code></li>
<li>两次调用接收<ul>
<li>对于tcp，中间有收到数据，则数据量可能发生变化</li>
<li>对于udp，即使调用间有新数据加入队列，返回结果也一样(?)</li>
</ul>
</li>
</ul>
</li>
<li>也可以通过ioctl的FIONREAD参数，返回套接字已排队字节的总合</li>
</ol>
<h1 id="八、套接字和标准IO"><a href="#八、套接字和标准IO" class="headerlink" title="八、套接字和标准IO"></a>八、套接字和标准IO</h1><p><strong>使用标准IO库要考虑流的缓冲处理</strong></p>
<ol>
<li>通过fdopen创建一个标准IO流，不能直接用select，要通过fileno()转换成对应的描述符</li>
<li>TCP/UDP和IO流都是全双工的，存在如下问题：<ul>
<li>在输出函数后要插入fflush/fseek/fsetpos/rewind，才能接着调用一个输入函数</li>
<li>类似的，调用一个输入函数后也必需插入一个fflush/fseek/fsetpos/rewind，才能接着调用输出，除非输入遇到EOF</li>
<li>但fseek/fsetpos/rewind内部都会调用lseek，而lseek无法用在套接字上</li>
<li>解决办法是为一个套接字打开两个标准IO流，一个读一个写</li>
</ul>
</li>
<li>标准IO的缓冲策略<ul>
<li>完全缓冲：缓冲区满、fflush、进程exit，才进行IO</li>
<li>行缓冲：遇到换行、fflush、进程exit，才进行IO</li>
<li>不缓冲：每次调用标准输出都发生IO</li>
<li>标准缓冲大小一般为8KB</li>
<li>对设备的策略：<ul>
<li>标准错误不缓冲</li>
<li>标准输入输出行缓冲，做终端时行缓冲</li>
<li>其它IO完全缓冲，做终端时行缓冲</li>
</ul>
</li>
<li>最好彻底避免在套接字上使用标准IO</li>
</ul>
</li>
</ol>
<h1 id="九、高级轮询"><a href="#九、高级轮询" class="headerlink" title="九、高级轮询"></a>九、高级轮询</h1><ol>
<li><p>select和poll的问题:</p>
<ul>
<li>内核采用轮询，大量并发的情况下效率低下（如Apache）</li>
<li>每次调用都要向内核文件描述符</li>
</ul>
</li>
<li><p>/dev/poll</p>
<ul>
<li><p>通过pollfd结构初始化描述符表，再write到/dev/poll设备上</p>
<pre><code>struct pollfd {
    int fd;
    short events;        // interested
    short revents;        // occurred
};
</code></pre></li>
<li><p>然后执行ioctl的DP_POLL命令，传递dvpoll结构，等待事件触发</p>
<pre><code>struct dvpoll {
    struct pollfd *dp_fds;
    int              dp_nfds;        // size of pollfd
    int              dp_timeout;    // ms, 0: nonblocked, -1: always blocked
}
</code></pre></li>
<li><p>栗子略，没有解决问题1，能否并发使用？</p>
</li>
</ul>
</li>
</ol>
<h1 id="十、kqueue"><a href="#十、kqueue" class="headerlink" title="十、kqueue"></a>十、kqueue</h1><p><strong>FreeBSD实现，类似epoll(略)</strong></p>
<hr>
<h1 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h1><hr>
<h1 id="一、套接字调用的阻塞与非阻塞"><a href="#一、套接字调用的阻塞与非阻塞" class="headerlink" title="一、套接字调用的阻塞与非阻塞"></a>一、套接字调用的阻塞与非阻塞</h1><p><strong>可阻塞的套接字调用分为4类：</strong></p>
<ol>
<li><p>输入操作-read/readv/recv/recvfrom/recvmsg</p>
<ul>
<li><p>TCP</p>
<ul>
<li>阻塞：<ul>
<li>接收缓冲区为空时睡眠</li>
<li>有数据到达时(单个字节或者完整TCP分节)唤醒</li>
<li>如果要等到固定数目的数据，可以调用readn或者设置MSG_WAITALL标志</li>
</ul>
</li>
<li>非阻塞：<ul>
<li>至少有一个字节的数据可读为成功</li>
<li>否则返回EWOULDBLOCK</li>
</ul>
</li>
</ul>
</li>
<li><p>UDP</p>
<ul>
<li>阻塞：<ul>
<li>接收缓冲区为空时睡眠</li>
<li>有UDP数据到达时唤醒</li>
</ul>
</li>
<li>非阻塞：<ul>
<li>UDP至少有一个完整数据报可读为成功</li>
<li>否则返回EWOULDBLOCK</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>输出操作-write/writev/send/sendto/sendmsg</p>
<ul>
<li>TCP<ul>
<li>阻塞：<ul>
<li>TCP套接字发送缓冲区没有空间时睡眠</li>
</ul>
</li>
<li>非阻塞：<ul>
<li>发送缓冲区有空间时，返回内核能复制到缓冲区的字节数(short cut 不足计数)</li>
<li>没有空间立即返回EWOULDBLOCK</li>
</ul>
</li>
</ul>
</li>
<li>UDP<ul>
<li>不存在真正的发送缓冲区，内核只复制应用数据并沿协议栈向下传递加上协议栈首部</li>
<li>对于阻塞套接字，也不会因为缓冲区阻塞，而是别的情况</li>
</ul>
</li>
</ul>
</li>
<li><p>接入连接-accept</p>
<ul>
<li>阻塞：无新连接到达</li>
<li>非阻塞：无新连接到达时返回EWOULDBLOCK</li>
</ul>
</li>
<li><p>发起连接-connect</p>
<ul>
<li>阻塞：<ul>
<li>收到对自己发起的SYN的ACK为止</li>
<li>总会阻塞至少一个到服务器的RTT时间</li>
</ul>
</li>
<li>非阻塞：<ul>
<li>连接不能立即建立时返回EIOPROGRESS</li>
<li>可能立即建立连接</li>
</ul>
</li>
</ul>
</li>
<li><p>结论：</p>
<ul>
<li>非阻塞IO效率更高<ul>
<li>动态性优势：只要IO操作有可能发生，就总能执行相应的操作</li>
</ul>
</li>
<li>通过select判断描述符何时可读写，通过非阻塞IO来执行读写操作</li>
<li>非阻塞版本会带来代码复杂度，通常使用并发技术(多进程/多线程)可以在不增加复杂度的情况下，提高效率，以代替非阻塞<ul>
<li>客户端向服务端复制2000行文本，RTT175ms<ul>
<li>阻塞等待版本：  354s</li>
<li>select版本：   12.3s</li>
<li>非阻塞IO：      6.9s</li>
<li>fork版本：      8.7s</li>
<li>多线程版本：     8.5s</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="二、非阻塞connect"><a href="#二、非阻塞connect" class="headerlink" title="二、非阻塞connect"></a>二、非阻塞connect</h1><ol>
<li><p>非阻塞connect主要有几个用途：</p>
<ul>
<li>不阻塞在三次握手上，可以并发进行别的操作</li>
<li>同时建立多个连接</li>
<li>缩短connect的超时时间</li>
</ul>
</li>
<li><p>需要处理的问题：</p>
<ul>
<li>连接立刻建立的情况<ul>
<li>通常立刻返回EINPROGRESS，表示三次握手进行中，调用select等待结果</li>
<li>如果连接建立很快，如在本地网络中，connect可能返回成功，</li>
</ul>
</li>
<li>select返回条件：<ul>
<li>连接成功建立时，描述符变为可写</li>
<li>连接建立出错时，描述可读可写</li>
</ul>
</li>
</ul>
</li>
<li><p>先connect，</p>
<ul>
<li>成功-&gt;连接建立，</li>
<li>失败<ul>
<li>EINPROGRESS：连接建立中，调用select等待三次握手的结果</li>
<li>其它错误：无法建立连接</li>
</ul>
</li>
</ul>
</li>
<li><p>判断select返回connect成功的方法</p>
<ul>
<li>调用getpeername，<ul>
<li>connect失败：返回ENOTCONN，接着以SO_ERROR调用getsockopt获取套接字错误</li>
<li>connect成功：返回成功和对端地址、端口</li>
</ul>
</li>
<li>以0为长度调用read<ul>
<li>connect失败：返回失败，此时errno说明了失败原因</li>
<li>connect成功：返回0</li>
</ul>
</li>
<li>再次调用connect<ul>
<li>connect成功：返回EISCONN错误</li>
</ul>
</li>
</ul>
</li>
<li><p>阻塞的connect被中断</p>
<ul>
<li>如果中断的connect不会被内核自动重启，会返回EINTR</li>
<li>如果再次调用connect会返回EADDRINUSE错误</li>
<li>两个方法：    <ul>
<li>调用select，获取连接建立的状态</li>
<li>close以后重新建立socket再connect</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="三、非阻塞accept"><a href="#三、非阻塞accept" class="headerlink" title="三、非阻塞accept"></a>三、非阻塞accept</h1><ol>
<li>不用把监听套接字设为非阻塞，select可以通知连接就绪</li>
<li>select-&gt;accept调用会产生连接终止问题：<ul>
<li>客户端正常建立连接，select返回</li>
<li>在accept处理之前，客户端断开了连接<ul>
<li>客户端设置SO_LINGER，l_onoff=1 l_linger=0，导致马上发送RST到服务端终止连接</li>
</ul>
</li>
<li>此时监听套接字上的连接队列已经清除，accept调用阻塞</li>
</ul>
</li>
<li>解决办法<ul>
<li>select返回监听套接字前，设置其为非阻塞</li>
<li>后续的accept处理如下错误：<ul>
<li>EWOULDBLOCK：Berkeley实现，客户端终止连接时</li>
<li>ECONNABOUTED：POSIX实现，客户端终止连接时</li>
<li>EPROTO：SVR4实现</li>
<li>EINTR：捕获信号</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h1 id="ioctl操作"><a href="#ioctl操作" class="headerlink" title="ioctl操作"></a>ioctl操作</h1><hr>
<p><strong>网络程序经常在启动后使用ioctl获取主机的接口信息，包括接口地址、是否支持广播/多播等</strong></p>
<h1 id="一、ioctl函数"><a href="#一、ioctl函数" class="headerlink" title="一、ioctl函数"></a>一、ioctl函数</h1><pre><code>#include &lt;unistd.h&gt;
int ioctl(int fd, int request, .../* void arg */);
成功返回 0，出错返回-1
</code></pre><ul>
<li>网络请求的操作类别<ul>
<li>套接字操作</li>
<li>文件操作</li>
<li>接口操作</li>
<li>ARP高速缓存操作</li>
<li>路由表操作</li>
<li>流系统</li>
</ul>
</li>
</ul>
<h1 id="二、套接字操作"><a href="#二、套接字操作" class="headerlink" title="二、套接字操作"></a>二、套接字操作</h1><ul>
<li>SIOCATMARK<ul>
<li>读指针位于带外标记时，第三个参数返回非0值，否则返回0值</li>
</ul>
</li>
<li>SIOCGPGRP<ul>
<li>获取套接字的pid和gpid，该进程接收套接字的SIGIO或SIGURG信号，与fcntl的<code>F_GETOWN</code>命令等效</li>
</ul>
</li>
<li>SIOCSPGRP<ul>
<li>设置套接字的pid和gpid，可用于接收套接字的SIGIO或SIGURG信号，与fcntl的<code>F_SETOWN</code>命令等效</li>
</ul>
</li>
</ul>
<h1 id="三、文件操作"><a href="#三、文件操作" class="headerlink" title="三、文件操作"></a>三、文件操作</h1><ul>
<li>FIONBIO<ul>
<li>清除或设置套接字的非阻塞IO标志，与<code>O_NONBLOCK</code>文件状态标志等效，可以通过fcntl的<code>F_SETFL</code>命令设置或清除</li>
</ul>
</li>
<li>FIOASYNC<ul>
<li>清除或设置套接字的信号驱动异步IO标志，与<code>O_ASYNC</code>等效，可以通过fcntl的<code>F_SETFL</code>命令设置或清除</li>
</ul>
</li>
<li>FIONREAD<ul>
<li>返回套接字接受缓冲区当前的字节数</li>
</ul>
</li>
<li>F_SETOWN<ul>
<li>与SIOCSPGRP等效</li>
</ul>
</li>
<li>F_GETOWN<ul>
<li>与SIOCGPGRP等效</li>
</ul>
</li>
</ul>
<h1 id="四、接口配置"><a href="#四、接口配置" class="headerlink" title="四、接口配置"></a>四、接口配置</h1><ol>
<li>从内核获取系统的接口配置</li>
<li>由SIOCGIFCONF请求完成</li>
<li><p>使用ifconf结构，内部使用ifreq结构</p>
<ul>
<li><p>内核定义</p>
<pre><code>/*
 * Interface request structure used for socket
 * ioctl&apos;s.  All interface ioctl&apos;s must have parameter
 * definitions which begin with ifr_name.  The
 * remainder may be interface specific.
 */

struct ifreq {
#define IFHWADDRLEN    6
    union
    {
        char    ifrn_name[IFNAMSIZ];        /* if name, e.g. &quot;en0&quot; */
    } ifr_ifrn;

    union {
        struct    sockaddr ifru_addr;
        struct    sockaddr ifru_dstaddr;
        struct    sockaddr ifru_broadaddr;
        struct    sockaddr ifru_netmask;
        struct  sockaddr ifru_hwaddr;
        short    ifru_flags;
        int    ifru_ivalue;
        int    ifru_mtu;
        struct  ifmap ifru_map;
        char    ifru_slave[IFNAMSIZ];    /* Just fits the size */
        char    ifru_newname[IFNAMSIZ];
        void __user *    ifru_data;
        struct    if_settings ifru_settings;
    } ifr_ifru;
};

#define ifr_name    ifr_ifrn.ifrn_name    /* interface name     */
#define ifr_hwaddr    ifr_ifru.ifru_hwaddr    /* MAC address         */
#define    ifr_addr    ifr_ifru.ifru_addr    /* address        */
#define    ifr_dstaddr    ifr_ifru.ifru_dstaddr    /* other end of p-p lnk    */
#define    ifr_broadaddr    ifr_ifru.ifru_broadaddr    /* broadcast address    */
#define    ifr_netmask    ifr_ifru.ifru_netmask    /* interface net mask    */
#define    ifr_flags    ifr_ifru.ifru_flags    /* flags        */
#define    ifr_metric    ifr_ifru.ifru_ivalue    /* metric        */
#define    ifr_mtu        ifr_ifru.ifru_mtu    /* mtu            */
#define ifr_map        ifr_ifru.ifru_map    /* device map        */
#define ifr_slave    ifr_ifru.ifru_slave    /* slave device        */
#define    ifr_data    ifr_ifru.ifru_data    /* for use by interface    */
#define ifr_ifindex    ifr_ifru.ifru_ivalue    /* interface index    */
#define ifr_bandwidth    ifr_ifru.ifru_ivalue    /* link bandwidth    */
#define ifr_qlen    ifr_ifru.ifru_ivalue    /* Queue length     */
#define ifr_newname    ifr_ifru.ifru_newname    /* New name        */
#define ifr_settings    ifr_ifru.ifru_settings    /* Device/proto settings*/

/*
 * Structure used in SIOCGIFCONF request.
 * Used to retrieve interface configuration
 * for machine (useful for programs which
 * must know all networks accessible).
 */

struct ifconf  {
    int    ifc_len;            /* size of buffer    */
    union {
        char __user *ifcu_buf;
        struct ifreq __user *ifcu_req;
    } ifc_ifcu;
};
#define    ifc_buf    ifc_ifcu.ifcu_buf        /* buffer address    */
#define    ifc_req    ifc_ifcu.ifcu_req        /* array of structures    */
</code></pre></li>
<li><p>使用(getSystemParameters.cpp)</p>
</li>
</ul>
</li>
<li><p>注意ifreq的<code>ifru_addr</code>成员使用IPv4的sockaddr结构定义,大小为16字节，对于IPv6的<code>sockaddr_in6</code>可能造成问题(24字节)</p>
</li>
<li>如果当前的<code>ifr_addr.sa_family</code>支持广播(<code>IFF_BROADCAST</code>)，可以调用ioctl的SIOCGIFBRDADDR获得广播地址</li>
<li>如果当前的<code>ifr_addr.sa_family</code>支持点对点接口(<code>IFF_POINTOPOINT</code>)，可以调用ioctl的SIOCGIFDSTADDR获得对端地址</li>
</ol>
<h1 id="五、接口操作"><a href="#五、接口操作" class="headerlink" title="五、接口操作"></a>五、接口操作</h1><ol>
<li>SIOCGIIFCONF请求用于返回所有的接口名以及套接字地址结构</li>
<li>接口总是以名称标识，获取到<code>ifr_name</code>后，可以在ifreq结构中指定然后继续查询其它信息</li>
<li>get版本通常由netstat查询，set版本通常有ifconfig调用</li>
<li>命令<ul>
<li>SIOCGIFADDR/SIOCSIFADDR<ul>
<li>获取/设置接口地址，通过<code>ifr_addr</code>成员</li>
</ul>
</li>
<li>SIOCGIFFLAGS/SIOCSIFFLAGS<ul>
<li>获取/设置接口标识，通过<code>ifr_flags</code>成员</li>
<li>接口标识定义在<code>&lt;net/if.h&gt;</code>中</li>
<li>标识是否出于工作状态(<code>IFF_UP</code>)、是否为点到点接口(<code>IFF_POINTOPOINT</code>)、是否支持广播(<code>IFF_BROADCAST</code>)等</li>
</ul>
</li>
<li>SIOCGIFDSTADDR/SIOCSIFDSTADDR<ul>
<li>获取/设置点到点地址，通过ifr_dstaddr成员</li>
</ul>
</li>
<li>SIOCGIFBRDADDR/SIOCSIFBRDADDR<ul>
<li>获取/设置广播地址，通过ifr_broadaddr成员</li>
</ul>
</li>
<li>SIOCGIFNETMASK/SIOCSIFNETMASK<ul>
<li>获取/设置子网掩码，通过ifr_addr成员</li>
</ul>
</li>
<li>SIOCGIFMETRIC/SIOCSIFMETRIC<ul>
<li>获取/设置路由测度，通过ifr_metric成员</li>
<li>接口测度由内核为每个接口维护</li>
<li>路由守护进程routed使用，被加到跳数上</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="六、ARP高速缓存"><a href="#六、ARP高速缓存" class="headerlink" title="六、ARP高速缓存"></a>六、ARP高速缓存</h1><ol>
<li>通常由路由套接字操作</li>
<li><p>第三个参数指向arpreq结构，定义在头文件<code>&lt;net/if_arp.h&gt;</code>中</p>
<pre><code>/* ARP ioctl request. */
struct arpreq {
  struct sockaddr    arp_pa;        /* protocol address        */
  struct sockaddr    arp_ha;        /* hardware address        */
  int            arp_flags;    /* flags            */
  struct sockaddr       arp_netmask;    /* netmask (only for proxy arps) */
  char            arp_dev[16];
};

struct arpreq_old {
  struct sockaddr    arp_pa;        /* protocol address        */
  struct sockaddr    arp_ha;        /* hardware address        */
  int            arp_flags;    /* flags            */
  struct sockaddr       arp_netmask;    /* netmask (only for proxy arps) */
};

/* ARP Flag values. */
#define ATF_COM        0x02        /* completed entry (ha valid)    */
#define    ATF_PERM    0x04        /* permanent entry        */
#define    ATF_PUBL    0x08        /* publish entry        */
#define    ATF_USETRAILERS    0x10        /* has requested trailers    */
#define ATF_NETMASK     0x20            /* want to use a netmask (only for proxy entries) */
</code></pre></li>
<li><p>命令</p>
<ul>
<li>SIOCSARP<ul>
<li>添加或修改ARP高速缓存的表项</li>
<li><code>arp_pa</code>是包含IP的网际套接字地址结构(IPv4/6)</li>
<li><code>arp_ha</code>是通用套接字地址结构，<code>sa_family</code>为<code>AF_UNSEPC</code>，<code>sa_data</code>含硬件地址</li>
<li><code>ATF_PERM</code>和<code>ATF_PUBL</code>可以用户指定，ATF_COM由内核设置</li>
</ul>
</li>
<li>SIOCDARP<ul>
<li>删除表项</li>
<li>需指定表项的网际网络地址</li>
</ul>
</li>
<li>SIOGARP<ul>
<li>获取表项</li>
<li>指定网际地址，返回硬件地址和标志</li>
</ul>
</li>
</ul>
</li>
<li><p>只有超级用户才能添加删除表项，通常arp程序会使用</p>
</li>
<li>ioctl没法列出ARP高速缓存的所有表项，arp -a命令通过读取内核内存/dev/kmem获取，可以通过sysctl来完成</li>
</ol>
<h1 id="七、路由表操作"><a href="#七、路由表操作" class="headerlink" title="七、路由表操作"></a>七、路由表操作</h1><ol>
<li>通常由路由套接字操作，第三个参数为指向rtentry的指针</li>
<li>第三个参数指向arpreq结构，定义在头文件<code>&lt;net/route.h&gt;</code>中</li>
<li>命令<ul>
<li>SIOADDRT/SIODELRT<ul>
<li>添加删除表项</li>
</ul>
</li>
</ul>
</li>
<li>与arp一样，只有超级用户才能添加删除表项，通常route程序会使用</li>
<li>ioctl没法列出路由表的所有表项，netstat -r命令通过读取内核内存/dev/kmem获取，可以通过sysctl来完成</li>
</ol>
<hr>
<h1 id="信号驱动IO"><a href="#信号驱动IO" class="headerlink" title="信号驱动IO"></a>信号驱动IO</h1><hr>
<p><strong>信号驱动IO不是真正的异步IO，因为IO不是由内核完成</strong></p>
<h1 id="一、设置套接字的信号驱动IO"><a href="#一、设置套接字的信号驱动IO" class="headerlink" title="一、设置套接字的信号驱动IO"></a>一、设置套接字的信号驱动IO</h1><ol>
<li>设置<ul>
<li>建立SIGIO的信号处理函数</li>
<li>设置套接字属主<ul>
<li>通常使用fcntl的<code>F_SETOWN</code>设置        </li>
</ul>
</li>
<li>开启信号驱动IO<ul>
<li>通常使用fcntl的<code>F_SETFL</code>命令打开<code>O_ASYNC</code>标志</li>
<li>也可以ioctl的FIOASYNC</li>
</ul>
</li>
</ul>
</li>
<li>建立SIGIO处理函数与设置套接字属主的顺序无关影响，因为SIGIO信号默认处理是忽略，所以即使先设置属主以后立即产生了该信号，也只是丢失</li>
</ol>
<h1 id="二、信号产生条件"><a href="#二、信号产生条件" class="headerlink" title="二、信号产生条件"></a>二、信号产生条件</h1><ol>
<li>对UDP<ul>
<li>数据报到达</li>
<li>套接字产生异步错误(条件是UDP套接字已连接)</li>
</ul>
</li>
<li><p>对TCP</p>
<ul>
<li>由于信号产生的过于频繁，且不能说明产生条件，对TCP用处不大</li>
<li>产生条件<ul>
<li>监听套接字上的请求已完成</li>
<li>断开连接发起</li>
<li>断开连接完成</li>
<li>半连接关闭</li>
<li>数据报到达</li>
<li>数据报已发送(输出缓冲区有空闲)</li>
<li>发生异步错误</li>
</ul>
</li>
<li>异步信号如果用于TCP读写，需要设置成非阻塞，因为无法区分信号产生时是有数据到达还是数据被确认</li>
<li>应考虑只对监听套接字设置信号驱动，因为产生信号的唯一条件是新连接已完成</li>
<li>基于UDP的NTP服务器用于给客户端提供精准的时间戳<ul>
<li>新数据报到达时，SIGIO处理函数读入数据，记录到达时刻，然后转移到队列里进行处理</li>
</ul>
</li>
</ul>
</li>
<li><p>sigsuspend</p>
<ul>
<li>用于解除信号阻塞，进程休眠等待信号发生</li>
<li>在进程获取一个信号并执行处理函数返回后才返回</li>
<li>总是返回EINTR错误</li>
<li>先保存当前的信号掩码，再将掩码置为输入的参数，返回前将掩码恢复为调用前的值</li>
</ul>
</li>
<li><p>由于POSIX信号不排队，通常开启信号驱动IO时将描述符设置为非阻塞，处理信号时，在循环中执行读操作，直到返回EWOULDBLOCK为止</p>
</li>
</ol>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2016/05/28/Linux网络编程-四、高级IO/" data-id="ciq86vj6b00531x63xzibwhey" class="article-share-link">分享到</a><div class="tags"><a href="/tags/Linux网络编程/">Linux网络编程</a></div><div class="post-nav"><a href="/2016/05/28/Sip协议-Sip通讯过程初步分析/" class="pre">Sip通讯过程初步分析</a><a href="/2016/05/28/Linux网络编程-六、IP基础编程/" class="next">六、IP基础编程</a></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C-C-经验累积/">C&C++经验累积</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Docker学习/">Docker学习</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux使用/">Linux使用</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux系统编程/">Linux系统编程</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux网络编程/">Linux网络编程</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Q-A/">Q&A</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Sip协议/">Sip协议</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux内核驱动与文件系统/">linux内核驱动与文件系统</a><span class="category-list-count">23</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/project-note/">project_note</a><span class="category-list-count">13</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/project-note/decode/">decode</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/project-note/think-about/">think_about</a><span class="category-list-count">4</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/开发环境搭建/">开发环境搭建</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂项/">杂项</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/">阅读笔记</a><span class="category-list-count">255</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/C-11新特性/">C++11新特性</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/C-Templates/">C++Templates</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/C程序设计语言/">C程序设计语言</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/EffectiveC/">EffectiveC++</a><span class="category-list-count">50</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/EffectiveSTL/">EffectiveSTL</a><span class="category-list-count">51</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/InsideC-ObjectModel/">InsideC++ObjectModel</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/Linux多线程服务器编程/">Linux多线程服务器编程</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/Linux性能优化大师/">Linux性能优化大师</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/Linux设备驱动程序/">Linux设备驱动程序</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/MoreEffectiveC/">MoreEffectiveC++</a><span class="category-list-count">26</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/TCPIP详解Vol1/">TCPIP详解Vol1</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/TheC-StandardLibraryEd1/">TheC++StandardLibraryEd1</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/TheC-StandardLibraryEd2/">TheC++StandardLibraryEd2</a><span class="category-list-count">23</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/http权威指南/">http权威指南</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/unix网络编程Ed3/">unix网络编程Ed3</a><span class="category-list-count">28</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/wireshark数据包分析实战/">wireshark数据包分析实战</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/实战LinuxShell编程与服务器管理/">实战LinuxShell编程与服务器管理</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/程序员的自我修养/">程序员的自我修养</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/网络安全基础/">网络安全基础</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/面向模式的软件体系结构Vol1/">面向模式的软件体系结构Vol1</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/高级C-C-编译技术/">高级C&C++编译技术</a><span class="category-list-count">2</span></li></ul></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Linux性能优化大师/" style="font-size: 15px;">Linux性能优化大师</a> <a href="/tags/Docker学习/" style="font-size: 15px;">Docker学习</a> <a href="/tags/Linux使用/" style="font-size: 15px;">Linux使用</a> <a href="/tags/Linux系统编程/" style="font-size: 15px;">Linux系统编程</a> <a href="/tags/Q-A/" style="font-size: 15px;">Q&A</a> <a href="/tags/Linux网络编程/" style="font-size: 15px;">Linux网络编程</a> <a href="/tags/Sip协议/" style="font-size: 15px;">Sip协议</a> <a href="/tags/开发环境搭建/" style="font-size: 15px;">开发环境搭建</a> <a href="/tags/linux内核驱动与文件系统/" style="font-size: 15px;">linux内核驱动与文件系统</a> <a href="/tags/杂项/" style="font-size: 15px;">杂项</a> <a href="/tags/阅读笔记/" style="font-size: 15px;">阅读笔记</a> <a href="/tags/decode/" style="font-size: 15px;">decode</a> <a href="/tags/think-about/" style="font-size: 15px;">think_about</a> <a href="/tags/C程序设计语言/" style="font-size: 15px;">C程序设计语言</a> <a href="/tags/C-11新特性/" style="font-size: 15px;">C++11新特性</a> <a href="/tags/C-Templates/" style="font-size: 15px;">C++Templates</a> <a href="/tags/InsideC-ObjectModel/" style="font-size: 15px;">InsideC++ObjectModel</a> <a href="/tags/C-C-经验累积/" style="font-size: 15px;">C&C++经验累积</a> <a href="/tags/Linux多线程服务器编程/" style="font-size: 15px;">Linux多线程服务器编程</a> <a href="/tags/EffectiveC/" style="font-size: 15px;">EffectiveC++</a> <a href="/tags/TCPIP详解Vol1/" style="font-size: 15px;">TCPIP详解Vol1</a> <a href="/tags/EffectiveSTL/" style="font-size: 15px;">EffectiveSTL</a> <a href="/tags/Linux设备驱动程序/" style="font-size: 15px;">Linux设备驱动程序</a> <a href="/tags/http权威指南/" style="font-size: 15px;">http权威指南</a> <a href="/tags/TheC-StandardLibraryEd2/" style="font-size: 15px;">TheC++StandardLibraryEd2</a> <a href="/tags/unix网络编程Ed3/" style="font-size: 15px;">unix网络编程Ed3</a> <a href="/tags/TheC-StandardLibraryEd1/" style="font-size: 15px;">TheC++StandardLibraryEd1</a> <a href="/tags/MoreEffectiveC/" style="font-size: 15px;">MoreEffectiveC++</a> <a href="/tags/wireshark数据包分析实战/" style="font-size: 15px;">wireshark数据包分析实战</a> <a href="/tags/实战LinuxShell编程与服务器管理/" style="font-size: 15px;">实战LinuxShell编程与服务器管理</a> <a href="/tags/网络安全基础/" style="font-size: 15px;">网络安全基础</a> <a href="/tags/程序员的自我修养/" style="font-size: 15px;">程序员的自我修养</a> <a href="/tags/高级C-C-编译技术/" style="font-size: 15px;">高级C&C++编译技术</a> <a href="/tags/面向模式的软件体系结构Vol1/" style="font-size: 15px;">面向模式的软件体系结构Vol1</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/07/04/开发环境搭建-ubuntu-server15-10安装systemtap/">ubuntu_server15.10安装systemtap</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/03/开发环境搭建-扩展虚拟机硬盘容量/">扩展虚拟机硬盘容量</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/03/阅读笔记-Linux多线程服务器编程-第十一章-反思C-对象与虚函数/">第十一章 反思C++对象与虚函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/23/阅读笔记-Linux多线程服务器编程-第十章-补充：ODR原则/">第十章 补充：ODR原则</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/21/阅读笔记-Linux多线程服务器编程-第十章-C-编译链接模型精要/">第十章 C++编译链接模型精要</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/17/阅读笔记-Linux多线程服务器编程-第九章-分布式工程实践/">第九章 分布式工程实践</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/16/开发环境搭建-kali-linux-VM版设置/">kali linux VM版设置</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/16/阅读笔记-Linux多线程服务器编程-第五章-高效的多线程日志/">第五章 高效的多线程日志</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/08/阅读笔记-Linux多线程服务器编程-第四章-补充：POD类型/">第四章 补充：POD类型</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/06/阅读笔记-Linux多线程服务器编程-第四章-C-多线程系统编程精要/">第四章 C++多线程系统编程精要</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://easy.ac.cn/" title="easy" target="_blank">easy</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">dupengair的blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>