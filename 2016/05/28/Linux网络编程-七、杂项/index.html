<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="keep it simple, stupid"><title>七、杂项 | dupengair的blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/3.0.3/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">七、杂项</h1><a id="logo" href="/.">dupengair的blog</a><p class="description">日拱一卒 精而悟道</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">七、杂项</h1><div class="post-meta">May 28, 2016<span> | </span><span class="category"><a href="/categories/Linux网络编程/">Linux网络编程</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#IPv4与v6互操作性"><span class="toc-number">1.</span> <span class="toc-text">IPv4与v6互操作性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#一、IPv4客户端与IPv6服务器"><span class="toc-number">2.</span> <span class="toc-text">一、IPv4客户端与IPv6服务器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、IPv6客户端与IPv4服务器"><span class="toc-number">3.</span> <span class="toc-text">二、IPv6客户端与IPv4服务器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、地址测试宏"><span class="toc-number">4.</span> <span class="toc-text">三、地址测试宏</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#带外数据"><span class="toc-number">5.</span> <span class="toc-text">带外数据</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#一、带外数据-out-of-band-data"><span class="toc-number">6.</span> <span class="toc-text">一、带外数据(out-of-band data)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、TCP的带外数据"><span class="toc-number">7.</span> <span class="toc-text">二、TCP的带外数据</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、带外标记-out-of-band-mark"><span class="toc-number">8.</span> <span class="toc-text">三、带外标记(out-of-band mark)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四、带外标记总结"><span class="toc-number">9.</span> <span class="toc-text">四、带外标记总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数据链路访问"><span class="toc-number">10.</span> <span class="toc-text">数据链路访问</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#一、作用"><span class="toc-number">11.</span> <span class="toc-text">一、作用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、Linux访问-SOCK-PACKET和PF-PACKET"><span class="toc-number">12.</span> <span class="toc-text">二、Linux访问(SOCK_PACKET和PF_PACKET)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、libpcap：分组捕获函数库"><span class="toc-number">13.</span> <span class="toc-text">三、libpcap：分组捕获函数库</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四、libnet：分组构造与输出函数库"><span class="toc-number">14.</span> <span class="toc-text">四、libnet：分组构造与输出函数库</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#五、实例"><span class="toc-number">15.</span> <span class="toc-text">五、实例</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#路由套接字"><span class="toc-number">16.</span> <span class="toc-text">路由套接字</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#一、路由套接字"><span class="toc-number">17.</span> <span class="toc-text">一、路由套接字</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、数据链路套接字地址结构"><span class="toc-number">18.</span> <span class="toc-text">二、数据链路套接字地址结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、读和写"><span class="toc-number">19.</span> <span class="toc-text">二、读和写</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、实例-书"><span class="toc-number">20.</span> <span class="toc-text">三、实例(书)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四、sysctl"><span class="toc-number">21.</span> <span class="toc-text">四、sysctl</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#五、接口名字和索引-Linux内核无"><span class="toc-number">22.</span> <span class="toc-text">五、接口名字和索引(Linux内核无)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#秘钥管理套接字"><span class="toc-number">23.</span> <span class="toc-text">秘钥管理套接字</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#一、秘钥管理套接字"><span class="toc-number">24.</span> <span class="toc-text">一、秘钥管理套接字</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、读和写-1"><span class="toc-number">25.</span> <span class="toc-text">二、读和写</span></a></li></ol></div></div><div class="post-content"><hr>
<h1 id="IPv4与v6互操作性"><a href="#IPv4与v6互操作性" class="headerlink" title="IPv4与v6互操作性"></a>IPv4与v6互操作性</h1><hr>
<h1 id="一、IPv4客户端与IPv6服务器"><a href="#一、IPv4客户端与IPv6服务器" class="headerlink" title="一、IPv4客户端与IPv6服务器"></a>一、IPv4客户端与IPv6服务器</h1><ol>
<li>大多数双栈主机在处理监听套接字时应用以下规则：<ul>
<li>IPv4监听套接字只能接收IPv4的外来连接</li>
<li>IPv6监听套接字，如果绑定的是通配地址，且没有设置<code>IPV6_V6ONLY</code>套接字选项，可以接受IPv4/6的连接。对于IPv4，其服务端本地地址是与某个本地IPv4地址对应的IPv4映射的IPv6地址</li>
<li>如果IPv6套接字绑定的是除IPv4映射的IPv6地址之外的某个非通配IPv6地址，或者绑定通配地址的同时设置了<code>IPV6_V6ONLY</code>选项，则只能接受IPv6客户端的外来连接 </li>
</ul>
</li>
<li>IPv4数据报到达某个IPv6套接字的时候，内核把收到的IPv4地址转换成IPv4映射到IPv6的地址，透明地返回给应用进程</li>
</ol>
<h1 id="二、IPv6客户端与IPv4服务器"><a href="#二、IPv6客户端与IPv4服务器" class="headerlink" title="二、IPv6客户端与IPv4服务器"></a>二、IPv6客户端与IPv4服务器</h1><ol>
<li>通过IPv6套接字，发送IPv4数据报(connect或者sendto到IPv4映射的IPv6地址，内核将发送IPv4数据报)，转换由getaddrinfo解析器完成</li>
<li><p>总结</p>
<pre><code>            IPv4服务器       IPv6服务器      IPv4服务器     IPv6服务器    
            IPv4单栈主机     IPv6单栈主机     双栈主机       双栈主机
            (纯A)           (纯AAAA)           (A和AAAAA)    (A和AAAAA)

IPv4客户        IPv4            ——                IPv4         IPv4        
IPv4单栈主机

IPv6客户        ——                IPv6            ——             IPv6
IPv6单栈主机

IPv4客户        IPv4            ——                IPv4         IPv4
双栈主机

IPv6客户        IPv4            IPv6            ——             IPv6
双栈主机
</code></pre></li>
</ol>
<blockquote>
<p> IPv6 的 TCP 客户端与 IPv4 的 TCP 服务器之间通信的步骤如下：</p>
<p> 首先启动 IPv4 服务器，创建一个 IPv4 的监听套接字;</p>
<p> IPv6 客户端调用 getaddrinfo 函数查找 IPv6 地址;</p>
<p> IPv6 客户端在作为函数参数的 IPv6 套接字地址结构中设置这个 IPv4 映射的 IPv6 地址后调用 connect 函数向服务器发出连接请求，内核检测到这个映射地址后，自动向服务器主机发送一个 IPv4 的 SYN 数据报;</p>
<p> 服务器主机接收到来自客户端的 IPv4 的 SYN 数据报后，响应一个 IPv4 的SYN 和 ACK 数据报。连接通过使用 IPv4 数据报建立;</p>
<p> 总结</p>
<p> 双栈主机上的 IPv6 服务器既能服务于 IPv4 客户，又能服务于 IPv6 客户。IPv4 客户发送给这种服务器的仍然是 IPv4 数据报，不过服务器的协议栈会把客户主机的地址转换成一个 IPv4 映射的 IPv6 地址。类似地，双栈主机上的 IPv6 客户能够与 IPv4 服务器通信，客户的解析器会把服务器主机所有的 A 记录作为 IPv4 映射的 IPv6 地址返回给客户，而客户指定这些地址之一调用 connect 将会使双栈发送一个 IPv4 的 SYN 数据报。为了使套接字编程具有可移植性，在编程实现过程中，尽量避免使用 gethostbyname 和 gethostbyaddr 函数，而应该使用 getaddrinfo 和 getnameinfo 函数。</p>
</blockquote>
<h1 id="三、地址测试宏"><a href="#三、地址测试宏" class="headerlink" title="三、地址测试宏"></a>三、地址测试宏</h1><p><em>内核已变(略)</em></p>
<hr>
<h1 id="带外数据"><a href="#带外数据" class="headerlink" title="带外数据"></a>带外数据</h1><hr>
<h1 id="一、带外数据-out-of-band-data"><a href="#一、带外数据-out-of-band-data" class="headerlink" title="一、带外数据(out-of-band data)"></a>一、带外数据(out-of-band data)</h1><ol>
<li>目的：一端发生了重要事情，希望尽快告诉对端</li>
<li>比普通数据有更高优先级</li>
<li>不再建立连接，映射到已有连接中</li>
<li>UDP无带外数据</li>
<li>除远程非活跃应用，很少使用带外数据</li>
</ol>
<h1 id="二、TCP的带外数据"><a href="#二、TCP的带外数据" class="headerlink" title="二、TCP的带外数据"></a>二、TCP的带外数据</h1><ol>
<li>TCP没有真正带外数据，提供紧急模式</li>
<li><p>发送</p>
<ul>
<li><p>以<code>MSG_OOB</code>发送一个字节：</p>
<pre><code>send(fd, &quot;a&quot;, 1, MSG_OOB);
</code></pre></li>
<li><p>TCP把该字节放在缓冲区下一个可用位置，TCP紧急指针设置为下一个可用位置，带外字节标记为”OOB</p>
<pre><code>  | 1 | ... | N | OOB | |    |
要发的最后字节-&gt;|        |&lt;-紧急指针在下一可用位置    
</code></pre></li>
<li><p>TCP在首部中设置URG标志，并调整偏移字段等</p>
</li>
<li>TCP首部指出发送端已进入紧急模式，无论数据字节是否发出，URG紧急通知都会发送(数据流会因为TCP流量控制而停止，紧急通知总是无障碍的发送到对端TCP)，但紧急数据因为滑动窗口满而不随同发送</li>
<li><p>如果是发送多个字节，只有最后<strong>一个字节</strong>被认为是带外数据</p>
<pre><code>send(fd, &quot;abc&quot;, 1, MSG_OOB);    \\只发c
</code></pre></li>
</ul>
</li>
<li><p>接收</p>
<ul>
<li>收到URG标志时<ul>
<li>检查紧急指针是否指向新的带外数据</li>
<li>发送端TCP往往发送多个含URG标志且紧急指针指向同一个数据字节的分节</li>
<li>只有第一个到达的带外数据数据会通知到进程</li>
</ul>
</li>
<li>新的紧急指针到达时<ul>
<li>已经调用fcntl或ioctl为套接字建立属主，并且设置信号处理函数<ul>
<li>内核给接收套接字属主发送SIGURG信号</li>
</ul>
</li>
<li>接收进程阻塞在select<ul>
<li>select返回异常<ul>
<li>注意select会一直提示异常，直到进程的读入越过带外数据</li>
<li>即读完带外数据后，要再读过数据区，然后才能继续让select捕捉异常(见书P511例子)</li>
</ul>
</li>
</ul>
</li>
<li>一旦新的紧急指针到达，无论实际数据字节是否到达，这两个动作总会发生</li>
</ul>
</li>
<li><code>SO_OOBONLINE</code>选项<ul>
<li>默认禁止，此时带外数据不放入套接字缓冲区，而是放入该连接的独立单字节带外缓冲区，<ul>
<li>通过指定<code>MSG_OOB</code>标准调用recv/recvfrom/recvmsg读取</li>
</ul>
</li>
<li>开启时，数据放入套接字接收缓冲区(在线数据)<ul>
<li>此时不能通过MSG_OOB标志读取</li>
<li>通过检查连接的带外标记了解何时到达</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>出错</p>
<ul>
<li>通过<code>MSG_OOB</code>请求读取带外数据，但对端未发送，读操作返回EINVAL</li>
<li>已被告知对端发送了带外字节，但尚未到达，可能是URG标志已经置位，带外数据和紧急指针因为窗口已满还没到，读操作返回EWOULDBLOCK<ul>
<li>接收进程需要读取已排队的普通数据，以便缓冲区有空间接收带外数据</li>
</ul>
</li>
<li>多次读入同一个带外数据，读操作返回EINVAL</li>
<li>接收开启<code>SO_OOBONLINE</code>选项，但试图通过<code>MSG_OOB</code>读取，读操作返回EINVAL</li>
</ul>
</li>
</ol>
<h1 id="三、带外标记-out-of-band-mark"><a href="#三、带外标记-out-of-band-mark" class="headerlink" title="三、带外标记(out-of-band mark)"></a>三、带外标记(out-of-band mark)</h1><ol>
<li>每收到一个带外数据时，关联到带外标记</li>
<li>带外标记表明了发送带外字节时，该字节在发送端普通数据流中的位置</li>
<li>从套接字读入时，接收端调用sockatmark确定是否处于带外标记</li>
<li><p>同时适用于在线数据和带外数据，常见用法是接收进程特殊的对待所有数据，直到越过它(每次读之前判断是否是带外数据)</p>
<pre><code>#include&lt;sys/socket.h&gt;
int sockatmark(int sockfd);
处于带外标记返回1，不处于返回0，出错返回-1
</code></pre></li>
<li><p>带外标记的性质</p>
<ul>
<li>读操作总是停在带外标记上，无论缓冲区有多少数据</li>
<li>对于在线数据(<code>SO_OOBONLINE</code>选项开启)，如果下一个待读入的数据是OOB，则返回true</li>
<li>对于带外数据(<code>SO_OOBONLINE</code>选项关闭)，如果下一个待读入数据是OOB的下一个字节，则返回true</li>
<li>总之，就是读返回以后，sockatmark判断一下是否为true，对于select，读完带外数据以后，要再读普通数据后(让读入越过带外数据)，才能捕捉下一个带外数据</li>
<li>一个给定的TCP连接，只有一个带外标记，如果接收进程读入某个现有带外数据之前有新的带外数据到达，先前的标志就会丢失</li>
</ul>
</li>
</ol>
<h1 id="四、带外标记总结"><a href="#四、带外标记总结" class="headerlink" title="四、带外标记总结"></a>四、带外标记总结</h1><ol>
<li><p>带外数据向接收端传达的三个信息：</p>
<ul>
<li>通知发送端进入紧急模式<ul>
<li>接收进程得知的方法，通过SIGURG信号或者select调用</li>
<li>即使数据流因流量控制而停止，通知任然会发送</li>
<li>目的是通知接收端进入特殊处理模式，以接收任何后续数据</li>
</ul>
</li>
<li>带外字节位置<ul>
<li>相对其余数据的位置：带外标记</li>
</ul>
</li>
<li>带外字节内容<ul>
<li>任何单字节值</li>
</ul>
</li>
</ul>
</li>
<li><p>TCP没有真正的带外数据，只有紧急模式，可以认为：</p>
<ul>
<li>URG标志是通知</li>
<li>紧急指针是带外标记</li>
<li>数据字节是内容</li>
</ul>
</li>
<li><p>带外标记相关问题</p>
<ul>
<li>每个连接只有一个TCP紧急指针</li>
<li>每个连接只有一个带外标记</li>
<li>每个连接只有一个单字节带外缓冲区</li>
<li>新到达的标记覆盖先前的标记</li>
<li>即是：如果带外数据在线读入，当新的带外数据到达时，先前的带外数据并未丢失，但标记被覆盖了</li>
</ul>
</li>
<li><p>应用</p>
<ul>
<li>rlogin：当客户中断运行在服务器上的程序时，服务通知客户丢弃正在等待服务器的输出的数据</li>
<li>telnet：通过带外数据把255作为命令的前缀，以区分命令和普通用户数据</li>
<li>FTP：通知对端有异常发生</li>
</ul>
</li>
<li><p>使用</p>
<ul>
<li>如何使用取决于目的</li>
<li>如果通知对端事情发生，对带外数据内容不敏感，中间丢失一个字节和标记不影响结果</li>
<li>如果内容重要，需要在线接收，以防丢失</li>
</ul>
</li>
</ol>
<hr>
<h1 id="数据链路访问"><a href="#数据链路访问" class="headerlink" title="数据链路访问"></a>数据链路访问</h1><hr>
<h1 id="一、作用"><a href="#一、作用" class="headerlink" title="一、作用"></a>一、作用</h1><ol>
<li>监视由数据链路层接收的分组<ul>
<li>结合接口混杂模式，监视本地电缆上流通的所有分组(tcpdump)</li>
</ul>
</li>
<li>作为应用程序，而不是运行在内核中 </li>
</ol>
<h1 id="二、Linux访问-SOCK-PACKET和PF-PACKET"><a href="#二、Linux访问-SOCK-PACKET和PF-PACKET" class="headerlink" title="二、Linux访问(SOCK_PACKET和PF_PACKET)"></a>二、Linux访问(<code>SOCK_PACKET和PF_PACKET</code>)</h1><ol>
<li><p>Linux提供两种方法：</p>
<ul>
<li>旧方法使用socket创建协议族为<code>AF_INET</code>，类型为<code>SOCK_PACKET</code>的套接字，应用较广，缺乏灵活</li>
<li>新方法使用socket创建协议族为<code>PF_PACKET</code>的套接字，引入了更多过滤和性能特性<ul>
<li>需要超级用户权限(同原始套接字)</li>
<li>参数2的类型可以是<code>SOCK_RAW</code>或<code>SOCK_DGRAM</code>(表示除去链路层首部)的分组</li>
</ul>
</li>
<li><p>socket参数3的协议类型必需是一个非0值，内核中如下定义：</p>
<pre><code>/*
 *    These are the defined Ethernet Protocol ID&apos;s.
 */

#define ETH_P_LOOP    0x0060        /* Ethernet Loopback packet    */
#define ETH_P_PUP    0x0200        /* Xerox PUP packet        */
#define ETH_P_PUPAT    0x0201        /* Xerox PUP Addr Trans packet    */
#define ETH_P_IP    0x0800        /* Internet Protocol packet    */
#define ETH_P_X25    0x0805        /* CCITT X.25            */
#define ETH_P_ARP    0x0806        /* Address Resolution packet    */
#define    ETH_P_BPQ    0x08FF        /* G8BPQ AX.25 Ethernet Packet    [ NOT AN OFFICIALLY REGISTERED ID ] */
#define ETH_P_IEEEPUP    0x0a00        /* Xerox IEEE802.3 PUP packet */
#define ETH_P_IEEEPUPAT    0x0a01        /* Xerox IEEE802.3 PUP Addr Trans packet */
#define ETH_P_BATMAN    0x4305        /* B.A.T.M.A.N.-Advanced packet [ NOT AN OFFICIALLY REGISTERED ID ] */
#define ETH_P_DEC       0x6000          /* DEC Assigned proto           */
#define ETH_P_DNA_DL    0x6001          /* DEC DNA Dump/Load            */
#define ETH_P_DNA_RC    0x6002          /* DEC DNA Remote Console       */
#define ETH_P_DNA_RT    0x6003          /* DEC DNA Routing              */
#define ETH_P_LAT       0x6004          /* DEC LAT                      */
#define ETH_P_DIAG      0x6005          /* DEC Diagnostics              */
#define ETH_P_CUST      0x6006          /* DEC Customer use             */
#define ETH_P_SCA       0x6007          /* DEC Systems Comms Arch       */
#define ETH_P_TEB    0x6558        /* Trans Ether Bridging        */
#define ETH_P_RARP      0x8035        /* Reverse Addr Res packet    */
#define ETH_P_ATALK    0x809B        /* Appletalk DDP        */
#define ETH_P_AARP    0x80F3        /* Appletalk AARP        */
#define ETH_P_8021Q    0x8100          /* 802.1Q VLAN Extended Header  */
#define ETH_P_IPX    0x8137        /* IPX over DIX            */
#define ETH_P_IPV6    0x86DD        /* IPv6 over bluebook        */
#define ETH_P_PAUSE    0x8808        /* IEEE Pause frames. See 802.3 31B */
#define ETH_P_SLOW    0x8809        /* Slow Protocol. See 802.3ad 43B */
#define ETH_P_WCCP    0x883E        /* Web-cache coordination protocol
                     * defined in draft-wilson-wrec-wccp-v2-00.txt */
#define ETH_P_PPP_DISC    0x8863        /* PPPoE discovery messages     */
#define ETH_P_PPP_SES    0x8864        /* PPPoE session messages    */
#define ETH_P_MPLS_UC    0x8847        /* MPLS Unicast traffic        */
#define ETH_P_MPLS_MC    0x8848        /* MPLS Multicast traffic    */
#define ETH_P_ATMMPOA    0x884c        /* MultiProtocol Over ATM    */
#define ETH_P_LINK_CTL    0x886c        /* HPNA, wlan link local tunnel */
#define ETH_P_ATMFATE    0x8884        /* Frame-based ATM Transport
                     * over Ethernet
                     */
#define ETH_P_PAE    0x888E        /* Port Access Entity (IEEE 802.1X) */
#define ETH_P_AOE    0x88A2        /* ATA over Ethernet        */
#define ETH_P_8021AD    0x88A8          /* 802.1ad Service VLAN        */
#define ETH_P_802_EX1    0x88B5        /* 802.1 Local Experimental 1.  */
...

/*
 *    Non DIX types. Won&apos;t clash for 1500 types.
 */

#define ETH_P_802_3    0x0001        /* Dummy type for 802.3 frames  */
#define ETH_P_AX25    0x0002        /* Dummy protocol id for AX.25  */
#define ETH_P_ALL    0x0003        /* Every packet (be careful!!!) */
#define ETH_P_802_2    0x0004        /* 802.2 frames         */
#define ETH_P_SNAP    0x0005        /* Internal only        */
#define ETH_P_DDCMP     0x0006          /* DEC DDCMP: Internal only     */
#define ETH_P_WAN_PPP   0x0007          /* Dummy type for WAN PPP frames*/
#define ETH_P_PPP_MP    0x0008          /* Dummy type for PPP MP frames */
...

/*
 *    This is an Ethernet frame header.
 */

struct ethhdr {
    unsigned char    h_dest[ETH_ALEN];    /* destination eth addr    */
    unsigned char    h_source[ETH_ALEN];    /* source ether addr    */
    __be16        h_proto;        /* packet type ID field    */
} __attribute__((packed));
</code></pre></li>
</ul>
</li>
<li><p>创建套接字</p>
<ul>
<li>接收所有套接字：<pre><code>fd = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL));        // new
fd = socket(AF_INET, SOCK_PACKET, hton(ETH_P_ALL));        // old
</code></pre></li>
<li>接收IPv4套接字：<pre><code>fd = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_IP));        // new
fd = socket(AF_INET, SOCK_PACKET, hton(ETH_P_IP));        // old        
</code></pre></li>
</ul>
</li>
<li><p>设置混杂模式(promiscuous mode)</p>
<ul>
<li>如果数据链路支持，要设置接口为混杂模式<br>*　对<code>PF_PACKET</code>套接字：<ul>
<li>设置”PACKET_ADD_MEMBERSHIP”选项</li>
<li>setsockopt接口第4个参数传递的<code>packet_mreq</code>结构中指定网络接口和值为<code>PATCKET_MR_PROMISC</code>的行为</li>
</ul>
</li>
<li>对<code>SOCK_PACKET</code>套接字<ul>
<li>设置ioctl命令SIOCGIFLAGS的<code>IPF_PROMISC</code>标志，再使用SIOCIFFLAGS存储标志</li>
<li>多路监听可能互相干扰</li>
<li>设计不好可能造成程序退出还保持混杂模式</li>
</ul>
</li>
</ul>
</li>
<li><p>Linux的数据链路访问</p>
<ul>
<li>不提供内核缓冲，新方法通过<code>SO_ATTACH_FILTER</code>套接字选项提供内核过滤。尽管套接字有普通的接收缓冲区，但多个帧不能缓冲到一起由单个读操作一次性传递给应用进程，所以会增长内核到应用程序大量拷贝的开销</li>
<li>旧方法不提供对设备过滤，新方法可以bind到某个设备。比如指定<code>ETH_P_IP</code>时，来自任何链路(以太网、PPP、loopback)的IPv4数据报都返回到套接字。recvfrom返回通用套接字地址结构，<code>sa_data</code>成员含有设备名</li>
</ul>
</li>
</ol>
<h1 id="三、libpcap：分组捕获函数库"><a href="#三、libpcap：分组捕获函数库" class="headerlink" title="三、libpcap：分组捕获函数库"></a>三、libpcap：分组捕获函数库</h1><ol>
<li>libpcap访问操作系统提供的分组捕获机制，与实现无关，目前只支持分组的读入</li>
<li>tcpdump使用和提供</li>
</ol>
<h1 id="四、libnet：分组构造与输出函数库"><a href="#四、libnet：分组构造与输出函数库" class="headerlink" title="四、libnet：分组构造与输出函数库"></a>四、libnet：分组构造与输出函数库</h1><ol>
<li>以实现无关的方式提供原始套接字和数据链路访问的方式，可以构造任意协议的分组，并将其输出到网络中</li>
<li>提供简单便于移植的数据链路和原始套接字输出访问接口，隐藏构造IP、UDP和TCP首部的细节</li>
<li>可以设置超时，仅当读缓冲区满或者超时发送才返回到应用程序，如果超时为0，返回所有分组，会引起内核到应用程序的大量复制</li>
</ol>
<h1 id="五、实例"><a href="#五、实例" class="headerlink" title="五、实例"></a>五、实例</h1><ol>
<li>使用原始套接字无法读入UDP或TCP分组，必需使用分组捕获机制获取含有名字服务器应答的完整UDP数据报</li>
<li>从分组捕获设备读入与从普通套接字读入的差别：<ul>
<li>后者可以使用通配地址，接收到达任意接口的分组</li>
<li>前者只能在单个接口上接收达到的分组</li>
</ul>
</li>
</ol>
<hr>
<h1 id="路由套接字"><a href="#路由套接字" class="headerlink" title="路由套接字"></a>路由套接字</h1><hr>
<h1 id="一、路由套接字"><a href="#一、路由套接字" class="headerlink" title="一、路由套接字"></a>一、路由套接字</h1><ol>
<li>路由域只支持路由套接字</li>
<li>路由套接字支持3种类型的操作<ul>
<li>通过写套接字，向内核发送命令，进行路径操作(添加删除查询等)</li>
<li>通过读套接字，接收内核消息，从而通知进程收到并处理一个ICMP重定向消息，或者请求外部路由进程解析一个路径</li>
<li>可以使用sysctl读取路由表或列出所有已配置接口</li>
</ul>
</li>
<li>可以通过路由套接字向内核发送信息，请求某个路径的所有信息，又通过这个套接字读取内核的返回</li>
<li>创建路由探究中需要超级用户权限，使用sysctl检测路由表和接口列表不限用户权限</li>
</ol>
<h1 id="二、数据链路套接字地址结构"><a href="#二、数据链路套接字地址结构" class="headerlink" title="二、数据链路套接字地址结构"></a>二、数据链路套接字地址结构</h1><ol>
<li><p>Linux上是沿用BSD的NetLink实现，与书上不同：</p>
<pre><code>&lt;include/linux/socket.h&gt;
#define AF_KEY        15      /* PF_KEY key management API */
#define AF_NETLINK    16
#define AF_ROUTE    AF_NETLINK /* Alias to emulate 4.4BSD */
#define AF_PACKET    17    /* Packet family        */
</code></pre></li>
</ol>
<ol>
<li><p>也没有IP_RECVIF套接字选项</p>
<pre><code>&lt;inlcude/uapi/linux/in.h&gt;
---- IP_RECV Matches (23 in 2 files) ----
In.h (include\uapi\linux):#define IP_RECVOPTS    6
In.h (include\uapi\linux):#define IP_RECVERR    11
In.h (include\uapi\linux):#define IP_RECVTTL    12
In.h (include\uapi\linux):#define IP_RECVTOS    13
In.h (include\uapi\linux):#define IP_RECVRETOPTS       IP_RETOPTS
In.h (include\uapi\linux):#define IP_RECVORIGDSTADDR   IP_ORIGDSTADDR
</code></pre></li>
</ol>
<h1 id="二、读和写"><a href="#二、读和写" class="headerlink" title="二、读和写"></a>二、读和写</h1><ol>
<li><p>路由消息和书上不同</p>
<pre><code>&lt;include/uapi/linux/route.h&gt;
#define    RTF_UP        0x0001        /* route usable              */
#define    RTF_GATEWAY    0x0002        /* destination is a gateway    */
#define    RTF_HOST    0x0004        /* host entry (net otherwise)    */
#define RTF_REINSTATE    0x0008    /* reinstate route after tmout    */
#define    RTF_DYNAMIC    0x0010        /* created dyn. (by redirect)    */
#define    RTF_MODIFIED    0x0020    /* modified dyn. (by redirect)    */
#define RTF_MTU        0x0040        /* specific MTU for this route    */
#define RTF_MSS        RTF_MTU        /* Compatibility :-(        */
#define RTF_WINDOW    0x0080        /* per route window clamping    */
#define RTF_IRTT    0x0100        /* Initial round trip time    */
#define RTF_REJECT    0x0200        /* Reject route            */
</code></pre></li>
<li><p>地址结构也完全不同</p>
<pre><code>&lt;include/net/route.h&gt;
struct fib_nh;
struct fib_info;
struct rtable {
    struct dst_entry    dst;    

    int                rt_genid;
    unsigned int    rt_flags;
    __u16            rt_type;
    __u8            rt_is_input;
    __u8            rt_uses_gateway;        
    int                rt_iif;

    /* Info on neighbour */
    __be32            rt_gateway;

    /* Miscellaneous cached information */
    u32                rt_pmtu;        
    struct list_head    rt_uncached;
};

&lt;include/uapi/linux/route.h&gt;
/* This structure gets passed by the SIOCADDRT and SIOCDELRT calls. */
struct rtentry {
    unsigned long    rt_pad1;
    struct sockaddr    rt_dst;        /* target address        */
    struct sockaddr    rt_gateway;    /* gateway addr (RTF_GATEWAY)    */
    struct sockaddr    rt_genmask;    /* target network mask (IP)    */
    unsigned short    rt_flags;
    short            rt_pad2;
    unsigned long    rt_pad3;
    void            *rt_pad4;
    short            rt_metric;    /* +1 for binary compatibility!    */
    char __user        *rt_dev;    /* forcing the device at add    */
    unsigned long    rt_mtu;        /* per route MTU/Window     */
#ifndef __KERNEL__
#define rt_mss        rt_mtu        /* Compatibility :-(            */
#endif
    unsigned long    rt_window;    /* Window clamping         */
    unsigned short    rt_irtt;    /* Initial RTT            */
};
</code></pre></li>
<li><p>命令类型也不同</p>
<pre><code>&lt;include/uapi/linux/rtnetlink.h&gt;
/* Routing message attributes */
enum rtattr_type_t {
    RTA_UNSPEC,
    RTA_DST,
    RTA_SRC,
    RTA_IIF,
    RTA_OIF,
    RTA_GATEWAY,
    RTA_PRIORITY,
    RTA_PREFSRC,
    RTA_METRICS,
    RTA_MULTIPATH,
    RTA_PROTOINFO, /* no longer used */
    RTA_FLOW,
    RTA_CACHEINFO,
    RTA_SESSION, /* no longer used */
    RTA_MP_ALGO, /* no longer used */
    RTA_TABLE,
    RTA_MARK,
    RTA_MFC_STATS,
    __RTA_MAX
};
</code></pre></li>
</ol>
<h1 id="三、实例-书"><a href="#三、实例-书" class="headerlink" title="三、实例(书)"></a>三、实例(书)</h1><ol>
<li><p>发送查询</p>
<pre><code>#define REQ 9999
#define BUFSIZE sizeof(struct sockaddr_in) + 512
</code></pre></li>
</ol>
<pre><code>int pid = getpid();        
char ip[64] = &quot;192.168.1.100&quot;;
char *buf = calloc(1, BUFSIZE);
struct rt_msghdr* rtm = (struct rt_msghdr*)buf;    


int sockfd = socket(AF_ROUTE, SOCK_RAW, 0);

rtm-&gt;rtm_msglen    = sizeof(struct rt_msghdr);
rtm-&gt;rtm_version = RTM_VERSION;
rtm-&gt;rtm_type    = RTM_GET;
rtm-&gt;rtm_addrs    = RTA_DST;
rtm-&gt;rtm_pid        = pid;
rtm-&gt;rtm_seq        = REQ;

struct sockaddr_in    sin;
sin-&gt;sin_len = sizeof(struct sockaddr_in);
sin-&gt;sin_family = AF_INET;
inet_pton(AF_NET, &amp;ip[0], &amp;sin-&gt;sin_addr);

write(sockfd, rtm, rtm-&gt;rtm_msglen);
</code></pre><ol>
<li><p>读取</p>
<pre><code>int n = 0;
do {
    n = read(sockfd, rtm, BUFSIZE);
} while(rtm-&gt;rtm_type != RTM_GET || rtm-&gt;rtm_req != REQ || rtm-&gt;rtm_pid != pid)

struct sockaddr *sa, *rti_info[RTAX_MAX];    // RTAX_MAX = 8
rtm = (struct rt_msghdr*)buf;
sa = (struct sockaddr* )(rtm + 1);
get_rtaddrs(rtm-&gt;rtm_addrs, sa, rti_info);    // 遍历结果，查找之前查询的类型RTA_DST的返回结果

if((sa = rti_info[RTAX_DST]) != NULL)
    printf(&quot;dest: *s\n&quot;, sock_ntop_host(sa, sa-&gt;sa_len));

if((sa = rti_info[RTAX_GATEWAY]) != NULL)
    printf(&quot;gateway: *s\n&quot;, sock_ntop_host(sa, sa-&gt;sa_len));

if((sa = rti_info[RTAX_NETMASK]) != NULL)
    printf(&quot;netmask: *s\n&quot;, sock_masktop(sa, sa-&gt;sa_len));

if((sa = rti_info[RTAX_GENMASK]) != NULL)
    printf(&quot;genmask: *s\n&quot;, sock_masktop(sa, sa-&gt;sa_len));
</code></pre></li>
</ol>
<h1 id="四、sysctl"><a href="#四、sysctl" class="headerlink" title="四、sysctl"></a>四、sysctl</h1><pre><code>#include &lt;sys/param.h&gt;
#include &lt;sys/sysctl.h&gt;

int sysctl(int *name, u_int namelen, void *oldp, size_t *old_lenp, void *newp, size_t newlen);
成功返回0，出错-1
</code></pre><ol>
<li>使用类似SNMP的mib表管理</li>
<li><p>参数</p>
<ul>
<li>name指定名字的整数数组，namelen指定元素数目</li>
<li><p>数组第一个元素指定请求定向到内核的哪个子系统，后面元素逐层细化到该子系统的某个部分</p>
<pre><code>&lt;inlcude/uapi/linux/sysctl.h&gt;
CTL_DEBUG    CTL_HW    CTL_NET    CTL_VFS ...
                       |
            AF_INET    AF_LINK AF_ROUTE AF_UNSPEC ...
                |
IPPROTO_ICMP    IPPROTO_IP    IPPROTO_TCP IPPROTO_UDP...
    |
X     X    X    X
</code></pre></li>
<li><p>name数组的第二个选项：</p>
<ul>
<li><code>AF_INET</code>    ：IP层，下一级数组变量为<code>IPPROTO_</code></li>
<li><code>AF_LINK</code>    ：链路层信息</li>
<li><code>AF_ROUTE</code>    ：路由表或接口列表</li>
<li><code>AF_UNSPEC</code>    ：套接字层变量</li>
</ul>
</li>
<li><p>第二个元素为<code>AF_ROUTE</code>时，第三个元素总是0，第四个元素是地址族</p>
</li>
<li><p>第五、六个元素如表：</p>
<pre><code>name[]    返回IPv4路由表    返回IPv4 ARP高速缓存    返回IPv6路由表    返回接口list
0        CTL_NET            CTL_NEL                CTL_NET            CTL_NET
1         AF_ROUTE        AF_ROUTE            AF_ROUTE        AF_ROUTE
2        0                0                    0                0
3        AF_INET            AF_INET                AF_INET6        0
4        NET_RT_DUMP        NET_RT_FLAGS        NET_RT_DUMP        NET_RT_IFLIST
5        0                RTF_LLINFO            0                0
</code></pre></li>
<li><p>路由域支持的操作由name[4]决定，可通过sysctl的oldp返回</p>
<ul>
<li><p><code>NET_RT_DUMP</code>：返回name[3]指定的地址族路由表</p>
<ul>
<li>指定地址族为0时返回所有路由表</li>
</ul>
</li>
<li><p><code>NET_RT_FLAGS</code>：返回name[3]指定的地址族路由表，仅限于标志与name[5]匹配的路由表项</p>
</li>
<li><code>NET_RT_IFLIST</code>：返回name[5]指定的接口信息，如果没有指定，就所有已配置接口信息</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="五、接口名字和索引-Linux内核无"><a href="#五、接口名字和索引-Linux内核无" class="headerlink" title="五、接口名字和索引(Linux内核无)"></a>五、接口名字和索引(Linux内核无)</h1><pre><code>#include&lt;net/if.h&gt;
unsigned int if_nametoindex(const char *ifname);
成功返回正接口索引值，出错返回0

char *if_indextoname(unsigned int ifindex, char *ifname);
成功返回指向接口的指针，出错返回NULL

struct if_nameindex *if_nameindex(void)
成功返回非空，出错返回NULL

void if_freenameindex(struct if_nameindex *pr);

struct if_nameindex {
    unsigned int if_index;    // 1 2 3 ..
    char        *if_name;    //
}； 
</code></pre><hr>
<h1 id="秘钥管理套接字"><a href="#秘钥管理套接字" class="headerlink" title="秘钥管理套接字"></a>秘钥管理套接字</h1><hr>
<h1 id="一、秘钥管理套接字"><a href="#一、秘钥管理套接字" class="headerlink" title="一、秘钥管理套接字"></a>一、秘钥管理套接字</h1><ol>
<li>秘钥管理套接字<ul>
<li><code>AF_KEY</code>地址族或<code>PF_KEY</code>协议族(两者等价)</li>
<li>唯一支持原始套接字</li>
<li>仅限超级用户权限</li>
</ul>
</li>
<li>IPSec<ul>
<li>基于安全关联(security association, SA)，为分组提供安全服务</li>
<li>SA描述了源地址与目标地址(以及可选的端口)、机制(认证、加密等)以及秘钥素材的组合</li>
<li>单个分组的每个流通方向上可以应用不止一个SA(一个认证，一个加密)</li>
<li>存放一个系统中所有SA构成的集合称为安全关联数据库(SADB)</li>
<li>安全策略数据库(SPDB)描述分组流通的需求</li>
<li>秘钥管理套接字支持3种类型的操作：<ul>
<li>写套接字，向内核以及打开套接字的其它进程发送消息，可以增加删除SADB表项</li>
<li>读套接字，接收来自内核以及打开套接字的其它进程的消息，内核可以请求某个秘钥管理守护进程为依照策略需受保护的一个新TCP会话安装一个SA</li>
<li>往内核dump请求消息，dump出当前的SADB</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="二、读和写-1"><a href="#二、读和写-1" class="headerlink" title="二、读和写"></a>二、读和写</h1><ol>
<li><p>首部</p>
<pre><code>#define PF_KEY_V2        2
#define PFKEYV2_REVISION    199806L

struct sadb_msg {
    __u8        sadb_msg_version;
    __u8        sadb_msg_type;
    __u8        sadb_msg_errno;
    __u8        sadb_msg_satype;
    __u16    sadb_msg_len;
    __u16    sadb_msg_reserved;
    __u32    sadb_msg_seq;
    __u32    sadb_msg_pid;
} __attribute__((packed));
/* sizeof(struct sadb_msg) == 16 */
</code></pre></li>
<li><p>秘钥管理消息类型</p>
<ul>
<li>由<code>sadb_msg_type</code>成员确定</li>
<li>秘钥管理消息类型，前10种常用</li>
</ul>
</li>
</ol>
<pre><code>        /* Message types */            To    From(kernel)    
        #define SADB_RESERVED    0
        #define SADB_GETSPI        1    Y    Y    // 分配一个用于获取表项的SPI
        #define SADB_UPDATE        2    Y    Y    // 更改一个不完备的表项
        #define SADB_ADD        3    Y    Y    // 增加一个完整表项
        #define SADB_DELETE        4    Y    Y    // 删除一个表项
        #define SADB_GET        5    Y    Y    // 获取一个表项
        #define SADB_ACQUIRE    6    Y    Y    // 创建一个表项
        #define SADB_REGISTER    7    Y    N    // 注册成SADB_ACQUIRE的应答者
        #define SADB_EXPIRE        8    N    Y    // 某个表项到期
        #define SADB_FLUSH        9    Y    Y    // 冲刷整个SADB
        #define SADB_DUMP        10    Y    Y    // dump
        #define SADB_X_PROMISC    11    
        ...
        #define SADB_MAX        24

* 每个sadb_msg首部跟0个或多个扩展
</code></pre></div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2016/05/28/Linux网络编程-七、杂项/" data-id="ciujcgml9004gzq63dlmece54" class="article-share-link">分享到</a><div class="tags"><a href="/tags/Linux网络编程/">Linux网络编程</a></div><div class="post-nav"><a href="/2016/05/28/Linux网络编程-九、附录-IPv4、IPv6、ICMPv4、ICMPv6/" class="pre">九、附录 IPv4、IPv6、ICMPv4、ICMPv6</a><a href="/2016/05/28/Linux网络编程-三、套接字编程细化/" class="next">三、套接字编程细化</a></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C-C-经验累积/">C&C++经验累积</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Docker学习/">Docker学习</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux使用/">Linux使用</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux内核学习/">Linux内核学习</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux系统编程/">Linux系统编程</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux网络编程/">Linux网络编程</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Q-A/">Q&A</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Sip协议/">Sip协议</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux内核驱动与文件系统/">linux内核驱动与文件系统</a><span class="category-list-count">24</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/project-note/">project_note</a><span class="category-list-count">13</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/project-note/decode/">decode</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/project-note/think-about/">think_about</a><span class="category-list-count">4</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/开发环境搭建/">开发环境搭建</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂项/">杂项</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/渗透测试/">渗透测试</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/源码分析/">源码分析</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法学习/">算法学习</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/系统性能/">系统性能</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/">阅读笔记</a><span class="category-list-count">258</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/C-11新特性/">C++11新特性</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/C-Templates/">C++Templates</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/C程序设计语言/">C程序设计语言</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/EffectiveC/">EffectiveC++</a><span class="category-list-count">50</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/EffectiveSTL/">EffectiveSTL</a><span class="category-list-count">51</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/InsideC-ObjectModel/">InsideC++ObjectModel</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/Linux多线程服务器编程/">Linux多线程服务器编程</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/Linux性能优化大师/">Linux性能优化大师</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/Linux设备驱动程序/">Linux设备驱动程序</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/MoreEffectiveC/">MoreEffectiveC++</a><span class="category-list-count">26</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/TCPIP详解Vol1/">TCPIP详解Vol1</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/TheC-StandardLibraryEd1/">TheC++StandardLibraryEd1</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/TheC-StandardLibraryEd2/">TheC++StandardLibraryEd2</a><span class="category-list-count">23</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/http权威指南/">http权威指南</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/unix网络编程Ed3/">unix网络编程Ed3</a><span class="category-list-count">28</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/wireshark数据包分析实战/">wireshark数据包分析实战</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/实战LinuxShell编程与服务器管理/">实战LinuxShell编程与服务器管理</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/程序员的自我修养/">程序员的自我修养</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/网络安全基础/">网络安全基础</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/面向模式的软件体系结构Vol1/">面向模式的软件体系结构Vol1</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/高级C-C-编译技术/">高级C&C++编译技术</a><span class="category-list-count">2</span></li></ul></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/C程序设计语言/" style="font-size: 15px;">C程序设计语言</a> <a href="/tags/C-C-经验累积/" style="font-size: 15px;">C&C++经验累积</a> <a href="/tags/Linux使用/" style="font-size: 15px;">Linux使用</a> <a href="/tags/Linux内核学习/" style="font-size: 15px;">Linux内核学习</a> <a href="/tags/Linux系统编程/" style="font-size: 15px;">Linux系统编程</a> <a href="/tags/Linux网络编程/" style="font-size: 15px;">Linux网络编程</a> <a href="/tags/Q-A/" style="font-size: 15px;">Q&A</a> <a href="/tags/Sip协议/" style="font-size: 15px;">Sip协议</a> <a href="/tags/linux内核驱动与文件系统/" style="font-size: 15px;">linux内核驱动与文件系统</a> <a href="/tags/开发环境搭建/" style="font-size: 15px;">开发环境搭建</a> <a href="/tags/杂项/" style="font-size: 15px;">杂项</a> <a href="/tags/算法学习/" style="font-size: 15px;">算法学习</a> <a href="/tags/渗透测试/" style="font-size: 15px;">渗透测试</a> <a href="/tags/系统性能/" style="font-size: 15px;">系统性能</a> <a href="/tags/阅读笔记/" style="font-size: 15px;">阅读笔记</a> <a href="/tags/源码分析/" style="font-size: 15px;">源码分析</a> <a href="/tags/decode/" style="font-size: 15px;">decode</a> <a href="/tags/think-about/" style="font-size: 15px;">think_about</a> <a href="/tags/C-11新特性/" style="font-size: 15px;">C++11新特性</a> <a href="/tags/Docker学习/" style="font-size: 15px;">Docker学习</a> <a href="/tags/InsideC-ObjectModel/" style="font-size: 15px;">InsideC++ObjectModel</a> <a href="/tags/C-Templates/" style="font-size: 15px;">C++Templates</a> <a href="/tags/Linux性能优化大师/" style="font-size: 15px;">Linux性能优化大师</a> <a href="/tags/EffectiveC/" style="font-size: 15px;">EffectiveC++</a> <a href="/tags/Linux设备驱动程序/" style="font-size: 15px;">Linux设备驱动程序</a> <a href="/tags/Linux多线程服务器编程/" style="font-size: 15px;">Linux多线程服务器编程</a> <a href="/tags/EffectiveSTL/" style="font-size: 15px;">EffectiveSTL</a> <a href="/tags/TCPIP详解Vol1/" style="font-size: 15px;">TCPIP详解Vol1</a> <a href="/tags/TheC-StandardLibraryEd2/" style="font-size: 15px;">TheC++StandardLibraryEd2</a> <a href="/tags/TheC-StandardLibraryEd1/" style="font-size: 15px;">TheC++StandardLibraryEd1</a> <a href="/tags/http权威指南/" style="font-size: 15px;">http权威指南</a> <a href="/tags/MoreEffectiveC/" style="font-size: 15px;">MoreEffectiveC++</a> <a href="/tags/wireshark数据包分析实战/" style="font-size: 15px;">wireshark数据包分析实战</a> <a href="/tags/unix网络编程Ed3/" style="font-size: 15px;">unix网络编程Ed3</a> <a href="/tags/网络安全基础/" style="font-size: 15px;">网络安全基础</a> <a href="/tags/程序员的自我修养/" style="font-size: 15px;">程序员的自我修养</a> <a href="/tags/面向模式的软件体系结构Vol1/" style="font-size: 15px;">面向模式的软件体系结构Vol1</a> <a href="/tags/高级C-C-编译技术/" style="font-size: 15px;">高级C&C++编译技术</a> <a href="/tags/实战LinuxShell编程与服务器管理/" style="font-size: 15px;">实战LinuxShell编程与服务器管理</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/10/21/算法学习-基础算法学习-六-——-图的基本概念/">基础算法学习(六) —— 图的基本概念</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/20/算法学习-基础算法学习-五-——-树的排序、查找与平衡/">基础算法学习(五) —— 树的排序、查找与平衡</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/20/Linux内核学习-Linux内核初探-之-进程的内存管理-三-————-内存操作/">Linux内核初探 之 进程的内存管理(三) ———— 内存操作</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/19/Linux内核学习-Linux内核初探-之-进程的内存管理-二-————-虚拟内存/">Linux内核初探 之 内存管理(七) —— 内核内存分配函数的选择</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/19/Linux内核学习-Linux内核初探-之-进程的内存管理-一-————-进程地址空间/">Linux内核初探 之 进程的内存管理(一) ———— 进程地址空间</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/18/Linux内核学习-Linux内核初探-之-页高速缓存/">Linux内核初探 之 高速缓存</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/15/算法学习-基础算法学习-四-——-树/">基础算法学习(四) —— 树</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/15/算法学习-基础算法学习-三-——-字符串/">基础算法学习(三) —— 字符串</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/15/算法学习-基础算法学习-二-——-栈与队列/">基础算法学习(二) —— 栈与队列</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/15/算法学习-基础算法学习-一-——-线性表/">基础算法学习(一) —— 线性表</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://easy.ac.cn/" title="easy" target="_blank">easy</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">dupengair的blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>