<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="keep it simple, stupid"><title>《The C++ Standard Library 第一版》阅读笔记 | dupengair的blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/3.0.3/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">《The C++ Standard Library 第一版》阅读笔记</h1><a id="logo" href="/.">dupengair的blog</a><p class="description">日拱一卒 精而悟道</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">《The C++ Standard Library 第一版》阅读笔记</h1><div class="post-meta">May 28, 2016<span> | </span><span class="category"><a href="/categories/阅读笔记/">阅读笔记</a><a href="/categories/阅读笔记/TheC-StandardLibraryEd1/">TheC++StandardLibraryEd1</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#巨细靡遗-井然有序——侯捷序"><span class="toc-number">1.</span> <span class="toc-text">巨细靡遗 井然有序——侯捷序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#孟岩译序"><span class="toc-number">2.</span> <span class="toc-text">孟岩译序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第二章-C-及其标准程序库简介"><span class="toc-number">3.</span> <span class="toc-text">第二章 C++及其标准程序库简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第三章-一般概念"><span class="toc-number">4.</span> <span class="toc-text">第三章 一般概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第四章-通用工具"><span class="toc-number">5.</span> <span class="toc-text">第四章 通用工具</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第五章-STL-标准程序库"><span class="toc-number">6.</span> <span class="toc-text">第五章 STL 标准程序库</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第六章-STL容器"><span class="toc-number">7.</span> <span class="toc-text">第六章 STL容器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第八章-STL仿函数"><span class="toc-number">8.</span> <span class="toc-text">第八章 STL仿函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第十三章-以Stream-Class完成输入与输出"><span class="toc-number">9.</span> <span class="toc-text">第十三章 以Stream Class完成输入与输出</span></a></li></ol></div></div><div class="post-content"><h1 id="巨细靡遗-井然有序——侯捷序"><a href="#巨细靡遗-井然有序——侯捷序" class="headerlink" title="巨细靡遗 井然有序——侯捷序"></a>巨细靡遗 井然有序——侯捷序</h1><pre><code>1    STL学习的三个境界：
    1. 熟用STL
    2. 了解泛型技术的内涵和STL的原理及实作
    3. 扩充STL    a    
2    如果你希望开拓OO技术视野，iostream是一颗沉睡的瑰宝    c
3    面对陌生，程序员最大的障碍在于心中的怯弱。面对光明的技术，必须果敢。    c    
4    STL六大组件：container容器，algorithm算法，iterator迭代器，adapter适配器。function object仿函数， allocator配置器        
</code></pre><h1 id="孟岩译序"><a href="#孟岩译序" class="headerlink" title="孟岩译序"></a>孟岩译序</h1><pre><code>5    咏中秋者，自东坡西江月后，余词尽废    g    
6    C++第二号人物Andrew Koenig（他老婆也是个超级大牛牛，⊙﹏⊙b汗~~~）    g    
</code></pre><h1 id="第二章-C-及其标准程序库简介"><a href="#第二章-C-及其标准程序库简介" class="headerlink" title="第二章 C++及其标准程序库简介"></a>第二章 C++及其标准程序库简介</h1><pre><code>7    C++语言核心和C++程序库是同时被标准化的    9    
8    非类型参数可以看做是整个模板类型的一部分，所以非类型参数不同的模板是不同的模板，相互之间不能赋值    10    
9    除了以typename修饰以外，模板内部任何一个标识符都被解释为一个值。    11    
10    class member function 可以是个template， 但这样的class member template即不能是virtual， 也不能拥有缺省参数    12    
11    template constructor 并不屏蔽implicit copy constructor，会根据类型调用适当的    14    
12    如果函数的一个或多个参数类型，仍处在函数的namespace中，那么不必为该函数指定namespace，这被称为Koenig lookup、    17    
13    当dynamic_cast的参数是引用时，如果转型失败，会抛出一个bad_cast异常    19    
14    C++ 在 main()的末尾隐式定义了一个return 0;所以可以不用return语句退出，表示默认成功退出，C则不可以。    21    
</code></pre><h1 id="第三章-一般概念"><a href="#第三章-一般概念" class="headerlink" title="第三章 一般概念"></a>第三章 一般概念</h1><pre><code>15    如果异常说明中列出bad_exception,那么unexpected()总是重新抛出bad_exception异常以取代不在异常说明中的任何异常    27
16    C++标准程序库的异常总是派生自logic_error    27    
17    标准异常接口class exception只有一个成员函数what,返回一个null结尾的字符串：
        virtual const char* what() const throw();    28    
</code></pre><h1 id="第四章-通用工具"><a href="#第四章-通用工具" class="headerlink" title="第四章 通用工具"></a>第四章 通用工具</h1><pre><code>18    根据C++标准，基本类型的default构造函数也可以引起适当初始化动作，如：
        std::pair&lt;int, float&gt; p; //以int()和float()来初始化p，这两个构造函数都返回0    35    
19    一个算式如果明确指出类型，产生出来的pair将有绝对明确的类型
如：
        std::pair&lt;int, float&gt;(42, 72.77); //int, float
        std::make_pair(42, 72.77);     //int, double(浮点数默认为double)    37    
20    auto_ptr 不允许使用一般指针的赋值初始化过程：
        std::auto_ptr&lt;ClassA&gt; ptr1(new ClassA); //OK
        std::auto_ptr&lt;ClassA&gt; ptr1 == new ClassA; //ERROR    40    
21    auto_ptr 的语义本身就包含了拥有权，所以如果无意转交拥有权，就不要在函数参数或者返回值中使用auto_ptr。
如：
        void bad_print(std::auto_ptr&lt;ClassA&gt; p)
        {
           ...
        }
    当函数执行时，资源所有权会被转移到参数p，而当函数退出时，参数p被析构释放资源，导致原来的拥有者丢失资源。    43    
22    通过reference获得auto_ptr无法预知拥有权是否被转交，这是十分糟糕的设计，应全力避免    43    
23    关键词const意味着不能更改auto_ptr的拥有权，但可以修改所指向的对象。即const auto_ptr的语法类似于常量指针 T* const P，而不是指针常量const T* p    44    
24    std::swap()的最大优势在于，通过template specialization（模板特化）或function overloading（函数重载），可以为复杂的类型提供实例化版本，如交互对象内部成员。STL的所有容器以及string都采用了这项技术。    68    
25    &lt;utility&gt;中使用==和&lt;操作符定义了!=、&gt;、&lt;=、&gt;=四个操作符，通过using namespace std::rel_ops可以自动获得其定义并直接使用。某些实现使用两个不同模板类型参数来定义，是为了方便不同类型的操作数之间进行比较（只要可以），但这不是STL支持的做法，需要付出可移植性的代价    70    
26    C中NULL定义为(void *)0,在C++中这是不对的，C++中NULL定义为一个整型，否则无法将NULL、赋值给一个指针，因为C++没有定义从(void *)到其它类型的转型操作。    71    
</code></pre><h1 id="第五章-STL-标准程序库"><a href="#第五章-STL-标准程序库" class="headerlink" title="第五章 STL 标准程序库"></a>第五章 STL 标准程序库</h1><pre><code>27    通过迭代器的协助，我们只需写一次算法，就可以将它应用于任意容器之上。    74    
28    STL的基本观念就是将数据和操作分离，数据由容器类别加以管理，操作由可定义的算法定义，迭代器在两者之间充当连接器，使任何算法和任何容器都可以交互运作。    74    
29    STL的根本特性就是所有的组件都可以对任意型别进行操作，前提是该型别提供执行所必要的操作。    75    
30    一般而言，STL容器只提供具有良好时间效能的操作，防止程序员调用性能很差的操作。良好的时间效能通常意味着具有常数复杂度或对数复杂度。    79    
31    Vector具有dynamic array的所有性质，并且提供更安全便捷的接口    81    
32    互等性，如果两个元素都不小于对方，则视为相等    82    
33    所有的关联式容器，都是以二叉树来实现    83    
34    泛型设计的概念：不同类型的所有操作行为都使用相同的接口，因此可以使用templates将泛型操作公式化，使之在满足接口需求的任意类型上顺利运行。    83    
35    一般情况下，优先使用前置式递增，效率更高，因为不会生成临时对象    86    
36    算法非容器提供的成员函数，是搭配迭代器使用的全局函数，这么做的优势是只要实现一份，就可以应用在所有的迭代器，包括用户自定义的    94    
37    STL采用半开区间的主要优势是单纯，可避免对空集群做特殊处理    97    
38    有效区间的含义是，从起点出发，逐一前进，能够到达终点。也就是说，两个迭代器隶属同一容器，前后置位放置正确    97    
39    关联式容器不可能被当做覆盖写操作的目标    103    
40    STL算法和数据分离的设计思想，迭代器反映的是容器中某一位置的抽象概念，与容器类型无关，任何以迭代器访问容器元素的算法，都不得通过迭代器调用容器提供的成员函数。要实现删除容器元素只能通过容器自身的erase()操作    114    
41    算法的操作对象，不一定是容器的所有元素，如remove    114    
42    关联式容器不能调用manipulating 算法，因为容器内的元素是有序的    115    
43    在同时存在的情况下，如果注重效率应优先选用成员函数。如对list使用remove算法，会导致对每个节点的操作，调用list自身的remove成员函数则直接删除对应节点，效率高很多。    116    
44    STL要求，面对相同的值，predicts必须得出相同的结果，调用时会改变自身状态的函数不符合这个要求    121    
45    仿函数的优点：
    1、智能——拥有不同的状态，可以在执行期初始化
    2、拥有类型——可以用做template参数，不同的template可以表现出一致的行为
    3、效率——编译期处理有机会获得更好的性能（？）    127    
46    C++标准没有限制算法对一个容器元素调用仿函数的次数，因此可能导致一个仿函数有若干副本被传给元素。如果把仿函数当做predicts使用，可能会有问题。    130    
47    STL容器元素要求：
    1、有（性能优化的）copy构造函数，保证副本与原本完全一致，因为所有的容器内部都会保存元素副本。
    2、有assignment操作符
    3、可被析构
    4、对序列式容器——default构造函数必须可用，可以创建有默认值的非空的容器
    5、对关联式容器——元素必须定义排序准则，默认是operator&lt;，由仿函数less&lt;&gt;调用&quot;    134    
48    STL设计是效率优先，安全次之，错误检测相当花时间，所以几乎没有。对于STL的任何应用，如果不合规则就可能出现未定义的错误    137    
49    STL对异常提供基本保证：发生异常时不会泄漏资源，也不会违反容器特性    139    
</code></pre><h1 id="第六章-STL容器"><a href="#第六章-STL容器" class="headerlink" title="第六章 STL容器"></a>第六章 STL容器</h1><pre><code>50    STL容器的3个核心能力：
    1、所有的容器都提供value语意，内部保存元素的副本
    2、每个容器提供“可返回迭代器”的操作，可以以相同次序多次遍历每个元素。
    3、STL自身不抛出异常，如果调用使用者传入的函数会抛出异常，其结果未定义    144    
51    每个容器提供了一个member templates的构造函数，负责从输入得到元素并构造容器，并提供了从来源端到目标端的型别自动转换    145    
52    vector通常拥有一个内存区块的所有元素，其max_size()成员函数通常返回索引型别的最大值    146    
53    swap性能比容器赋值优异的多，因为它通常只交换容器内部数据，如指向数据的指针等，所以时间复杂度为常数。    147    
54    Vector是一种有序群集，元素可以是各种类型，但必须具有assignable和copyable的性质    148    
55    vector不能使用reserve来缩减容量，只能扩大，如果参数比现有容量小，容器不会发生变化，这是与string的区别    149    
56    安插操作可能导致references、pointers、iterators失效，因为可能导致vector重新分配空间    149    
57    两个vector交换内容后，容量也会交换，所以可以间接缩小容量：
        std::vector&lt;T&gt;(v).swap(v)    150    
58    由于list不支持随机存取，它的迭代器只是双向迭代器，所以凡是用到随机存取迭代器的算法都不可调用，如操作元素顺序的算法，排序等    169    
59    对于list，应调用其remove成员函数，而不是像vector和deques去调用通用算法    170    
60    所有的STL容器中list对异常安全提供了最佳支持，几乎所有的操作要么成，要么无效    172    
61    STL遵守的排序准则是strictly weak ordering:
    1、反对称 antisymmetric， 对于operator&lt;, if x &lt; y 为 true，则 y &lt; x 为 false
    2、可传递 transive，对于operator&lt;, if x &lt; y 为 true， y &lt; z 为 true，则 x &lt; z 为 true
    3、非自反 irreflexive，对于operator&lt;, x &lt; x 永远为 false    176    
62    自动排序的优点：
        搜寻元素时性能优良，具有对数复杂度，二叉树搜寻的复杂度（成员函数）为线性搜索（通用算法）的1/50
    缺点：
        不能直接改变元素值，会打乱原来的顺序，要改名元素值，只能先删除元素再插入    177    
63    标准库中，当采用默认方式（operator&lt;）进行排序时，默认的相等性测试语句为：
        if（!(elem1 &lt; elem2)||(elem2 &lt; elem1)）
    好处是：
    1、不必对元素类型提供==操作符
    2、只需传递一个参数做&quot;    178    
64    元素比较只能用于同类型并且比较方式的容器：
        set&lt;int&gt; c1;
        set&lt;int std::greater&lt;int&gt; &gt; c2;
        if( c1 == c2 ) //error&quot;    179    
65    对于关联式容器，其迭代器为双向迭代器，不能使用随机存取迭代器的算法，也不能对其使用变动性算法如remove，因为key为const，只能对其使用成员函数    200    
66    改变map的key：由于key为const不能直接改变，只能先添加value with new key，再删除old key：
        map1[new key] = map1[old key]; map1.erase(old key);    202    
67    从map中移除元素的正确做法：
        for(std::map&lt;T&gt;::iterator iter = map1.begin(); iter != map1.end();)
        {
             if(iter-&gt;second == value)
                   map1.erase(pos++);
             else
                   ++pos;
        }    205    
68    map的下标操作先调用default构造函数生成元素，然后再将value赋值，插入元素的效率不如insert成员函数    207    
</code></pre><h1 id="第八章-STL仿函数"><a href="#第八章-STL仿函数" class="headerlink" title="第八章 STL仿函数"></a>第八章 STL仿函数</h1><pre><code>69    将仿函数以by value方式传递的好处是，可以传递常量或临时表达式    298    
70    对于STL算法，如果以相同参数来调用单参数判断式，其返回结果总是应该相同，不应该因为被调用而改变自身状态，因为在算法内部，判断式可能被多次调用。最好将operator() 声明为const    304    
</code></pre><h1 id="第十三章-以Stream-Class完成输入与输出"><a href="#第十三章-以Stream-Class完成输入与输出" class="headerlink" title="第十三章 以Stream Class完成输入与输出"></a>第十三章 以Stream Class完成输入与输出</h1><pre><code>71    经&gt;&gt;读入字符时，一般会跳过开头的空格，如果不希望这样，可以清除skipws标志，或者使用get()    596    
</code></pre></div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2016/05/28/阅读笔记-TheC-StandardLibraryEd1-《The-C-Standard-Library-第一版》阅读笔记/" data-id="ciubc3odq00xs1r632k6ofnsx" class="article-share-link">分享到</a><div class="tags"><a href="/tags/TheC-StandardLibraryEd1/">TheC++StandardLibraryEd1</a></div><div class="post-nav"><a href="/2016/05/28/阅读笔记-TCPIP详解Vol1-第二十二章-TCP的坚持定时器/" class="pre">第二十二章 TCP的坚持定时器</a><a href="/2016/05/28/阅读笔记-TheC-StandardLibraryEd2-第七章-STL容器-3-——-Deque/" class="next">第七章 STL容器(3) —— Deque</a></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C-C-经验累积/">C&C++经验累积</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Docker学习/">Docker学习</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux使用/">Linux使用</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux内核学习/">Linux内核学习</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux系统编程/">Linux系统编程</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux网络编程/">Linux网络编程</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Q-A/">Q&A</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Sip协议/">Sip协议</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux内核驱动与文件系统/">linux内核驱动与文件系统</a><span class="category-list-count">24</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/project-note/">project_note</a><span class="category-list-count">13</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/project-note/decode/">decode</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/project-note/think-about/">think_about</a><span class="category-list-count">4</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/开发环境搭建/">开发环境搭建</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂项/">杂项</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/渗透测试/">渗透测试</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/源码分析/">源码分析</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法学习/">算法学习</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/系统性能/">系统性能</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/">阅读笔记</a><span class="category-list-count">258</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/C-11新特性/">C++11新特性</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/C-Templates/">C++Templates</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/C程序设计语言/">C程序设计语言</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/EffectiveC/">EffectiveC++</a><span class="category-list-count">50</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/EffectiveSTL/">EffectiveSTL</a><span class="category-list-count">51</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/InsideC-ObjectModel/">InsideC++ObjectModel</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/Linux多线程服务器编程/">Linux多线程服务器编程</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/Linux性能优化大师/">Linux性能优化大师</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/Linux设备驱动程序/">Linux设备驱动程序</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/MoreEffectiveC/">MoreEffectiveC++</a><span class="category-list-count">26</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/TCPIP详解Vol1/">TCPIP详解Vol1</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/TheC-StandardLibraryEd1/">TheC++StandardLibraryEd1</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/TheC-StandardLibraryEd2/">TheC++StandardLibraryEd2</a><span class="category-list-count">23</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/http权威指南/">http权威指南</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/unix网络编程Ed3/">unix网络编程Ed3</a><span class="category-list-count">28</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/wireshark数据包分析实战/">wireshark数据包分析实战</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/实战LinuxShell编程与服务器管理/">实战LinuxShell编程与服务器管理</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/程序员的自我修养/">程序员的自我修养</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/网络安全基础/">网络安全基础</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/面向模式的软件体系结构Vol1/">面向模式的软件体系结构Vol1</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/高级C-C-编译技术/">高级C&C++编译技术</a><span class="category-list-count">2</span></li></ul></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/C程序设计语言/" style="font-size: 15px;">C程序设计语言</a> <a href="/tags/C-C-经验累积/" style="font-size: 15px;">C&C++经验累积</a> <a href="/tags/Linux使用/" style="font-size: 15px;">Linux使用</a> <a href="/tags/Linux内核学习/" style="font-size: 15px;">Linux内核学习</a> <a href="/tags/Linux系统编程/" style="font-size: 15px;">Linux系统编程</a> <a href="/tags/Linux网络编程/" style="font-size: 15px;">Linux网络编程</a> <a href="/tags/Q-A/" style="font-size: 15px;">Q&A</a> <a href="/tags/Sip协议/" style="font-size: 15px;">Sip协议</a> <a href="/tags/linux内核驱动与文件系统/" style="font-size: 15px;">linux内核驱动与文件系统</a> <a href="/tags/开发环境搭建/" style="font-size: 15px;">开发环境搭建</a> <a href="/tags/杂项/" style="font-size: 15px;">杂项</a> <a href="/tags/渗透测试/" style="font-size: 15px;">渗透测试</a> <a href="/tags/算法学习/" style="font-size: 15px;">算法学习</a> <a href="/tags/源码分析/" style="font-size: 15px;">源码分析</a> <a href="/tags/系统性能/" style="font-size: 15px;">系统性能</a> <a href="/tags/阅读笔记/" style="font-size: 15px;">阅读笔记</a> <a href="/tags/decode/" style="font-size: 15px;">decode</a> <a href="/tags/think-about/" style="font-size: 15px;">think_about</a> <a href="/tags/C-11新特性/" style="font-size: 15px;">C++11新特性</a> <a href="/tags/Docker学习/" style="font-size: 15px;">Docker学习</a> <a href="/tags/C-Templates/" style="font-size: 15px;">C++Templates</a> <a href="/tags/EffectiveC/" style="font-size: 15px;">EffectiveC++</a> <a href="/tags/EffectiveSTL/" style="font-size: 15px;">EffectiveSTL</a> <a href="/tags/InsideC-ObjectModel/" style="font-size: 15px;">InsideC++ObjectModel</a> <a href="/tags/Linux性能优化大师/" style="font-size: 15px;">Linux性能优化大师</a> <a href="/tags/Linux多线程服务器编程/" style="font-size: 15px;">Linux多线程服务器编程</a> <a href="/tags/Linux设备驱动程序/" style="font-size: 15px;">Linux设备驱动程序</a> <a href="/tags/MoreEffectiveC/" style="font-size: 15px;">MoreEffectiveC++</a> <a href="/tags/TCPIP详解Vol1/" style="font-size: 15px;">TCPIP详解Vol1</a> <a href="/tags/TheC-StandardLibraryEd2/" style="font-size: 15px;">TheC++StandardLibraryEd2</a> <a href="/tags/TheC-StandardLibraryEd1/" style="font-size: 15px;">TheC++StandardLibraryEd1</a> <a href="/tags/wireshark数据包分析实战/" style="font-size: 15px;">wireshark数据包分析实战</a> <a href="/tags/http权威指南/" style="font-size: 15px;">http权威指南</a> <a href="/tags/unix网络编程Ed3/" style="font-size: 15px;">unix网络编程Ed3</a> <a href="/tags/实战LinuxShell编程与服务器管理/" style="font-size: 15px;">实战LinuxShell编程与服务器管理</a> <a href="/tags/网络安全基础/" style="font-size: 15px;">网络安全基础</a> <a href="/tags/程序员的自我修养/" style="font-size: 15px;">程序员的自我修养</a> <a href="/tags/面向模式的软件体系结构Vol1/" style="font-size: 15px;">面向模式的软件体系结构Vol1</a> <a href="/tags/高级C-C-编译技术/" style="font-size: 15px;">高级C&C++编译技术</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/10/15/算法学习-基础算法学习-四-——-树/">基础算法学习(四) —— 树</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/15/算法学习-基础算法学习-三-——-字符串/">基础算法学习(三) —— 字符串</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/15/算法学习-基础算法学习-二-——-栈与队列/">基础算法学习(二) —— 栈与队列</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/15/算法学习-基础算法学习-一-——-线性表/">基础算法学习(一) —— 线性表</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/15/Linux内核学习-Linux内核初探-之-内存管理-七-——-内核内存分配函数的选择/">Linux内核初探 之 内存管理(七) —— 内核内存分配函数的选择</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/15/Linux内核学习-Linux内核初探-之-内存管理-六-——-per-cpu-data/">Linux内核初探 之 内存管理(六) —— per cpu data</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/15/Linux内核学习-Linux内核初探-之-内存管理-五-——-静态分配与高端内存映射/">Linux内核初探 之 内存管理(五) —— 静态分配与高端内存映射</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/15/Linux内核学习-Linux内核初探-之-内存管理-四-——-Slab层/">Linux内核初探 之 内存管理(四) —— Slab层</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/12/开发环境搭建-VIM配置/">VIM配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/12/系统性能测试-系统性能工具篇-perf/">系统性能工具篇(perf)</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://easy.ac.cn/" title="easy" target="_blank">easy</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">dupengair的blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>