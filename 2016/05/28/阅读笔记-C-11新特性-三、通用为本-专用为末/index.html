<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="keep it simple, stupid"><title>三、通用为本 专用为末 | dupengair的blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/3.0.3/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">三、通用为本 专用为末</h1><a id="logo" href="/.">dupengair的blog</a><p class="description">日拱一卒 精而悟道</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">三、通用为本 专用为末</h1><div class="post-meta">May 28, 2016<span> | </span><span class="category"><a href="/categories/阅读笔记/">阅读笔记</a><a href="/categories/阅读笔记/C-11新特性/">C++11新特性</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、继承构造函数"><span class="toc-number">1.</span> <span class="toc-text">一、继承构造函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、委派构造函数"><span class="toc-number">2.</span> <span class="toc-text">二、委派构造函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、移动语义与完美转发"><span class="toc-number">3.</span> <span class="toc-text">三、移动语义与完美转发</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四、显式类型转换"><span class="toc-number">4.</span> <span class="toc-text">四、显式类型转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#五、初始化列表"><span class="toc-number">5.</span> <span class="toc-text">五、初始化列表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#六、POD类型"><span class="toc-number">6.</span> <span class="toc-text">六、POD类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#七、非受限联合体"><span class="toc-number">7.</span> <span class="toc-text">七、非受限联合体</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#八、用户自定义字面量"><span class="toc-number">8.</span> <span class="toc-text">八、用户自定义字面量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#九、内联名字空间（个人感觉用处不大）"><span class="toc-number">9.</span> <span class="toc-text">九、内联名字空间（个人感觉用处不大）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#十、定义别名"><span class="toc-number">10.</span> <span class="toc-text">十、定义别名</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#十一、一般化的SFINAE原则"><span class="toc-number">11.</span> <span class="toc-text">十一、一般化的SFINAE原则</span></a></li></ol></div></div><div class="post-content"><h1 id="一、继承构造函数"><a href="#一、继承构造函数" class="headerlink" title="一、继承构造函数"></a>一、继承构造函数</h1><ol>
<li><p>C++98可以通过using声明将基类非虚成员函数引入到派生类中，否则派生类无法访问基类同名的成员函数。但是构造函数不能通过using透传。</p>
<pre><code>struct A { void func(int); };
struct B:A { using A::func; void func(double); };

B b; b.func(4);                    //调用A::func(int)，如果没有using声明则调用A::func(double)
</code></pre></li>
<li><p>如果基类含有大量构造函数，派生类只是添加几个接口，则需要重复定义构造函数与基类保持一致</p>
<pre><code>struct A { 
    A(int); A(int, double);     //多个构造函数
    void func_A();                 //member function
};
struct B:A { 
    B(int b):A(b); B(int a, double b):A(a, b);     //与基类一致，对派生类无用
    void func_B();                 //增加的member function
};
</code></pre></li>
<li><p>C++11 中可通过using声明将基类的构造函数透传</p>
<pre><code>struct B:A { 
    using A::A;                    //继承的构造函数
    void func_B();                 //增加的member function
};    
</code></pre></li>
<li><p>当派生类有成员变量有默认值时，可通过就地初始化，继承构造函数无法初始化派生类的成员变量</p>
<pre><code>struct B:A { 
    using A::A;                    //继承的构造函数
    void func_B();                 //增加的member function
private:
    int b {0};        
};
</code></pre></li>
<li><p>如果派生类的成员变量也要通过构造函数初始化，则不能使用继承构造函数，和原来一样</p>
<pre><code>struct B:A { 
    B(int a, int _b):A(a), b(_b); 
    B(int a, double b, int _b):A(a, b), b(_b);     //无法使用继承构造函数
    void func_B();                 
private:
    int b;        
};    
</code></pre></li>
<li><p>继承构造函数对多重继承无法使用，只适合单继承的情况</p>
<pre><code>struct A { A(int); };
struct B { B(int); };
struct C:A, B {         
    using A::A;                    //error, 继承构造函数冲突
    using B::B;
};                
</code></pre></li>
</ol>
<h1 id="二、委派构造函数"><a href="#二、委派构造函数" class="headerlink" title="二、委派构造函数"></a>二、委派构造函数</h1><ol>
<li><p>C++98中只能通过调用公共函数在一定程度上减轻构造函数冗余的问题：</p>
<pre><code>class A {
public:
    A(int  x = 0, char y = &apos;a&apos;): _x(x), _y(y) { init(); }    //两个构造函数重复调用init()
    A(char y): _x(0), _y(y) { init(); }
private:
    void init();
    int  _x;
    char _y;
};
</code></pre></li>
<li><p>利用C++11就地初始化减轻冗余</p>
<pre><code>class A {
public:
    A(int  x = 0, char y = &apos;a&apos;): _x(x), _y(y) { init(); }    //构造函数体还是存在冗余
    A(char y): _y(y) { init(); }
private:
    void init();
    int  _x {0};
    char _y {&apos;a&apos;};
};
</code></pre></li>
<li><p>C++11中构造函数可以通过委派构造的方式，通过一个基本构造函数来构造，简单了很多</p>
<pre><code>class A {
public:
    A(int  x = 0, char y = &apos;a&apos;): _x(x), _y(y) {...}    //基本构造函数实现init()的内容        
    A(char y): A(0, y) { }                    //调用基本构造函数
private:    
    int  _x {0};
    char _y {&apos;a&apos;};
};
</code></pre></li>
<li><p>不能将初始化列表和委托构造函数同时使用</p>
<pre><code>A(char y): _y(y), A(0, y) { }                //error!
</code></pre></li>
<li><p>注意不要在基本构造函数和实施委派构造的构造函数体中初始化同一个成员，因为基本构造函数总是先于实施委派构造的构造函数体执行，和初始化列表一样</p>
<pre><code>A(int  x, char y): _x(x), _y(y) { ++_y; }    //基本构造函数    
A(char y): A(0, y) { _y = y; }                //再次初始化成员_y，导致基本构造函数体失效
</code></pre></li>
<li><p>注意不要让委派构造形成链式依赖关系</p>
<pre><code>A(int x): A(&apos;c&apos;) { }                        //依赖于A(char y)
A(char y): A(0)  { }                        //依赖于A(int  x)，形成链式依赖
</code></pre></li>
<li><p>委派构造函数的一个实际应用是定义构造函数模板，只用定义一个构造函数适应多个类型</p>
<pre><code>class A {
public:
    A(vector&lt;short&gt;&amp; v):A(v.begin(), v.end()) {}
    A(deque&lt;int&gt;&amp; d):A(d.begin(), d.end()) {}
private:
    template&lt;typename T&gt; 
    A(T first, T last) { ... }
};
</code></pre></li>
<li><p>可以在所有的委派构造中，捕获基本构造函数产生的异常</p>
<pre><code>class A {
public:
    A(int  x = 0, char y = &apos;a&apos;): _x(x), _y(y) { throw 1; }    //基本构造函数抛出异常
    A(char y): try: A(0, y) {                    //调用基本构造函数
        ...
    } catch (...) {                                //委派过程中捕获异常
        ...
    }                
private:            
    int  _x {0};
    char _y {&apos;a&apos;};
};
</code></pre></li>
</ol>
<h1 id="三、移动语义与完美转发"><a href="#三、移动语义与完美转发" class="headerlink" title="三、移动语义与完美转发"></a>三、移动语义与完美转发</h1><ol>
<li><p>拷贝构造</p>
<ul>
<li><p>拷贝构造：将资源从一个类拷贝到另一个类</p>
<pre><code>class A {
    int *d;
public:
    A():d(new int(0)) {}
    A(cosnt A&amp; a):d(new int(a.d)) {}        //拷贝构造函数
    ~A() { delete d; }
    static A GetA() { return A(); }
};

A a = A::GetA();                            //拷贝构造
</code></pre></li>
</ul>
<ul>
<li>这个拷贝构造的过程中，会生成两个临时对象，第一个在函数内部由GetA()显式构造生成，第二个由编译器生成用于函数返回。执行一次构造函数，显示调用GetA()构造函数内的临时对象。执行两次拷贝构造的过程，第一次由函数内部的临时对象拷贝生成用于函数返回的第二个临时对象，第二次由这个临时对象拷贝生成显式定义的对象a。</li>
<li>构造函数-&gt;临时对象1-&gt;拷贝构造-&gt;临时对象2-&gt;拷贝构造-&gt;对象a</li>
<li>由此可见，这个过程中资源被拷贝了两次。如果是个大数据量的资源，其性能损耗将不堪设想。</li>
</ul>
</li>
</ol>
<ol>
<li><p>移动构造</p>
<ul>
<li><p>移动构造：转移资源所有权</p>
<pre><code>A(cosnt A&amp;&amp; a):d(a.d) { a.d = nullptr; }    //资源所有权转移，需清空原来对象
A a = A::GetA();                            //移动构造
</code></pre><ul>
<li>此时的两个临时变量，调用的都是移动构造函数，从而避免了资源拷贝：<ul>
<li>构造函数-&gt;临时对象1-&gt;移动构造（资源转移）-&gt;临时对象2-&gt;移动构造（资源转移）-&gt;对象a</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol>
<li>左值与右值<ul>
<li>左值：等号左边、有名字（可标识），可以取地址    （C++98）</li>
<li>右值：等号右边、无名（不可标识），不能取地址    （C++98）<ul>
<li>将亡值（xvalue，eXpiring value）：右值引用&amp;&amp;，std::move的返回值，将被移动的对象</li>
<li>纯右值（prvalue，Pure rvalue）：临时对象，如表达式的临时对象，函数返回值、类型转换返回值、lambda表达式</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol>
<li><p>右值引用&amp;&amp;</p>
<ul>
<li>通常情况下，由于右值不可标识，所以只能从右值表达式获得右值引用</li>
<li><p>右值的生命周期将和右值引用的变量一样，类似于普通引用</p>
<pre><code>A&amp;&amp; ra = A::GetA();            //ra与GetA()返回的临时变量生命周期一样
</code></pre></li>
<li><p>右值引用不能绑定到左值</p>
<pre><code>A a; A&amp;&amp; ra = a;            // error!
</code></pre></li>
<li><p>只有常量的左值引用才能绑定到右值，因为右值不能修改，绑定后是只读的（对右值的修改不起作用）</p>
<pre><code>A&amp; a = A::GetA();            // error!
const A&amp; a = A::GetA();        // ok
</code></pre></li>
<li><p>与C++98的比较</p>
<pre><code>struct Obj { Obj(const Obj&amp;) { cout &lt;&lt; &quot;copied&quot; &lt;&lt; endl; } };    //只实现拷贝构造函数
Obj Rvalue() { return Obj; }

void passValue(Obj) {};        //值传递，C++98
void passRef(const Obj&amp;);    //引用传递，延长临时变量生命期，C++98
void passRref(Obj&amp;&amp;);        //右值引用， C++11

passValue(Rvalue());        //两次copy，输出copied copied
passRef(Rvalue());            //一次copy，输出copied 
passRref(Rvalue());            //一次copy，输出copied     
</code></pre></li>
<li><p>实现移动语义，必须具有移动构造函数</p>
<pre><code>struct Obj { Obj(Obj&amp;&amp;) { cout &lt;&lt; &quot;moved&quot; &lt;&lt; endl; } };        //移动构造函数
void passRref(Obj&amp;&amp; o) { Obj n = std::move(o); }            //实现移动语义
</code></pre></li>
<li><p>防御性设计，同时提供拷贝构造函数和移动构造函数</p>
<pre><code>Obj n = std::move(o);        //当没有定义移动构造函数时，语句实现拷贝构造语义
</code></pre></li>
<li><p>常量右值引用，合法但无实际意义，因为右值引用就是为了修改右值</p>
<pre><code>const Obj&amp;&amp; cRref = Rvalue()；
</code></pre></li>
<li><p>判断引用的类型，标准库<code>&lt;type_traits&gt;</code>提供3个模板类：<code>is_rvalue_reference、is_lvalue_reference、is_reference</code></p>
<pre><code>cout &lt;&lt; is_rvalue_reference&lt;Obj &amp;&amp;&gt;::value &lt;&lt; endl;
</code></pre></li>
</ul>
</li>
</ol>
<ol>
<li><p>std::move：将左值强制转化为右值</p>
<ul>
<li><p>基本等同于类型转换：</p>
<pre><code>static_cast&lt;T&amp;&amp;&gt;(lvalue);
</code></pre></li>
<li><p>由于可接受右值的右值引用本身是个左值，所以需要转化为右值才能实现移动语义，如下面的b.a</p>
</li>
<li>适合生命期即将结束的对象，注意避免误用。</li>
<li><p>实用中，通常转换拥有堆内存、文件句柄等资源的成员为右值，以实现移动语义，当成员没有移动构造函数时，实现拷贝构造</p>
<pre><code>class A {
    int* _a;
public:
    A(): _a(new int(0)) {}
    ~A() { delete _a; }
    A(A&amp;&amp; a): _a(a._a) { a._a = nullptr; }        //移动构造函数
};

class B {
    A a;
    int* _b;
public:
    B(): _b(new int(0)) {}
    ~B() { delete _b; }
    B(B&amp;&amp; b): _b(b._b), a(std::move(b.a)) {        //实现移动语义，否则b.a拷贝构造
        b._b = nullptr;
        }
};

B GetB() { return B(); }
B b(GetB());            //实现移动构造
</code></pre></li>
</ul>
</li>
</ol>
<ol>
<li><p>移动语义的一些问题</p>
<ul>
<li><p>注意不要声明成常量右值，移动语义的目的是为了修改右值</p>
<pre><code>B(const B&amp;&amp; b);
const B GetB();
</code></pre></li>
<li><p>与构造函数一样，编译器会隐式生成（即用到才生成）一个移动构造函数，但通常情况下，实现移动语义都需要自定义移动构造函数</p>
</li>
<li>只有移动语义的类，往往都是资源型的类，要求资源的唯一性，如智能指针<code>unique_ptr</code></li>
<li><p>可以通过标准库<code>&lt;type_traits&gt;</code>的方法判断一个类型是否可以移动：<code>is_move_constructible、is_trivially_move_constructible、is_nothrow_move_constructible:</code></p>
<pre><code>cout &lt;&lt; is_move_constructible&lt;Type&gt;::value &lt;&lt; endl;
</code></pre></li>
<li><p>关于swap函数，可移动的情况下执行移动语义，否则执行拷贝</p>
<pre><code>template&lt;class T&gt;
void swap(T&amp; a, T&amp; b)
{
    T tmp(std::move(a));
    a = std::move(b);
    b = std::move(tmp);
}
</code></pre></li>
<li><p>移动构造函数尽量避免抛出异常，因为多含有指针操作，抛出异常时很容易出现悬垂指针。可以添加noexcept关键字，或者使用<code>std::move_if_noexcept</code>（当move构造函数定义有noexcept时执行move语义，否则执行拷贝，牺牲性能以保证安全性）</p>
</li>
<li><p>与RVO优化的矛盾：RVO优化会大量减少临时变量的产生，从而阻止了移动语义    </p>
<pre><code>B GetB() { return B(); }
B b(GetB());                //b的地址实际就是B()产生的临时变量的地址
</code></pre></li>
<li><p>RVO并不是总是起作用，视编译器而定，移动语义总是能发挥作用    </p>
</li>
</ul>
</li>
</ol>
<ol>
<li><p>完美转发</p>
<ul>
<li>完美转发指在函数模板中，完全按照模板参数的类型将参数传递给所调用的目标函数</li>
<li><p>实现完美转发并不容易</p>
<pre><code>void realfunc(X u);
template&lt;typename T&gt;
void forwardfunc(T t) {     //包装函数转发参数，基本类型转发，会产生拷贝
    realfunc(t);             //目标函数实际执行
}
</code></pre></li>
<li><p>通常在包装函数中通过引用转发参数，避免传递过程中拷贝带来的开销。但目标函数的接受能力不同，可能是const，可能是左值引用或右值引用，而左值引用不能接受右值，同样右值引用不能接受左值，只有常量左值引用是万能的，但其具有常量性。</p>
</li>
<li>通常通过对函数模板的重载，来解决目标函数的接受问题，这在目标函数参数比较多的情况下，造成代码冗余。</li>
<li><p>引用折叠，将复杂的未知表达式转化为已知的简单表达式</p>
<pre><code>typedef const int T;
typedef T&amp; TR;                 //将类型T转发
TR&amp; v = 1;                    //c++98出错，因为没有引用折叠

TR的类型 声明v的类型 v的实际类型
T&amp;        TR             T&amp;
T&amp;        TR&amp;         T&amp;
T&amp;         TR&amp;&amp;         T&amp;    
T&amp;&amp;     TR             T&amp;&amp;
T&amp;&amp;     TR&amp;         T&amp;
T&amp;&amp;     TR&amp;&amp;         T&amp;&amp;    
</code></pre><ul>
<li>当定义中出现左值引用，引用折叠总是优先折叠为左值。    </li>
<li><p>因此，当转发函数实参是一个左值引用时，参数类型被推导为T&amp;，是右值引用时，为T&amp;&amp;</p>
<pre><code>template&lt;typename T&gt;
void forwardfunc(T&amp;&amp; t) {     
    realfunc(t);         
}    
</code></pre><ul>
<li>对上面函数，T为T&amp;时，t的类型为T&amp; &amp;&amp;，即为T&amp;；T为T&amp;&amp;时，t的类型为T&amp;&amp; &amp;&amp;，即为T&amp;&amp;.</li>
</ul>
</li>
<li><p>别忘了，要实现移动语义，还要std::move，否则转发的类型只能是左值（因为此时的转发的是一个具名对象）。不过在完美转发的情况下，换成了forward，转发的模板函数最终定义为：</p>
<pre><code>template&lt;typename T&gt;
void forwardfunc(T&amp;&amp; t) {     
    realfunc(std::forward(t));         
}    
</code></pre></li>
</ul>
</li>
<li><p>一个完美转发的实例：</p>
<pre><code>void realfunc(int&amp; u)  { std::cout &lt;&lt; &quot;lvalue ref: &quot; &lt;&lt; u &lt;&lt; std::endl; }
void realfunc(int&amp;&amp; u) { std::cout &lt;&lt; &quot;rvalue ref: &quot; &lt;&lt; u &lt;&lt; std::endl; }
void realfunc(const int&amp; u)  { std::cout &lt;&lt; &quot;const lvalue ref: &quot; &lt;&lt; u &lt;&lt; std::endl; }
void realfunc(const int&amp;&amp; u) { std::cout &lt;&lt; &quot;const rvalue ref: &quot; &lt;&lt; u &lt;&lt; std::endl; }                
template&lt;typename T&gt; 
void forwardfunc(T&amp;&amp; t) {     
    realfunc(std::forward&lt;T&gt;(t));         
}

int main() {
    int a = 1;
    int b = 2;
    const int c = 3;
    const int d = 4;

    forwardfunc(a);                //lref
    forwardfunc(std::move(b));    //rref
    forwardfunc(c);                //const lref
    forwardfunc(std::move(d));    //const rref
}
</code></pre></li>
<li><p>转发函数用作包装器：        </p>
<pre><code>void realfunc1(int&amp; u)  { std::cout &lt;&lt; &quot;realfunc1: &quot; &lt;&lt; u &lt;&lt; std::endl; }
void realfunc2(int&amp;&amp; u) { std::cout &lt;&lt; &quot;realfunc2: &quot; &lt;&lt; u &lt;&lt; std::endl; }
void realfunc3(const int&amp; u)  { std::cout &lt;&lt; &quot;realfunc3: &quot; &lt;&lt; u &lt;&lt; std::endl; }
void realfunc4(const int&amp;&amp; u) { std::cout &lt;&lt; &quot;realfunc4: &quot; &lt;&lt; u &lt;&lt; std::endl; }        
void realfunc5(char u)  { std::cout &lt;&lt; &quot;realfunc5: &quot; &lt;&lt; u &lt;&lt; std::endl; }
void realfunc6(const char u)  { std::cout &lt;&lt; &quot;realfunc6: &quot; &lt;&lt; u &lt;&lt; std::endl; }
</code></pre></li>
</ul>
</li>
</ol>
<pre><code>        template&lt;typename T, typename U&gt; 
        void funcwarpper(T&amp;&amp; t, U&amp; func) {     
                func(std::forward&lt;T&gt;(t));         
        }    


        int main() {    
                int a = 1;
                const int c = 3;
                const char e = &apos;e&apos;;

                funcwarpper(a, realfunc1);    //1
                funcwarpper(2, realfunc2);    //2
                funcwarpper(c, realfunc3);    //3
                funcwarpper(4, realfunc4);    //4
                funcwarpper(e, realfunc5);    //e
                funcwarpper(&apos;f&apos;, realfunc6);    //f
        }

* 补充：关于完美转发，网上这段讲的很好：

    + 左值和右值的语法符号
    + 左值的声明符号为”&amp;”， 为了和左值区分，右值的声明符号为”&amp;&amp;”。

            示例程序 :

             void process_value(int&amp; i) { 
              std::cout &lt;&lt; &quot;LValue processed: &quot; &lt;&lt; i &lt;&lt; std::endl; 
             } 

             void process_value(int&amp;&amp; i) { 
              std::cout &lt;&lt; &quot;RValue processed: &quot; &lt;&lt; i &lt;&lt; std::endl; 
             } 

             int main() { 
              int a = 0; 
              process_value(a); 
              process_value(1); 
             }
            运行结果 :

             LValue processed: 0 
             RValue processed: 1

        - Process_value 函数被重载，分别接受左值和右值。由输出结果可以看出，临时对象是作为右值处理的。

    + 但是如果临时对象通过一个接受右值的函数传递给另一个函数时，就会变成左值，因为这个临时对象在传递过程中，变成了命名对象。

            示例程序 :

             void process_value(int&amp; i) { 
              std::cout &lt;&lt; &quot;LValue processed: &quot; &lt;&lt; i &lt;&lt; std::endl; 
             } 

             void process_value(int&amp;&amp; i) { 
              std::cout &lt;&lt; &quot;RValue processed: &quot; &lt;&lt; i &lt;&lt; std::endl; 
             } 

             void forward_value(int&amp;&amp; i) { 
              process_value(i); 
             } 

             int main() { 
              int a = 0; 
              process_value(a); 
              process_value(1); 
              forward_value(2); 
             }
            运行结果 :

             LValue processed: 0 
             RValue processed: 1 
             LValue processed: 2

        - 虽然 2 这个立即数在函数`forward_value`接收时是右值，但到了`process_value`接收时，变成了左值。
</code></pre><h1 id="四、显式类型转换"><a href="#四、显式类型转换" class="headerlink" title="四、显式类型转换"></a>四、显式类型转换</h1><ol>
<li><p>c++98中，explicit用于构造函数，阻止通过构造函数的隐式类型转换，但对用户定义的类型转换没有做限制</p>
<pre><code>class A {
        int m, n;
    public:
        A(int x, int y): m(x), n (y) {}
        operator int() { return m*n; }
};

int main() {
        A a(1,2), b(2,3);
        cout &lt;&lt; a + b &lt;&lt; endl;            //隐式转换为int    
}
</code></pre></li>
</ol>
<ol>
<li><p>C++11运行对用户定义类型转换函数应用explicit，从而阻止隐式类型转换</p>
<pre><code>class A {
        int m, n;
    public:
        A(int x, int y): m(x), n (y) {}
        explicit operator int() { return m*n; }
};

int main() {
        A a(1,2), b(2,3);
        cout &lt;&lt; a + b &lt;&lt; endl;            //出错，无法隐式转换为int
    cout &lt;&lt; (int)a + (int)b &lt;&lt; endl;     //只能显式转换    
}
</code></pre></li>
<li><p>可以运用到关系运算符，因为关系运算符要求bool类型，是个显式转换，看官方示例：</p>
<pre><code>template&lt;typename T&gt;    
class Ptr {
    public:
        Ptr(T* p): _p(p) {}
        explicit operator bool() const { 
        if(_p) 
            return true;
        else
            return false; 
    }
};

int main() {
    int a = 1;
    Ptr&lt;int&gt; pi(&amp;a);                    //初始化为指针类型

    if(pi) {                             //在关系运算符中是显式转换，判断指针是否为空
        cout &lt;&lt; &quot;valid pointer&quot; &lt;&lt; endl; 
    } else {
        cout &lt;&lt; &quot;empty&quot; &lt;&lt; endl;
    }

    Ptr&lt;char&gt; pc(&apos;c&apos;);
        cout &lt;&lt; pi + pc &lt;&lt; endl;        //出错，通过explicit阻止隐式转换为bool，避免无意义的+操作
}
</code></pre></li>
</ol>
<h1 id="五、初始化列表"><a href="#五、初始化列表" class="headerlink" title="五、初始化列表"></a>五、初始化列表</h1><ol>
<li><p>C++98中只有数组能采用初始化列表，C++11中包括容器在内的各种集合都可以</p>
<pre><code>int a[] = {1, 3, 5};
vector&lt;int&gt; b {1, 3, 5};
map&lt;int, float&gt; c = {{1, 1.0f}, {2, 2.0f}, {3, 3.0f}};
</code></pre></li>
<li><p>c++11的初始化方式有无=，{}或()都可以</p>
<pre><code>int a = 1 + 2;
int a = {1+2};
int a {1+2};
int a (1+2);
new int{1};
new int(1);
</code></pre></li>
<li><p>自定义类型通过<code>&lt;initializer_list&gt;</code>的<code>std::initializer_list&lt;T&gt;</code>模板支持初始化列表</p>
<pre><code>#include&lt;initializer_list&gt;    
#include&lt;vector&gt;
#include&lt;string&gt;

class Student {
    std::vector&lt;std::pair&lt;int, std::string&gt; &gt; data;
public:
    Student(std::initializer_list&lt;std::pair&lt;int, std::string&gt; &gt; l) {
        for(auto i=l.begin(); i!=l.end(); ++i) 
            data.push_back(*i);
    }
};

Student class1 = {{1, "Li"}, {2, "Wang"}, {3, "Zhao"}};
</code></pre></li>
<li><p>函数也能使用初始化列表：</p>
<pre><code>void func(std::initializer_list&lt;int&gt; l) { 
        for(auto i=l.begin(); i!=l.end(); ++i) 
        std::cout &lt;&lt; (*i) &lt;&lt; std::endl;
}
func({1, 2, 3, 4});
</code></pre></li>
<li><p>可以通过重载<code>operator[]</code>扩展数组对列表的支持，实现一次性访问多个数组元素</p>
<pre><code>#include &lt;algorithm&gt;
#include&lt;initializer_list&gt;    
#include&lt;vector&gt;
using namespace std;    

class SmartArray {
    vector&lt;int&gt; idx;
    vector&lt;int&gt; d;
 public:
    SmartArray&amp; operator[] (std::initializer_list&lt;int&gt; l) {
        std::for_each(l.begin(), l.end(), [&amp;](int i) { idx.push_back(i); });
        return *this;
    }

    SmartArray&amp; operator= (int t) {
        if (!idx.empty()) {
            std::for_each(idx.begin(), idx.end(), [&amp;](int i) {
                d.resize((i+1) &gt; (int)d.size() ? (i+1) : (int)d.size());
                d[i] = t;
            });
            idx.clear();
        }
        return *this;
    }

    void Print() {
        for(auto i=d.begin(); i!=d.end(); ++i)  cout &lt;&lt; *i &lt;&lt; &quot; &quot;;
        cout &lt;&lt; endl;
    }
};

int main() {
    SmartArray s;
    s[{1, 3, 5}] = 1;        //s[]的第1、3、5个元素值
    s[{2, 4, 6}] = 2;        //s[]的第2, 4, 6个元素值
    s.Print();            //0 1 2 1 2 1 2
}
</code></pre></li>
<li><p>初始化列表还可应用于函数返回，此时通常会有临时变量产生</p>
<pre><code>vector&lt;int&gt; func() { return {1, 2, 3}; }        //如果是引用返回只能用const
</code></pre></li>
<li><p>防止类型收窄</p>
<ul>
<li>类型收窄指数据发生变化或精度丢失的隐式类型转换，通常由于新类型无法表现原有数据</li>
<li>通常由几种情况：<ul>
<li>浮点-&gt;整型：<code>int a = 1.2;</code></li>
<li>高精度浮点转低精度浮点：long double -&gt; double</li>
<li>大整型-&gt;浮点：整型数据大到浮点无法精确表示</li>
<li>整型-&gt;小整型：<code>char = 1024</code></li>
</ul>
</li>
<li><p>初始化列表是唯一可以防止类型收窄的方式（实际测试gcc4.8.1只是多了个警告）</p>
<pre><code>const int x = 1024;
char a = x;            //通过编译            
char b = {x};        //编译出错
</code></pre></li>
</ul>
</li>
</ol>
<h1 id="六、POD类型"><a href="#六、POD类型" class="headerlink" title="六、POD类型"></a>六、POD类型</h1><ol>
<li><p>POD表示trivial和标准布局的合集</p>
<ul>
<li><p>trivial</p>
<ul>
<li>拥有trivial default consturctor、destructor、copy constructor、move constructor、assignment operator</li>
<li>没有virtual base和virtual funciton</li>
</ul>
</li>
<li><p>标准布局</p>
<ul>
<li>所有非静态类型有相同的访问权限</li>
<li>继承时满足下列条件之一：<ul>
<li>派生类中有非静态成员时，基类只能是单继承且仅包含静态成员</li>
<li>派生类没有非静态成员时，基类可以多继承也可以包含非静态成员<br>(即非静态成员同时出现在基类和派生类时，就不是POD类型)</li>
</ul>
</li>
<li>派生类的第一个非静态成员类型不是基类类型（达到对象和第一个成员共享地址的目的）<ul>
<li>C++标准中，如果基类没有成员，则派生类的第一个成员与基类共享地址。因为派生类的地址总是堆叠在基类之上的，这样的地址共享表明了基类是空的，不占据地址空间以节省数据</li>
<li>如果派生类第一个成员是基类了下，编译器会分配1byte空间，以保证不同成员的地址不同</li>
</ul>
</li>
<li>没有虚函数和虚基类</li>
<li>所有非静态数据成员和基类符合标准布局</li>
</ul>
</li>
</ul>
</li>
<li><p>可通过模板判断类型是否符合标准布局或POD</p>
<pre><code>#include &lt;type_traits&gt;
template&lt;typename T&gt; struct std::is_standard_layout;
cout &lt;&lt; is_standard_layout&lt;T&gt;::value;

template&lt;typename T&gt; struct std::is_pod;
cout &lt;&lt; is_pod&lt;T&gt;::value;
</code></pre></li>
<li><p>使用POD的好处</p>
<ul>
<li>字节赋值，可使用memset memcpy等</li>
<li>与C的内存布局兼容</li>
<li>保证静态初始化安全    </li>
</ul>
</li>
</ol>
<h1 id="七、非受限联合体"><a href="#七、非受限联合体" class="headerlink" title="七、非受限联合体"></a>七、非受限联合体</h1><ol>
<li>C++98里union不允许拥有非POD成员、静态成员和引用类型成员，并且不能做基类，这是为了保证与C的兼容性</li>
<li>C++11中任何非引用类型都可以是union的成员，静态成员函数可以作为union成员，静态变量不行</li>
<li><p>C++98里union的所有成员会被默认初始化，C++11里当成员由non-trivial的一系列函数时，需要自己实现构造函数，通常此时可以用placement new</p>
<pre><code>union failed {
    string s;        //non-trivial
    int n;
}

T t;                //构造失败

union succ {
    string s;        //non-trivial
    int n;
public:
    succ() { new (&amp;s) string; }
    ~succ() { s.~string; };
}

T t;                //构造成功
</code></pre></li>
<li><p>在类中使用匿名非受限联合可以使类呈现变长的特征</p>
<pre><code>struct Student { string name; bool gender; int age; };

class District {
public:
    enume Type { STUDENT=0, BUILDING, ROAD };
    District(string n, bool g, int a): s.name(n), s.gender(g), s.age(a) { type = STUDENT; }
    District(int i): id(i) { type = BUILDING; }
    District(string n):addr(n) { type = ROAD; }
private:
    Type type;
    union {
        Student s;
        int id;
        string addr;
    };
};

District stu(&quot;Tom&quot;, 0, 12);
District house(1);        
District road(&quot;ShenNanDaDao&quot;);
</code></pre></li>
</ol>
<h1 id="八、用户自定义字面量"><a href="#八、用户自定义字面量" class="headerlink" title="八、用户自定义字面量"></a>八、用户自定义字面量</h1><ol>
<li>C++11中，允许声明一个后缀标识的操作符来表示某类的对象，将声明了改后缀标识符的字面量转化为需要的类型，以方便初始化时直接创建对象</li>
<li>声明该标识符的过程。即是重载<code>operator&quot;&quot;</code>来解析其中字符串获取参数的过程</li>
<li><p>由于创建的是临时对象，需要通过右值引用的方式操作</p>
<pre><code>struct RGB {
    unsigned int R;
    unsigned int G;
    unsigned int B;
};
</code></pre></li>
</ol>
<pre><code>/* C++98 fashion */
void blend(RGB&amp; c1, RGB&amp; c2);

RGB c1(1, 158, 255);
RGB c2(255, 199, 75);
blend(c1, c2);                                            //C++98中要先创建对象才能调用函数

/* C++98 fashion */
void blend(RGB&amp;&amp; c1, RGB&amp;&amp; c2);                            //通过右值引用来操作临时对象

RGB operator &quot;&quot; _C(const char* line, size_t n) {        //解析参数为一个长度n的字符串
    const char* p = line;
    const char* end = line + n;
    const char *r, *g, *b;
    r = g = b = nullptr;

    for (; p != end; ++p) {
        if (*p == &apos;r&apos;) r = p;
        else if (*p == &apos;g&apos;) g = p;
        else if (*p == &apos;b&apos;) b = p;
    }

    if ((r == nullptr)||(g == nullptr)||(b == nullptr))
        throw;
    else
        return RGB(atoi(r+1), atoi(g+1), atoi(b+1));    //返回一个临时对象
}

blend(&quot;r1, g158, b255&quot;_C, &quot;r255, g199, b7&quot;_C);            //C++11通过后缀标识在调用函数时直接创建临时对象，函数通过右值引用来操作
</code></pre><ol>
<li><p>可以将后缀标识符直接应用于数值</p>
<pre><code>struct weight { unsigned int t; };
weight operator &quot;&quot; _kg(unsigned long long t) {
    return (unsigned int)t;
}

weight Tom = 68_kg;
</code></pre><ul>
<li><p>一般规则：</p>
<ul>
<li>当字面量为整型时，<code>operator&quot;&quot;</code>的参数只能接受<code>unsigned long long</code>或者<code>const char*</code>。当<code>unsigned long long</code>无法容纳字面量的值，编译器自动转化为<code>\0</code>结尾的字符串，调用<code>const char*</code>参数的版本</li>
<li>当字面量为浮点时，只能接受<code>long double</code>或者<code>const char*</code>。规则同上。</li>
<li>当字面量为字符串时。只可接受<code>const char*、size_t</code>类型参数</li>
<li>如果为字符，则只接受char作参数</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li><code>operator &quot;&quot;</code>与用户定义后缀间必须有空格</li>
<li>后缀建议”<code>_</code>“开始，否则会被编译器警告</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="九、内联名字空间（个人感觉用处不大）"><a href="#九、内联名字空间（个人感觉用处不大）" class="headerlink" title="九、内联名字空间（个人感觉用处不大）"></a>九、内联名字空间（个人感觉用处不大）</h1><ol>
<li><p>C++标准不允许在不同的名字空间中特化模板</p>
<pre><code>namespace A {
    namespace B {
        template &lt;typename T&gt; class C1 { ... };
    }
}

namespace B {
    template &lt;&gt; class C1&lt;int&gt; { ... };        //特化失败，不在同一个名字空间
}
</code></pre></li>
<li><p>inline名字空间可以将某个名字空间的名称引入所在的名字空间</p>
<pre><code>namespace A {
    inline namespace B {                    //将B空间引入A空间
        template &lt;typename T&gt; class C1 { ... };
    }
}

namespace B {
    template &lt;&gt; class C1&lt;int&gt; { ... };        //特化成功
}
</code></pre></li>
<li><p>书上说内联名字空间主要就是为了解决此问题，不明白实用价值，库中通过预定义宏实现对不同代码的编译</p>
<pre><code>namespace A {
    #if __cplusplus == 201311L
        inline
    #endif
        namespace cpp11 {
            class C1;
        }

    #if __cplusplus &lt; 201311L
        inline
    #endif
        namespace oldcpp {
            class C1;
        }
    }

C1 c;        //取决于编译器版本
cpp11::C1;    //c++11
oldcpp::C1;    //c++98
</code></pre></li>
</ol>
<h1 id="十、定义别名"><a href="#十、定义别名" class="headerlink" title="十、定义别名"></a>十、定义别名</h1><ol>
<li><p>C++11允许使用using来定义别名，其用法与typedef一致</p>
<pre><code>typedef unsigned int uint
using uint = unsigned int;
</code></pre></li>
<li><p>using在模板中的应用更为灵活，可以接受模板参数，而typedef则不行</p>
<pre><code>template&lt;typename T&gt; using StrMap = std::map&lt;T, std::string&gt;;        //可以定义一个带模板参数的别名
StrMap&lt;int&gt; IntStrMap;
</code></pre></li>
</ol>
<h1 id="十一、一般化的SFINAE原则"><a href="#十一、一般化的SFINAE原则" class="headerlink" title="十一、一般化的SFINAE原则"></a>十一、一般化的SFINAE原则</h1><ol>
<li><p>SFINAE原则：匹配错误不失败，可以让编译器为模板寻求一个最佳和最特殊的匹配</p>
<pre><code>struct Test { typedef int INT; };
template &lt;typename T&gt; void f(typename T::INT) {}    //1
template &lt;typename T&gt; void f(T) {}                    //2

f&lt;Test&gt;(10);
f&lt;int&gt;(10);            //由于SFINAE，可以匹配到模板2上
</code></pre></li>
<li><p>C++11对SFINAE作出明确定义，可以支持表达式的情况，只要模板参数不出现“外部于表达式本身”的元素，比如发生实例化、隐式拷贝构造等情况，都算作SFINAE的范畴</p>
<pre><code>template&lt;int I&gt; struct A {};
char xxx(int);
char xxx(float);
template &lt;typename T&gt; A&lt;sizeof(xxx((T)0))&gt; f(T) {}

f(1);                //根据参数长度产生不同的f(T)返回值，如sizeof((int)0)、sizeof((float)0);
</code></pre></li>
</ol>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2016/05/28/阅读笔记-C-11新特性-三、通用为本-专用为末/" data-id="cir6jyn9t00bhnz639xny0jja" class="article-share-link">分享到</a><div class="tags"><a href="/tags/C-11新特性/">C++11新特性</a></div><div class="post-nav"><a href="/2016/05/28/开发环境搭建-Mac-SSH-密钥登陆/" class="pre">Mac SSH 密钥登陆</a><a href="/2016/05/28/Sip协议-sip阅读笔记/" class="next">sip阅读笔记</a></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C-C-经验累积/">C&C++经验累积</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Docker学习/">Docker学习</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux使用/">Linux使用</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux系统编程/">Linux系统编程</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux网络编程/">Linux网络编程</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Q-A/">Q&A</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Sip协议/">Sip协议</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux内核驱动与文件系统/">linux内核驱动与文件系统</a><span class="category-list-count">24</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/project-note/">project_note</a><span class="category-list-count">13</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/project-note/decode/">decode</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/project-note/think-about/">think_about</a><span class="category-list-count">4</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/开发环境搭建/">开发环境搭建</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂项/">杂项</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/">阅读笔记</a><span class="category-list-count">257</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/C-11新特性/">C++11新特性</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/C-Templates/">C++Templates</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/C程序设计语言/">C程序设计语言</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/EffectiveC/">EffectiveC++</a><span class="category-list-count">50</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/EffectiveSTL/">EffectiveSTL</a><span class="category-list-count">51</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/InsideC-ObjectModel/">InsideC++ObjectModel</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/Linux多线程服务器编程/">Linux多线程服务器编程</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/Linux性能优化大师/">Linux性能优化大师</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/Linux设备驱动程序/">Linux设备驱动程序</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/MoreEffectiveC/">MoreEffectiveC++</a><span class="category-list-count">26</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/TCPIP详解Vol1/">TCPIP详解Vol1</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/TheC-StandardLibraryEd1/">TheC++StandardLibraryEd1</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/TheC-StandardLibraryEd2/">TheC++StandardLibraryEd2</a><span class="category-list-count">23</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/http权威指南/">http权威指南</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/unix网络编程Ed3/">unix网络编程Ed3</a><span class="category-list-count">28</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/wireshark数据包分析实战/">wireshark数据包分析实战</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/实战LinuxShell编程与服务器管理/">实战LinuxShell编程与服务器管理</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/程序员的自我修养/">程序员的自我修养</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/网络安全基础/">网络安全基础</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/面向模式的软件体系结构Vol1/">面向模式的软件体系结构Vol1</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/高级C-C-编译技术/">高级C&C++编译技术</a><span class="category-list-count">2</span></li></ul></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Linux设备驱动程序/" style="font-size: 15px;">Linux设备驱动程序</a> <a href="/tags/C-C-经验累积/" style="font-size: 15px;">C&C++经验累积</a> <a href="/tags/Docker学习/" style="font-size: 15px;">Docker学习</a> <a href="/tags/Linux系统编程/" style="font-size: 15px;">Linux系统编程</a> <a href="/tags/Linux网络编程/" style="font-size: 15px;">Linux网络编程</a> <a href="/tags/Q-A/" style="font-size: 15px;">Q&A</a> <a href="/tags/Sip协议/" style="font-size: 15px;">Sip协议</a> <a href="/tags/linux内核驱动与文件系统/" style="font-size: 15px;">linux内核驱动与文件系统</a> <a href="/tags/开发环境搭建/" style="font-size: 15px;">开发环境搭建</a> <a href="/tags/杂项/" style="font-size: 15px;">杂项</a> <a href="/tags/阅读笔记/" style="font-size: 15px;">阅读笔记</a> <a href="/tags/decode/" style="font-size: 15px;">decode</a> <a href="/tags/think-about/" style="font-size: 15px;">think_about</a> <a href="/tags/C程序设计语言/" style="font-size: 15px;">C程序设计语言</a> <a href="/tags/C-11新特性/" style="font-size: 15px;">C++11新特性</a> <a href="/tags/InsideC-ObjectModel/" style="font-size: 15px;">InsideC++ObjectModel</a> <a href="/tags/C-Templates/" style="font-size: 15px;">C++Templates</a> <a href="/tags/Linux使用/" style="font-size: 15px;">Linux使用</a> <a href="/tags/Linux多线程服务器编程/" style="font-size: 15px;">Linux多线程服务器编程</a> <a href="/tags/EffectiveC/" style="font-size: 15px;">EffectiveC++</a> <a href="/tags/TCPIP详解Vol1/" style="font-size: 15px;">TCPIP详解Vol1</a> <a href="/tags/EffectiveSTL/" style="font-size: 15px;">EffectiveSTL</a> <a href="/tags/TheC-StandardLibraryEd1/" style="font-size: 15px;">TheC++StandardLibraryEd1</a> <a href="/tags/Linux性能优化大师/" style="font-size: 15px;">Linux性能优化大师</a> <a href="/tags/http权威指南/" style="font-size: 15px;">http权威指南</a> <a href="/tags/unix网络编程Ed3/" style="font-size: 15px;">unix网络编程Ed3</a> <a href="/tags/wireshark数据包分析实战/" style="font-size: 15px;">wireshark数据包分析实战</a> <a href="/tags/实战LinuxShell编程与服务器管理/" style="font-size: 15px;">实战LinuxShell编程与服务器管理</a> <a href="/tags/程序员的自我修养/" style="font-size: 15px;">程序员的自我修养</a> <a href="/tags/网络安全基础/" style="font-size: 15px;">网络安全基础</a> <a href="/tags/面向模式的软件体系结构Vol1/" style="font-size: 15px;">面向模式的软件体系结构Vol1</a> <a href="/tags/高级C-C-编译技术/" style="font-size: 15px;">高级C&C++编译技术</a> <a href="/tags/TheC-StandardLibraryEd2/" style="font-size: 15px;">TheC++StandardLibraryEd2</a> <a href="/tags/MoreEffectiveC/" style="font-size: 15px;">MoreEffectiveC++</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/07/23/linux内核驱动与文件系统-内核学习之no-stack-function/">内核学习之no-stack-function</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/17/开发环境搭建-systemtap磨难记-ubuntu1404/">systemtap磨难记(ubuntu1404)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/11/开发环境搭建-ubuntu-server-14-04LTS-64-bit-安装systemtap/">ubuntu_server_14.04LTS(64 bit)安装systemtap</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/08/阅读笔记-Linux多线程服务器编程-第十二章-C-经验谈/">第十二章 C++经验谈</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/08/阅读笔记-Linux多线程服务器编程-第十二章-补充：链接顺序与优先级/">第十二章 补充：链接顺序与优先级</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/04/开发环境搭建-ubuntu-server15-10安装systemtap/">ubuntu_server15.10安装systemtap</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/03/开发环境搭建-扩展虚拟机硬盘容量/">扩展虚拟机硬盘容量</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/03/阅读笔记-Linux多线程服务器编程-第十一章-反思C-对象与虚函数/">第十一章 反思C++对象与虚函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/23/阅读笔记-Linux多线程服务器编程-第十章-补充：ODR原则/">第十章 补充：ODR原则</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/21/阅读笔记-Linux多线程服务器编程-第十章-C-编译链接模型精要/">第十章 C++编译链接模型精要</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://easy.ac.cn/" title="easy" target="_blank">easy</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">dupengair的blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>