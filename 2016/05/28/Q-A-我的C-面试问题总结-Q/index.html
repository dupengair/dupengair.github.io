<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="keep it simple, stupid"><title>我的C++面试问题总结_Q | dupengair的blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/3.0.3/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">我的C++面试问题总结_Q</h1><a id="logo" href="/.">dupengair的blog</a><p class="description">日拱一卒 精而悟道</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">我的C++面试问题总结_Q</h1><div class="post-meta">May 28, 2016<span> | </span><span class="category"><a href="/categories/Q-A/">Q&amp;A</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div></div></div><div class="post-content"><pre><code>序号    一级标签    二级标签    问题
1    基础语法    operators    赋值操作符中返回this的引用有什么用？
2    基础语法    operators    如何通过赋值操作符阻止连续赋值？
3    基础语法    operators        指出bug：
                            const Rational&amp; operator* (const Rational&amp; lhs, const Rational&amp; rhs)
                                {
                                    Rational* result = new Rational( lhs.n * rhs.n, lhs.d * rhs.d ); 
                                    return *result;                        
                                }    


                            Rational w, x, y, z;
                            w = x * y * z;            
4    基础语法    operators    指出bug，并说明可以得出什么结论？
                            const Rational&amp; operator* (const Rational&amp; lhs, const Rational&amp; rhs)
                            {
                                static Rational result; 
                                result = ……;      //用lhs* rhs的结果来初始化这个static对象 
                                return result;                        
                            }    
                          //重载operator==
                            bool operator==(const Rational&amp; lhs, const Rational&amp; rhs);    
                            Rational a, b, c, d;

                            if( (a * b) == (c * d))        
                            {
                                ……        // ab与cd的乘积相等时
                            }
                            else
                            {
                                ……        // ab与cd的乘积不等时

5    模板    参数    非类型参数不同的两个模板能相互赋值吗？
                如：
                bitset&lt;32&gt; flag1;
                bitset&lt;16&gt; flag2;
                flag1 = flag2; //正确吗？why？
6    模板    基础    当class template的 member function 也是一个template时，有什么限制？ 
7    基础语法    隐式类型转换        指出这个有理数类的3个操作是否正确，要实现这些操作应如何修改，结论是什么：
                                class Rational {
                                public:
                                    Rational(int numerator = 0, int denominator = 1);
                                    int numerator() const;
                                    int demoninator() const;

                                    const Rational operator* (const Rational&amp; rhs) const;
                                };

                                      // 操作
                                Rational oneEighth(1, 8);
                                Rational oneHalf(1, 2);
                                Rational result = oneEighth * oneHalf;        // 1
                                result = oneHalf * 2;                                          // 2
                                result = 2 * oneHalf;                                          // 3
8    基础语法    转型    请指出bug，应如何改正？
                    class Window {
                        public:
                            virtual void onResize() { ... }                
                            ...
                        };
                        class SpecialWindow: public Window {
                        public:
                            virtural void onResize() {                
                                static_cast&lt;Window&gt;(*this).onResize();        
                                ...                        
                            }
                            ...
                        }

9    基础语法        请指出bug
                class Rectangle {                //矩形class    
                        ...
                    public:
                        const Point&amp; upperLeft() const { return pData-&gt;ulhc; }    
                        const Point&amp; lowerRight() const { return pData-&gt;lrhc; }    
                        ...
                    };

                const Rectangle boundingBox();        
                const Point* pUpperLeft = &amp;(boundingBox().upperLeft());

10    异常    异常安全    请指出bug，应如何改正？请谈谈什么是异常安全性？
                    void PrettyMenu::changeBackground(std::istream&amp; imgSrc)
                    {
                        lock(&amp;mutex);                //线程保护
                        delete bgImage;                //删除旧背景图案
                        ++imageChanges;                //改变状态
                        bgImage = new Image(imgSrc);        //更新背景图案
                        unlock(&amp;mutex);                
                    }
11    基础语法    inline    inline的优缺点？哪些情况不能inline？
12    基础语法    explicit    根据class定义指出下列操作的正确性：
                            class Stack {
                            public:
                                explicit Stack(int size);
                            };

                            1. Stack s(40);
                            2. Stack s = 40;
                            3. Stack s; s = 40;
13    基础语法    转型    当dynamic_cast的参数是引用时，如果转型失败，会发生什么？
14    基础语法    动态绑定    什么是动态绑定？含义是什么？在继承上什么是动态绑定的什么是静态绑定的？
15    基础语法    继承    private继承的class是否具有多态的性质？private继承的用处是什么？缺点？如何用更好的设计方式来避免直接private继承？
16    模板    typename    请指出bug，应如何改正？
                        template&lt;typename T&gt;
                        void print2nd(const T&amp; container)
                        {
                                if (container.size() &gt;= 2) {
                                    T::const_iterator iter(container.begin());        
                                    ++iter;
                                    int value = *iter;
                                    std::cout &lt;&lt; value;
                                }
                        }

17    模板    访问控制    指出下面程序问题，如何修改？
                    1、提供具体操作的普通类型:
                        class CompanyA {
                        public:
                            void sendCleartext(const std::string&amp; msg);
                            void sendEncrypted(const std::string&amp; msg);
                        };

                        class CompanyB { … }；// 类似

                        2、使用这些普通类型的基类模板:
                        template&lt;typename Company&gt;
                        class MsgSender {
                        public:
                            void sendClear()        //发送cleartext的统一接口
                            {
                                std::string msg;
                                Company c;
                                c.sendCleartext(msg);
                            }
                            void sendSecret()    { … }；// 类似
                        };

                        3、增加log功能的派生类模板:
                        template&lt;typename Company&gt;
                        class LogMsgSender : public MsgSender&lt;Company&gt; {
                        public:
                            void sendClearMsg()        //在send操作前增加log操作
                            {
                                log 操作;
                                sendClear();
                            }
                            void sendSecretMsg()    { … }；// 类似
                        };    
18    模板    参数类型    下面的template会引起代码膨胀，请解释原因并做合理优化：
                        template&lt;typename T, std::size_t n&gt;            //支持n阶矩阵的template
                        class SquareMatrix {
                        public:
                            ……
                            void invert();            //矩阵求逆操作
                        };

                        实例化：
                        SquareMatrix&lt;double, 5&gt; sm1;            
                        sm1.invert();                    

                        SquareMatrix&lt;double, 10&gt; sm2;            
                        sm2.invert();    
19    模板    转型    请定义一个类模板，实现派生类到基类的转换，如下：
                //定义一个智能指针类模板    
                template&lt;typename T&gt;
                class SmartPtr {
                public:
                    explicit SmartPtr(T* realPtr);        //以内置原始指针完成初始化
                    ……
                };

                //我们希望能够这样：
                SmartPtr&lt;Top&gt; pt1 = SmartPtr&lt;Middle&gt;(new Middle);    //将SmartPtr&lt;Middle&gt;转换为SmartPtr&lt;Top&gt;
                SmartPtr&lt;Top&gt; pt2 = SmartPtr&lt;Bottom&gt;(new Bottom);    //将SmartPtr&lt;Bottom&gt;转换为SmartPtr&lt;Top&gt;
                const SmartPtr&lt;Top&gt;pct2 = pt1;        //将SmartPtr&lt;Top&gt;转换为SmartPtr&lt;const Top&gt;
20    模板    友元    请指出模板应用的问题,应如何修改该模板定义？
                template&lt;typename T&gt;
                 class Rational {
                 public:
                  Rational(const T&amp; numerator = 0, const T&amp; denominator = 1);
                  const T numerator() const;
                  const T demoninator() const;
                  …
                 };

                 //non-member函数
                 template&lt;typename T&gt;
                 const Rational&lt;T&gt; operator* (const Rational&lt;T&gt;&amp; rhs, const Rational&lt;T&gt;&amp; rhs)
                 {……}

                 //应用
                 Rational&lt;int&gt; oneHalf(1, 2);    
                 Rational&lt;int&gt; result = 2 * oneHalf;   

21    基础语法    new    C++ 的operate new 对0内存申请会有什么处理？
22    基础语法    new    operator new什么情况下抛出bad_alloc异常？
23    基础语法    new    编写operator new的要点
24    基础语法    new    编写new_handler的要点
25    基础语法    new    使用new时什么情况下会产生异常？分别会引起什么后果？
26    基础语法    new    如果定义了placement new没有定义对应的placement delete会造成什么后果？为什么？
27    基础语法    operators    前缀和后缀式的++、--有什么区别？
28    基础语法    引用与指针    reference与pointer的区别
29    基础语法    多态    下面程序会输出什么结果？为什么不能否以多态的方式操作数组？
                     class BST { … };
                     class BalancedBST: public BST { … };

                     void printBSTArray( ostream &amp;s, const BST array[], int numElements )
                     {
                      for ( int i = 0; i &lt; numElements; ++i ) {
                       s &lt;&lt; array[i];
                      }
                     }
                     void deleteArray(ostream&amp; logStream, BST array[])
                     {
                      delete [] array;
                     }

                     BalancedBST BSTArray[10];
                     printArray(cout, BSTArray, 10); 

                     BalancedBST *baiTreeArray = new BalancedBST[10];
                     deleteArray(cout, baiTreeArray); 
30    基础语法    构造与析构    缺乏default constructor在哪些应用场合下会带来不便？可以如何解决？
31    基础语法    隐式类型转换    哪些方法可使一个类能够隐式类型转换，有何差异？
32    基础语法    隐式类型转换    要限制构造函数导致隐式转换的发生，除了声明explicit关键字，还能怎么做？
                            如：
                            template&lt;class T&gt;
                             class Array {
                             public:
                              Array(int size);
                              T&amp; operator[](int index);
                              …
                             }；
33    基础语法        请指出下面程序运行会有什么结果，并说明后缀自增符实现时需要注意什么？
                    UPInt UPInt::operato++ (int)  //返回值应为const
                      {
                       UPInt old = *this;
                       ++(*this);
                       return old;
                      }

                      UPInt i;
                      i++++;
34    STL    pair    下面的pair定义有何不同？
                    std::pair&lt;int, float&gt;(42, 72.77); 
                    std::make_pair(42, 72.77);     
35    基础语法    智能指针    如下的函数调用会发生什么？原因？
                        void bad_print(std::auto_ptr&lt;T&gt; p) //函数定义
                        {
                           ...
                        }

                        std::auto_ptr&lt;int&gt; ptr1(new int);
                        *ptr1= 42；
                        bad_print(ptr1);
                        *ptr1= 43；
36    基础语法    智能指针    通过reference获得auto_ptr是否是好的设计？为什么？
37    基础语法    操作符重载    哪些操作符一定不能重载？为什么？
38    基础语法    new    请区别以下new表达式，并说明应如何应用：
                    1. new operator
                    2. operator new
                    3. placement new
38    基础语法    构造与析构    指出下面程序如果在构造函数发生异常，会有什么后果？应如何修改？
                            class Image;
                            class AudioClip;

                            class BookEntry {
                            public:
                                BookEntry(const string&amp; name);
                                ~BookEntry();
                            private:
                                string theName;
                                Image *theImage;
                                AudioClip *theAudioClip;
                            };

                            BookEntry::BookEndtry(const stirng&amp; name):theName(0)
                            {
                                if(name != &quot;&quot;&quot;&quot;)
                                    theImage = new Image(name);
                                if(name != &quot;&quot;&quot;&quot;)
                                    theAudioClip = new AudioClip(name);
                            }

                            ~BookEntry::BookEndtry()
                            {
                                delete theImage;
                                delete theAudioClip;
                            }
39    基础语法    构造与析构    当一个exception的执行过程中调用了一个destructor，在其中又抛出了exception，会发生什么后果？
40    异常    throw    下面两个exception throw有何区别？哪一种更好？
                    catch (Widget&amp; w)
                        {
                            ...
                            throw;        
                        }

                        catch (Widget&amp; w)
                        {
                            ...
                            throw w;    
                        }

41    异常    catch    exception catch时可能出现哪些类型转换？
42    异常    catch    请解释以by value、by pointer、by reference三种方式捕获异常有什么不同？那种最佳？
43    异常    异常说明    template中是否可以使用exception specification？why？
44    异常    异常说明    如何处理非预期的exceptions，使其不影响程序运行？
45    异常    异常说明    如果unexpected函数重新抛出当前产生的非预期异常，会导致什么结果？
46    异常    异常说明    请说明exception specification的局部性校验
47    基础语法    智能指针    const auto_ptr 的语义能修改什么？不能修改什么？
48    基础语法    operators    运算操作符的复合形式和独身形式哪个效率更高？why？
49    基础语法    继承    当derived class重新定义base class的一个虚函数时，函数声明可以有什么不同？
50    基础语法    构造与析构    下面代码会输出什么？为什么？
                            class A {
                              public:
                              A() { test_vt() };   
                              virtual void test_vt() { cout &lt;&lt; &quot;&quot;this is base Class ctor&quot;&quot; &lt;&lt; endl; };
                              };
                             class B: public A {
                              public:
                              virtual void test_vt() { cout &lt;&lt; &quot;&quot;this is derived Class ctor&quot;&quot; &lt;&lt; endl; }; 
                              };

                             B b;  
51    基础语法    IO流    IO操作符是否能作成员函数？Why？
52    基础语法        C中NULL定义为(void *)0,在C++中这样定义正确吗？为什么？
53    基础语法        函数static 与 class static 有什么不同？哪个更好？
54    基础语法    基础    什么情况下一个类不可以做基类？
55    基础语法    new    请指出下面程序运行是否异常安全？为什么？应如何改正？
                    /*声明*/
                    int priority();
                    void processWidget(boost::shared_ptr&lt;Widget&gt; pw, int priority);

                    /*调用*/
                    processWidget((boost::shared_ptr&lt;Widget&gt;)(new Widget), priority());
56    STL    容器    关联容器中是否可以使用push_back()和pop_front()之类的操作，为什么？
57    STL    迭代器    下面两个迭代器的遍历方式有什么区别？
                for(pos = coil.begin(); pos != coil.end(); ++pos)
                for(pos = coil.begin(); pos &lt; coil.end(); ++pos)
58    STL    迭代器    请指出下面程序的运行结果并且解释：
                list&lt;int&gt; coll;
                for(int i=20; i&lt;=40; i++) { coll.push_back(i); }

                list&lt;int&gt;::iterator pos25 pos35;
                pos25 = find(coll.begin(), coll.end(), 25);
                pos35 = find(coll.begin(), coll.end(), 35);

                std::cout&lt;&lt; &quot;&quot;max(25, 35) = &quot;&quot; &lt;&lt; *max_element(pos25, pos35) &lt;&lt; endl;
59    基础语法    智能指针    下面的操作合理吗？应如何改正？
                            void printWidget(auto_ptr&lt;Widget&gt; p) { … }
                            auto_ptr&lt;Widget&gt; pw (new Widget);
                            printWidget（pw）；
                            pw-&gt;XXX();
60    STL    算法    请说明下面程序结果，并说明反映了STL什么样的设计思想？
                list&lt;int&gt; coll;
                for(int i=1; i&lt;=6; i++) { coll.push_back(i); }
                remove(coll.begin(), coll.end(), 3);
                copy(coll.begin(), coll.end(), ostream_interator&lt;int&gt;(out), &quot;&quot; &quot;&quot;);
61    STL    容器    STL容器元素有什么要求？
62    STL    容器    怎样缩小一个vector容量？可以用reserve()吗？
63    STL    容器    怎么替换一个map的key？
64    STL    容器    下面从map删除元素有什么问题：
                for(std::map&lt;T&gt;::iterator iter = map1.begin(); iter != map1.end();++pos)
                {
                      map1.erase(pos);
                }
65    STL    容器    map的insert成员函数与下表操作插入元素，有什么不同？
66    STL    容器    下面插入map的做法有什么问题？
                 coll.insert(std::pair&lt;std::string, float&gt;(&quot;&quot;otto&quot;&quot;, 1));
67    STL    容器    解释下面迭代器出错原因，应如何改正：
                std::vector&lt;int&gt; coil;
                ......
                if(coil.size() &gt; 1)
                {
                   sort(++coil.begin(), coil.end());
                }
68    模板    参数类型    指出下列错误产生的原因，并提供至少2种办法解决：
                    template&lt;typename T&gt;
                    T const&amp; max(T const&amp; a, T const&amp; b);
                    ...
                    max(4, 4.7)      //error
69    模板    参数类型    哪些类型不能做template非类型参数？
70    模板    参数类型    请说明下面程序结果，并说明原因？
                    template &lt;typename T&gt;
                    void ref(T const&amp; x) { cout&lt;&lt;&quot;&quot;ref type(T const&amp; x) : &quot;&quot;&lt;&lt;typeid(x).name()&lt;&lt;endl; }
                    template &lt;typename T&gt;
                    void nonref(T x) { cout&lt;&lt;&quot;&quot;nonref type(T x) : &quot;&quot;&lt;&lt;typeid(x).name()&lt;&lt;endl; }

                    main()
                    {
                    ref(&quot;&quot;hello&quot;&quot;);
                    nonref(&quot;&quot;hello&quot;&quot;);
                    }
71    基础语法        什么时候类无法生成默认赋值运算符？
72    模板    友元    请说明下面这个模板的实例化结果，并说明如何在模板内部定义友元：
                template&lt;typename T&gt;
                class Creator {
                    friend void appear() {}
                }
                Creator&lt;void&gt; obj1; 
                Creator&lt;void&gt; obj2; 
73    模板    名称查找    请说明下面程序结果，并解释:
                       namespace X {
                            template&lt;typename T&gt;void f(T);
                            }

                        namespace N {
                            using namespace X;
                            enum E { e1 };
                            void f(E) { cout &lt;&lt; &quot;&quot;N::f(N::E) called&quot;&quot; &lt;&lt;endl; }
                            }

                        void f(int){
                            cout &lt;&lt; &quot;&quot;::f(int) called&quot;&quot; &lt;&lt; endl;             
                            } 

                        int main(void)
                        {
                            ::f(N::e1);
                            f(N::e1);

                            return 0;
                        }

74    模板    名称查找    请说明下面程序运行结果：
                    template &lt;typename T&gt;
                    class C {
                        …
                        friend void f();
                        friend void f(C&lt;T&gt; const&amp;);
                    };

                    void g(C&lt;int&gt;* p)
                    {
                        f();         //
                        f(*p);       //
                    }&quot;
                    75    模板    typename    &quot;typename用法辨析：
                    template&lt;typename1 T&gt;
                    class S: typename2 X&lt;T&gt;::Base {
                        S(): typename3 X&lt;T&gt;::Base( typename4 X&lt;T&gt;::Base(0) ) { }
                        typename5 X&lt;T&gt; f() {
                            typename6 X&lt;T&gt;::C *p;
                            X&lt;T&gt;::D* q;
                            }
                        typename7 X&lt;int&gt;::C* s;
                    };

                    class U {
                        typename8 X&lt;int&gt;::C* pc;
                    };
76    模板    名称查找    指出下面的错误，说明原因并修改：
                    namespace N {
                        class X {
                        public: int a;
                        };

                        template&lt;int I&gt;void select(X*) { cout &lt;&lt; I &lt;&lt; endl; }        
                    }

                    void g(N::X* xp)
                        {
                        select&lt;3&gt;(xp); 
                        }
77    模板    名称查找    请指出下面运行过程的问题，说明原因：
                    //template definition
                    template &lt;typename X&gt;
                    class Base {
                    public:
                        int basefield;
                        typedef int T;
                    };

                    class D1: public Base&lt;void&gt; {           
                        public:
                            void f() { basefield = 3; }
                    };

                    template &lt;typename T&gt;
                    class D2: public Base&lt;void&gt; {           
                        public:
                            void f() { basefield = 7; }
                            T strange;                      
                    };

                    //execute, may have error:
                    void g(D2&lt;int*&gt;&amp; d2, int* p)
                    {
                        d2.strange = p;                     
                    }
78    基础语法        怎样判断vptr在对象中的位置？
79    基础语法        一下几个取地址操作有何不同？
                    class A { 
                    public: 
                        char x; 
                        static int y;
                    };

                   A a;
                   &amp;A::x;   //1.
                   &amp;A::y;   //2.
                   &amp;a.x;    //3.
80    模板    实例化    请指出下列代码位置需要模板声明还是定义，并说明理由：
                template &lt;typename T&gt; class A; //声明
                template &lt;typename T&gt; class A { public: void f(); }; //定义

                A&lt;int&gt;* pa = NULL;                    //1.
                pa = new A&lt;int&gt;;                      //2.

                void func(A&lt;int&gt;&amp; rfa) {              //3.
                    rfa.f();                          //4.
                }
81    模板    实例化    请指出下列函数模板1和类模板2的实例化POI点分别在(1)(2)(3)(4)的哪一处：
                template&lt;typename T&gt; func(T t) {}
                template&lt;typename T&gt; class A { … };
                (1)
                void test() {
                       (2)
                       func&lt;int&gt;(1);     //1
                       sizeof(A&lt;int&gt;);   //2
                       (3)
                }
                (4)
82    模板    实例化    请指出下列函数模板3和类模板12的实例化POI点123分别在(1)(2a)(2b)的哪一处：
                template&lt;typename T&gt; class A { public: typedef int Int; };

                template&lt;typename T&gt; func() {
                    A&lt;int&gt;::Int v1 = 1;             //1 非依赖型名称，不能用typename
                    typename A&lt;T&gt;::Int v2 = 2;      //2
                }
                (1)
                int main() {
                    func&lt;double&gt;();                 //3 
                }
                (2a)
                (2b)
83    模板    实例化    请指出模板实例化时的问题，并修改：
                template&lt;typename T&gt;  
                inline const T&amp; max( const T&amp; a, const T&amp; b) {   
                       return a &gt; b ? a : b;
                }

                max(&quot;&quot;abc&quot;&quot;, &quot;&quot;def&quot;&quot;);      //1
                max(&quot;&quot;abc&quot;&quot;, &quot;&quot;abcd&quot;&quot;);     //2 
84    模板    实例化    请指出下列模板实例化后类型参数T的类型：
                template&lt;typename T&gt; void f(T);   
                template&lt;typename T&gt; void g(T&amp;);  
                double x[20];
                const int y = 1;

                f(x);                              //1
                g(x);                              //2
                f(y);                              //3
                g(y);                              //4
                f(1);                              //5
                g(1);                              //6
85    模板    实例化    请指出下列模板实例化后各类型参数T的类型：
                template&lt;typename T&gt; void f1(T*);
                template&lt;typename T, int N&gt; void f2(T(&amp;)[N]);
                template&lt;typename T1, typename T2, typename T3&gt; void f3(T1 (T2::*)(T3*));

                int ***p1;
                bool p2[2];
                class p3 { void f(double*); };

                f1(p1);    //1
                f2(p2);    //2
                f3(&amp;p3::f);//3
86    模板    实例化    模板参数匹配接受哪些转换？
87    模板    参数推导    模板参数类型推导是否可运用于函数模板和类模板？
88    模板    友元    请指出下列12处正确或错误，并说明原因
                class A{};
                template&lt;typename T&gt;
                class B {
                public:
                    B(T t) {}
                    friend void f(const B&lt;T&gt;&amp; b) {}
                }

                A a;
                B&lt;A&gt; b(a);
                f(b);               //1
                f(a);               //2
89    模板    实例化    请指出下列实例化了哪个模板定义？
                template&lt;typename T&gt;int f(T){ return 1; }     //1
                template&lt;typename T&gt;int f(T*){ return 2; }    //2

                cout &lt;&lt; f&lt;int*&gt;((int*)0) &lt;&lt;endl;               //
                cout &lt;&lt; f&lt;int&gt;((int*)0) &lt;&lt;endl;                //
90    模板    重载与特化    请指出下列模板的输出结果：
                        template&lt;typename T&gt; void f(T t) { cout &lt;&lt; &quot;&quot;template&quot;&quot; &lt;&lt; endl; }
                        void f(int t) { cout &lt;&lt; &quot;&quot;non-template&quot;&quot; &lt;&lt; endl; }

                        f(1);       //1
91    模板    重载与特化    模板重载与特化的区别？
92    模板    重载与特化    指出下列模板实例化的哪个定义?
                        template&lt;typename T, typename U = int&gt; class A {...};    //原模板定义
                        template&lt;&gt; class A&lt;char&gt; {...};                          //模板特化

                        A&lt;int&gt; a1;            //实例化原模板定义
                        A&lt;char&gt; a2;           //实例化模板特化
                        A&lt;char, int&gt; a3;      //实例化模板特化
                        A&lt;char, char&gt; a4;     //实例化原模板定义
93    模板    重载与特化    指出下列模板特化和实例过程中的错误：
                        //file1
                        template&lt;typename T&gt; 
                        class A { public: enum { MAX = 10}; };             //原模板定义
                        char buffer[A&lt;void&gt;::MAX];                         //实例化
                        extern void clear(const char*);
                        int main() {  clear(buffer); }                     //主程序

                        //file2
                        template&lt;typename T&gt; class A;                      //声明
                        template&lt;&gt; class A&lt;void&gt; {                         //特化为void类型
                             public: 
                                    enum { MAX = 100}; 
                        };
                        void clear(const char* buf) {
                            for(int i=0; i &lt;  A&lt;void&gt;::MAX; ++i)           
                                buf[i] = &apos;\0&apos;;
                        }
94    基础语法    多态    运行期多态和编译期多态的优点
95    基础语法    隐式类型转换    指出下面两个类型转换的区别：
                            X x;
                            Y y(x);       // 1.
                            Z z = x;      // 2.
                            96    异常    throw    &quot;下面两种抛出异常的方式有什么区别，哪种更合理？
                             catch (Widget&amp; w)
                             {
                              ...
                              throw;  // 1.
                             }

                             catch (Widget&amp; w)
                             {
                              ...
                              throw w; // 2.
                             }
97    基础语法    函数重载    请指出下面main函数中会输出什么错误：
                            class Calc {
                            public:
                             string Twice(string);  // 1.
                            private:
                             char* Twice(char*);    // 2.
                             };

                            int main() {
                             c.Twice(&quot;&quot;hello&quot;&quot;);      
                            }
98    基础语法        请指出下面定义中cstr的类型：
                    typedef string* pstr;
                    const pstr cstr;
99    基础语法    new    如果自定义new没有对应delete会有什么后果？
100    模板    名称查找    请指出下面程序的问题：
                        namespace N {
                        struct X{};
                        template&lt;typename T&gt; int* operator+(T, unsigned) { cout&lt;&lt;&quot;&quot;error&quot;&quot;&lt;&lt;endl; }
                        }

                        int main() {
                        std::vector&lt;N::X&gt; v(5);
                        v[1];                       // 1
                        }
101    STL    仿函数    定义接受仿函数的函数的最佳做法
102    模板        模板实参允许哪些类型转换？
103    模板        说明下面程序的错误，应该如何改正：
                //std::list的声明：
                namespace std { template &lt;typename T, typename Allocator = allocator&lt;T&gt; &gt; class list; }
                //类定义，最后一个参数接受一个容器 
                template &lt;typename T1, typename T2, template&lt;typename&gt; class Container&gt; class Relation { … };
                //实例化
                Relation&lt;int,double,std::list&gt; rel;

104    模板    名称解析    请指出下面的g()绑定到哪个函数？
                        Void g(double); //#1
                        template&lt;typename T&gt; void f(){ g(1); }
                        void g(int); //#2
                        int main()
                        {
                            f&lt;int&gt;();
                        }
105    模板    友元    请指出下面程序的错误：
                void combine(int, int);
                template&lt;typename T1, typename T2&gt; void combine(T1, T2);
                class Mixer {
                   …
                    friend void combine(int, int) {...} //#1
                    friend void ::newcombine(int, int) //#2
                    friend void combine&lt;&gt;(long, long) {...} //#3
                    friend void combine&lt;&gt;(char, char); //#4


                };
106    模板    友元    下面程序有什么问题？因如何修改？
                template&lt;typename T&gt;
                class Creator {
                    friend void appear() {}
                }
                Creator&lt;void&gt; obj1; 
                Creator&lt;double&gt; obj2
107    模板    友元    下面程序有什么问题？
                template&lt;typename T&gt;
                class C {
                    friend void f()；
                    friend void f(C&lt;T&gt; const&amp;);
                }
                void g(C&lt;int&gt;* p) {
                    f();    // #1
                    f(*p)   // #2
                }
108    模板        请说出下面的调用有什么错误？
                template &lt;typename X&gt;
                class Base {
                public:
                    int basefield;
                    typedef int T;
                };

                template &lt;typename T&gt;
                class D2: public Base&lt;double&gt; {         
                    public:
                        void f() { basefield = 7; }
                        T strange;                      // T 取自基类int，而不是派生类
                };

                void g(D2&lt;int*&gt;&amp; d2, int* p)
                {
                    d2.strange = p;                     
                }
109    设计模式    模式    请写出一个工业级的单例模式，并详细解释。提高单例模式性能的办法？
110    STL    智能指针    下面语句有什么问题？应如何修改？ 
                    std::unique_ptr&lt;int&gt; up = new int; 
111    STL    智能指针    下面语句有什么问题？应如何修改？ 
                    std::unique_ptr&lt;int&gt; up（new int）;
                    std::unique_ptr&lt;int&gt; up1（up）;
112    C++11    智能指针    C++11是否支持auto_ptr? Why? 
113    基础语法    隐式类型转换    隐式类型转换通常发生在什么时候？下面程序有什么问题？
                            void uppercast(string&amp; str);
                            char subtleBook[] = &quot;&quot;effective c++&quot;&quot;;
                            uppercast(subtleBook);   
114    基础语法    operators    下面程序有什么问题？
                            const MyClass operator+(const int&amp; lhs, const int&amp; rhs);

115    基础语法    临时对象    命名对象和临时（匿名）对象有什么区别？那个更好？
116    C++11    Range based for    下面程序有什么问题：
                                list&lt;int&gt; coll;
                                for(auto elem : coll) {    // clear list
                                    elem = 0;
                                }
117    STL    迭代器    容器支持随机访问的含义是什么？容器提供随机访问迭代器意味什么？
118    STL    容器    引起Vector迭代器失效的情况有哪些？
119    STL    容器    关联式容器与序列式容器在改变元素值上有什么不同？
120    STL    容器    关联式容器定义排序准则有什么特点？好处是什么？有几种定义方式？
121    C++11    nullptr    C++11定义的nullptr代表什么？类型是什么？为什么要这样定义？下面的调用分别是哪个函数？
定义：
                    f(int)
                    f(void*)

                    调用：
                    f(0);  
                    f(NULL); 
                    f(nullptr); 
                    122    STL    String    下面两句的执行结果，可能有什么不同：
                    basename = filename.substr(0, filename.find(&apos;.&apos;)); \\ 1
                    basename = filename.substr(filename.find(&apos;.&apos;));    \\2

123    STL    String    请指出下面各字符串长度，why
                   string s1(&quot;&quot;nico&quot;&quot;);
                   string s2(&quot;&quot;nico&quot;&quot;, 5);
                   string s3(5, &apos;\0&apos;);

                   s1.length(); 
                   s2.length(); 
                   s3.length(); 
124    STL    String    下面的构造函数是否正确？
                   string s(&apos;x&apos;);  
                   string s(1, &apos;x&apos;); 
                   string s({&apos;x&apos;}); 
125    STL    String    下面程序有什么问题？
                 string s=&quot;&quot;abcd&quot;&quot;;
                 const char* p = s.c_str();
                 void foo(cosnt char*);
                 foo(p); 
                 s += &quot;&quot;efg&quot;&quot;;  
                 foo(p);   
126    STL    String    下面代码有什么风险？
                    string s=&quot;&quot;abcd&quot;&quot;;
                    char* p = &amp;s[2];
                    char&amp; q = s[3];
                    *p = &apos;e&apos;; 
                    q = &apos;f&apos;; 
                    s += &quot;&quot;efg&quot;&quot;; 
                    *p = &apos;e&apos;; 
                    q = &apos;f&apos;; 
127    STL    通用概念    下面两种include的方式有什么区别？
                    #include&lt;Cstdlib&gt;
                    #include&lt;stdlib.h&gt;
128    STL    智能指针    下面的程序有什么问题 ？应如何修改？
                    shared_ptr&lt;string&gt; pStr = new string(&quot;&quot;hello&quot;&quot;);
129    STL    智能指针    下面两条语句有什么区别？哪条更好？
                    shared_ptr&lt;string&gt; pStr = make_shared&lt;string&gt;(&quot;&quot;hello&quot;&quot;);  
                    shared_ptr&lt;string&gt; pStr(new string(&quot;&quot;hello&quot;&quot;));   
130    STL    智能指针    下面的程序有什么问题 ？应如何修改？
                    shared_ptr&lt;string&gt; pStr;
                    pStr = new string(&quot;&quot;hello&quot;&quot;); 
131    STL    算法    请说明下面程序的运行结果，并说明原因？
                class Elem {
                   private:
                    int intv;
                    int count; 
                   public:
                    Elem(int n): intv(n), count(0) {}
                    bool operator() (int) {
                     return ++count == intv;  
                    }
                   };

                   list&lt;int&gt; coll = {1, 2, 3, 4, 5, 6, 7, 8};
                   list&lt;int&gt;::iterator pos = remove_if(coll.begin(), coll.end(), Elem(3));
                   coll.erase(pos, coll.end());  

132    C++11    Lambda    请说明Lambda函数与函数对象各有什么优缺点？
133    C++11    nullptr    请说明下面程序的运行结果，并说明原因？
                    Std::string s(NULL); //建立空字符串
134    基础语法    const    下面的const用法中，请指明错误：
                        int a = 10;
                        const int * p = &amp;a;     
                        *p = 5;     //
                        p = &amp;b;     //

                        int * const p = &amp;a;     
                        *p = 5;     //
                        p = &amp;b;     //

                        std::vector&lt;int&gt;vec;
                        const std::vector&lt;int&gt;::interator iter = vec.begin();   
                        ++iter;     //
                        *iter = 10; //

                        const_iterator
                        std::vector&lt;int&gt;::const_iterator iter = vec.begin();
                        ++iter;     //
                        *iter = 10; //


135    基础语法    构造与析构    为什么说初始化列表的效率比构造函数体中初始化效率更高？那些情况下必需要使用初始化列表？
136    高级语法    返回值优化    比较下面两段代码，请说明第一段代码采用什么优化手段？
                             template&lt;class T&gt;
                             const T operator+(const T&amp; rhs, const T&amp; lhs)
                             {
                              return T(lhs) += rhs;    
                             } 


                             template&lt;class T&gt;
                             const T operator+(const T&amp; rhs, const T&amp; lhs)
                             {
                              T result(lhs)；     
                              return result += rhs;
                             }
137    STL    vector/string    请说出下面语句的作用：
                        class Contestant {...};
                        vector&lt;Contestant&gt; contestants; 
                        vector&lt;Contestant&gt;(contestants).swap(contestants);
138    STL    指针类型容器    下面的程序段，希望按字母顺序输出，有什么错误？
                        set&lt;string*&gt; ssp; // ssp = “set of string ptrs”
                        ssp.insert(new string(&quot;&quot;Anteater&quot;&quot;));
                        ssp.insert(new string(&quot;&quot;Wombat&quot;&quot;));
                        ssp.insert(new string(&quot;&quot;Lemur&quot;&quot;));
                        ssp.insert(new string(&quot;&quot;Penguin&quot;&quot;));

                        for (set&lt;string*&gt;::const_iterator i = ssp.begin(); i != ssp.end(); ++i) 
                           cout &lt;&lt; *i &lt;&lt; endl;   // 输出的是地址
139    STL    算法    请指出下面算法的问题：
                list&lt;double&gt; ld;
                ...
                double sum = accumulate(ld.begin(), Id.end(), 0); // 计算它们的和
140    STL    迭代器    请指出下面程序问题，应如何修改？
                deque&lt;double&gt;::iterator insertLocation = d.begin(); // 记下d的起始迭代器

                  // 在deque后面插入
                for (size_t i = 0; i &lt; numDoubles; ++i) { 
                    d.insert(insertLocation++, data[i] + 41);  
                } 
</code></pre></div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2016/05/28/Q-A-我的C-面试问题总结-Q/" data-id="ciww8soba00560nfy5g861ai9" class="article-share-link">分享到</a><div class="tags"><a href="/tags/Q-A/">Q&amp;A</a></div><div class="post-nav"><a href="/2016/05/28/Sip协议-sip协议库tid-did-tid-分析/" class="pre">sip协议库tid.did.tid 分析</a><a href="/2016/05/28/Sip协议-Sip协议关键点整理/" class="next">Sip协议关键点整理</a></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C-C-经验累积/">C&C++经验累积</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Docker学习/">Docker学习</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux使用/">Linux使用</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux内核学习/">Linux内核学习</a><span class="category-list-count">32</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux内核学习/基础篇/">基础篇</a><span class="category-list-count">24</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux内核学习/杂记/">杂记</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux内核学习/配置篇/">配置篇</a><span class="category-list-count">7</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux系统编程/">Linux系统编程</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux网络编程/">Linux网络编程</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Q-A/">Q&A</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Sip协议/">Sip协议</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux内核驱动与文件系统/">linux内核驱动与文件系统</a><span class="category-list-count">24</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/project-note/">project_note</a><span class="category-list-count">13</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/project-note/decode/">decode</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/project-note/think-about/">think_about</a><span class="category-list-count">4</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/开发环境搭建/">开发环境搭建</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂项/">杂项</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/渗透测试/">渗透测试</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/源码分析/">源码分析</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法学习/">算法学习</a><span class="category-list-count">19</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/系统性能/">系统性能</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/">阅读笔记</a><span class="category-list-count">258</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/C-11新特性/">C++11新特性</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/C-Templates/">C++Templates</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/C程序设计语言/">C程序设计语言</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/EffectiveC/">EffectiveC++</a><span class="category-list-count">50</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/EffectiveSTL/">EffectiveSTL</a><span class="category-list-count">51</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/InsideC-ObjectModel/">InsideC++ObjectModel</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/Linux多线程服务器编程/">Linux多线程服务器编程</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/Linux性能优化大师/">Linux性能优化大师</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/Linux设备驱动程序/">Linux设备驱动程序</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/MoreEffectiveC/">MoreEffectiveC++</a><span class="category-list-count">26</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/TCPIP详解Vol1/">TCPIP详解Vol1</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/TheC-StandardLibraryEd1/">TheC++StandardLibraryEd1</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/TheC-StandardLibraryEd2/">TheC++StandardLibraryEd2</a><span class="category-list-count">23</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/http权威指南/">http权威指南</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/unix网络编程Ed3/">unix网络编程Ed3</a><span class="category-list-count">28</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/wireshark数据包分析实战/">wireshark数据包分析实战</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/实战LinuxShell编程与服务器管理/">实战LinuxShell编程与服务器管理</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/程序员的自我修养/">程序员的自我修养</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/网络安全基础/">网络安全基础</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/面向模式的软件体系结构Vol1/">面向模式的软件体系结构Vol1</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/高级C-C-编译技术/">高级C&C++编译技术</a><span class="category-list-count">2</span></li></ul></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/InsideC-ObjectModel/" style="font-size: 15px;">InsideC++ObjectModel</a> <a href="/tags/C-C-经验累积/" style="font-size: 15px;">C&C++经验累积</a> <a href="/tags/Linux使用/" style="font-size: 15px;">Linux使用</a> <a href="/tags/Linux系统编程/" style="font-size: 15px;">Linux系统编程</a> <a href="/tags/Linux网络编程/" style="font-size: 15px;">Linux网络编程</a> <a href="/tags/Q-A/" style="font-size: 15px;">Q&A</a> <a href="/tags/Sip协议/" style="font-size: 15px;">Sip协议</a> <a href="/tags/linux内核驱动与文件系统/" style="font-size: 15px;">linux内核驱动与文件系统</a> <a href="/tags/开发环境搭建/" style="font-size: 15px;">开发环境搭建</a> <a href="/tags/杂项/" style="font-size: 15px;">杂项</a> <a href="/tags/算法学习/" style="font-size: 15px;">算法学习</a> <a href="/tags/渗透测试/" style="font-size: 15px;">渗透测试</a> <a href="/tags/源码分析/" style="font-size: 15px;">源码分析</a> <a href="/tags/系统性能/" style="font-size: 15px;">系统性能</a> <a href="/tags/阅读笔记/" style="font-size: 15px;">阅读笔记</a> <a href="/tags/Linux内核学习/" style="font-size: 15px;">Linux内核学习</a> <a href="/tags/decode/" style="font-size: 15px;">decode</a> <a href="/tags/think-about/" style="font-size: 15px;">think_about</a> <a href="/tags/C-11新特性/" style="font-size: 15px;">C++11新特性</a> <a href="/tags/Docker学习/" style="font-size: 15px;">Docker学习</a> <a href="/tags/C程序设计语言/" style="font-size: 15px;">C程序设计语言</a> <a href="/tags/C-Templates/" style="font-size: 15px;">C++Templates</a> <a href="/tags/EffectiveC/" style="font-size: 15px;">EffectiveC++</a> <a href="/tags/Linux多线程服务器编程/" style="font-size: 15px;">Linux多线程服务器编程</a> <a href="/tags/EffectiveSTL/" style="font-size: 15px;">EffectiveSTL</a> <a href="/tags/Linux性能优化大师/" style="font-size: 15px;">Linux性能优化大师</a> <a href="/tags/Linux设备驱动程序/" style="font-size: 15px;">Linux设备驱动程序</a> <a href="/tags/MoreEffectiveC/" style="font-size: 15px;">MoreEffectiveC++</a> <a href="/tags/TCPIP详解Vol1/" style="font-size: 15px;">TCPIP详解Vol1</a> <a href="/tags/TheC-StandardLibraryEd1/" style="font-size: 15px;">TheC++StandardLibraryEd1</a> <a href="/tags/TheC-StandardLibraryEd2/" style="font-size: 15px;">TheC++StandardLibraryEd2</a> <a href="/tags/http权威指南/" style="font-size: 15px;">http权威指南</a> <a href="/tags/wireshark数据包分析实战/" style="font-size: 15px;">wireshark数据包分析实战</a> <a href="/tags/unix网络编程Ed3/" style="font-size: 15px;">unix网络编程Ed3</a> <a href="/tags/实战LinuxShell编程与服务器管理/" style="font-size: 15px;">实战LinuxShell编程与服务器管理</a> <a href="/tags/网络安全基础/" style="font-size: 15px;">网络安全基础</a> <a href="/tags/程序员的自我修养/" style="font-size: 15px;">程序员的自我修养</a> <a href="/tags/高级C-C-编译技术/" style="font-size: 15px;">高级C&C++编译技术</a> <a href="/tags/面向模式的软件体系结构Vol1/" style="font-size: 15px;">面向模式的软件体系结构Vol1</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/12/14/linux内核学习-配置篇-Linux内核配置详解-七-——-Executable-file-formats-Emulations-可执行文件格式-仿真/">Linux内核配置详解(七) ——   Executable file formats / Emulations (可执行文件格式/仿真)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/12/linux内核学习-配置篇-Linux内核配置详解-六-——-Power-management-and-ACPI-options-电源管理和ACPI选项/">Linux内核配置详解(六) ——  Power management and ACPI options (电源管理和ACPI选项)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/10/linux内核学习-配置篇-Linux内核配置详解-五-——-Processor-type-and-features-中央处理器-CPU-类型及特性/">Linux内核配置详解(五) ——  Processor type and features(中央处理器(CPU)类型及特性)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/07/linux内核学习-配置篇-Linux内核配置详解-四-——-Enable-the-block-layer-块设备支持/">Linux内核配置详解(四) ——  Enable the block layer(块设备支持)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/04/linux内核学习-配置篇-Linux内核配置详解-三-——-Enable-loadable-module-support-可加载模块支持/">Linux内核配置详解(三) ——  Enable loadable module support(可加载模块支持)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/01/linux内核学习-配置篇-Linux内核配置详解-二-——-General-setup-常规设置/">Linux内核配置详解(二) —— General setup(常规设置)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/28/linux内核学习-杂记-Linux-Kernel-diff-3-x-to-4-x-—-Documents/">Linux Kernel diff 3.x to 4.x — Documents)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/28/linux内核学习-配置篇-Linux内核配置详解-一-——-main-主菜单/">Linux内核配置详解(一) —— main(主菜单)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/22/linux内核学习-基础篇-Linux内核初探-之-中断-三-——-工作队列和底半机制/">Linux内核初探 之 中断(三) —— 工作队列和底半机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/20/linux内核学习-基础篇-Linux内核初探-之-中断-二-——-底半处理/">Linux内核初探 之 中断(二) —— 底半处理</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://easy.ac.cn/" title="easy" target="_blank">easy</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">dupengair的blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>