<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="keep it simple, stupid"><title>Linux内核配置详解(五) ——  Processor type and features(中央处理器(CPU)类型及特性) | dupengair的blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/3.0.3/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Linux内核配置详解(五) ——  Processor type and features(中央处理器(CPU)类型及特性)</h1><a id="logo" href="/.">dupengair的blog</a><p class="description">日拱一卒 精而悟道</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Linux内核配置详解(五) ——  Processor type and features(中央处理器(CPU)类型及特性)</h1><div class="post-meta">Dec 10, 2016<span> | </span><span class="category"><a href="/categories/Linux内核学习/">Linux内核学习</a><a href="/categories/Linux内核学习/配置篇/">配置篇</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux内核配置详解-五-——-Processor-type-and-features-中央处理器-CPU-类型及特性"><span class="toc-number">1.</span> <span class="toc-text">Linux内核配置详解(五) ——  Processor type and features(中央处理器(CPU)类型及特性)</span></a></li></ol></div></div><div class="post-content"><p>##</p>
<h1 id="Linux内核配置详解-五-——-Processor-type-and-features-中央处理器-CPU-类型及特性"><a href="#Linux内核配置详解-五-——-Processor-type-and-features-中央处理器-CPU-类型及特性" class="headerlink" title="Linux内核配置详解(五) ——  Processor type and features(中央处理器(CPU)类型及特性)"></a>Linux内核配置详解(五) ——  Processor type and features(中央处理器(CPU)类型及特性)</h1><p>基于4.9.0-rc8，ARM-64，根据金步国《4.4内核配置选项简介》整理, @ 表示4.9版本内核无此选项</p>
<p>##</p>
<pre><code>|                            选项                                          |                  配置名                |               内容
--------------------------------------------------------------------------------------------------------------------------------------------------------------
   [*] DMA memory allocation support                                                       CONFIG_ZONE_DMA                            允许为寻址宽度不足32位的设备(也就是ISA和LPC总线设备)在物理内存的前16MB范围内(也就是传统上x86_32架构的ZONE_DMA区域)
                                                                                                                                    分配内存.不确定的选&quot;N&quot;,内核中若有其它驱动(主要是某些老旧的声卡)需要它会自动选中此项.[提示]LPC总线通常和主板上
                                                                                                                                    的南桥物理相连,通常连接了一系列的传统设备:BIOS,PS/2键盘,PS/2鼠标,软盘,并口设备,串口设备,某些集成声卡,
                                                                                                                                    TPM(可信平台模块),等等.[题外话]x86_64已经没有ZONE_HIGHMEM了                                                     
   [*] Symmetric multi-processing support                                               CONFIG_SMP                                SMP(对称多处理器)支持,如果你有多个CPU或者使用的是多核CPU就选上.                                            
   [*] Support x2apic                                                                   CONFIG_X86_X2APIC                         x2apic支持.具有这个特性的CPU可以使用32位的APIC ID(可以支持海量的CPU),并且可以使用MSR而不是mmio去访问 local APIC 
                                                                                                                                    (更加高效).可以通过&quot;grep x2apic /proc/cpuinfo&quot;命令检查你的CPU是否支持这个特性.注意:有时候还需要在BIOS中也开启
                                                                                                                                    此特性才真正生效.[提示]在虚拟机中,还需要VMM的支持(例如qemu-kvm).                                   
   [*] Enable MPS table                                                                 CONFIG_X86_MPPARSE                      如果是不支持acpi特性的古董级SMP系统就选上.但现今的64位系统早都已经支持acpi了,所以可以安全的关闭.                                            
   [*] Support for extended (non-PC) x86 platforms                                      CONFIG_X86_EXTENDED_PLATFORM            支持非标准的PC平台: Numascale NumaChip, ScaleMP vSMP, SGI Ultraviolet. 绝大多数人都遇不见这些平台.                                            
   [*] Numascale NumaChip                                                               CONFIG_X86_NUMACHIP                     Numascale NumaChip 平台支持                                            
   [ ] ScaleMP vSMP                                                                                                             ScaleMP vSMP 平台    
   [ ] SGI Ultraviolet                                                                                                          SGI Ultraviolet 平台    
   [ ] Goldfish (Virtual Platform)                                                                                                  
   [ ] Intel MID platform support                                                                                                   
   &lt; &gt; Mellanox Technologies platform support                                                                                       
 @ [*] Intel Low Power Subsystem Support                                                                                            
   [*] AMD ACPI2Platform devices support                                                CONFIG_X86_AMD_PLATFORM_DEVICE          为AMD Carrizo以及后继架构的I2C,UART,GPIO提供支持.                                                                    
   -*- Intel SoC IOSF Sideband support for SoC platforms                                CONFIG_IOSF_MBI                            为主打低功耗的Intel SoC平台CPU开启&quot;sideband&quot;寄存器访问支持.这些CPU包括:BayTrail,Braswell,Quark                                            
 @ [*]   Enable IOSF sideband access through debugfs                                                                                
   [*] Single-depth WCHAN output                                                         CONFIG_SCHED_OMIT_FRAME_POINTER         使用简化的 /proc/&lt;PID&gt;/wchan 值,禁用此选项会使用更加精确的wchan值(可以在&quot;ps -l&quot;结果的WCHAN域看到),但会轻微增加调度器消耗.                                                                                      
   [*] Linux guest support  ---&gt;                    
           --- Linux guest support                                                      CONFIG_HYPERVISOR_GUEST                 如果这个内核将在虚拟机里面运行就开启,否则就关闭.                                         
           [*]   Enable paravirtualization code                                         CONFIG_PARAVIRT                         半虚拟化(paravirtualization)支持.                                         
           [ ]     paravirt-ops debugging                                               CONFIG_PARAVIRT_DEBUG                   仅供调试.paravirt-ops是内核通用的半虚拟化接口.                                         
           [*]     Paravirtualization layer for spinlocks                               CONFIG_PARAVIRT_SPINLOCKS               半虚拟化的自旋锁支持.开启之后运行在虚拟机里的内核速度会加快,但是运行在物理CPU上的宿主内核运行效率会降低
                                                                                                                                    (最多可能会降低5%).请根据实际情况选择.                                         
 @         [ ]       Paravirt queued spinlock statistics                                                                         
           [*]     Xen guest support                                                    CONFIG_XEN                              Xen半虚拟化技术支持            
 @         [*]       Limit Xen pv-domain memory to 512GB                                                                         
           [ ]       Enable Xen debug and tuning parameters in debugfs                  CONFIG_XEN_DEBUG_FS                     为Xen在debugfs中输出各种统计信息和调整选项.对性能有严重影响.仅供调试.                    
 @         [*]       Support for running as a PVH guest                                                                          
           [*]     KVM Guest support (including kvmclock)                               CONFIG_KVM_GUEST                        KVM客户机支持(包括kvmclock).                 
 @         [*]       Enable debug information for KVM Guests in debugfs                                                          
           [ ]     Paravirtual steal time accounting                                     CONFIG_PARAVIRT_TIME_ACCOUNTING            允许进行更细粒度的 task steal time 统计.会造成性能的略微降低.仅在你确实需要的时候才开启.
       Processor family (Generic-x86-64)  ---&gt;                                                                                     处理器系列,请按照你实际使用的CPU选择.&quot;Generic-x86-64&quot;表示通用于所有x86-64平台,而不是针对特定类型的CPU进行优化.
           ( ) Opteron/Athlon64/Hammer/K8                   
           ( ) Intel P4 / older Netburst based Xeon         
           ( ) Core 2/newer Xeon                            
           ( ) Intel Atom                                   
           (X) Generic-x86-64       
   [*] Supported processor vendors  ---&gt;                                                                                          支持的CPU厂商,按实际情况选择.
           --- Supported processor vendors                                                             
           [*]   Support Intel processors                                                              
           [*]   Support AMD processors                                                                
           [*]   Support Centaur processors  
   [*] Enable DMI scanning                                                              CONFIG_DMI                              允许扫描DMI(Desktop Management Interface)/SMBIOS(System Management BIOS)以获得机器的硬件配置,
                                                                                                                                    从而对已知的bug bios进行规避.具体涉及到哪些机器可参见&quot;drivers/acpi/blacklist.c&quot;文件.
                                                                                                                                    除非确定你的机器没有bug,否则请开启此项.                                                                                                        
   [*] Old AMD GART IOMMU support                                                       CONFIG_GART_IOMMU                       为较旧的AMD Athlon64/Opteron/Turion/Sempron CPU提供GART IOMMU支持.图形地址重映射表
                                                                                                                                    (Graphics Address Remapping Table)可以将物理地址不连续的系统内存映射成看上去连续的图形内存交给GPU使用,
                                                                                                                                    是一种挖CPU内存补GPU内存机制,这种机制也可以被认为是一种&quot;伪IOMMU&quot;(缺乏地址空间隔离和访问控制).
                                                                                                                                    开启此选项以后,在内存大于3G的系统上,传统的32位总线(PCI/AGP)的设备将可以使用完全DMA的方式直接访问
                                                                                                                                    原本超出32位寻址范围之外的系统内存区域.具体方法是:通过编程让设备在受GART控制的显存区域工作,
                                                                                                                                    然后使用GART将这个地址映射为真实的物理地址(4GB以上)来实现的.USB/声卡/IDE/SATA之类的设备常常需要它.
                                                                                                                                    开启此选项之后,除非同时开启了CONFIG_IOMMU_DEBUG选项或者使用了&quot;iommu=force&quot;内核引导参数,
                                                                                                                                    否则此特性仅在条件满足的情况下(内存足够大且确有支持GART的设备)激活.由于较新的AMD CPU都已配备了AMD IOMMU
                                                                                                                                    (应该使用CONFIG_AMD_IOMMU),故而仅建议在内存大于3G的老式AMD系统上选&quot;Y&quot;.                                            
   [*] IBM Calgary IOMMU support                                                        CONFIG_CALGARY_IOMMU                    IBM xSeries/pSeries 系列服务器的 Calgary IOMMU 支持.                                            
   [*]   Should Calgary be enabled by default?                                          CONFIG_CALGARY_IOMMU_ENABLED_BY_DEFAULT 开启此选项表示默认启用Calgary特性,关闭此选项表示默认禁用Calgary特性(可以使用&quot;iommu=calgary&quot;内核引导参数开启).                                            
   [ ] Enable Maximum number of SMP Processors and NUMA Nodes                           CONFIG_MAXSMP                           让内核支持x86_64平台所能支持的最大SMP处理器数量和最大NUMA节点数量.主要用于调试目的.                                            
   (256) Maximum number of CPUs                                                         CONFIG_NR_CPUS                          支持的最大CPU数量,每个CPU要占8KB的内核镜像,最小有效值是&quot;2&quot;,最大有效值是&quot;512&quot;.注意:这里的&quot;CPU数量&quot;是指&quot;逻辑CPU数量&quot;.
                                                                                                                                    例如,对于一颗带有超线程技术的4核8线程CPU来说,相当于拥有8个CPU.                                            
   [*] SMT (Hyperthreading) scheduler support                                           CONFIG_SCHED_SMT                        Intel超线程技术(HyperThreading)支持.                                            
   [*] Multi-core scheduler support                                                     CONFIG_SCHED_MC                         针对多核CPU进行调度策略优化                                            
       Preemption Model (Voluntary Kernel Preemption (Desktop))  ---&gt;                                                           内核抢占模式    
           ( ) No Forced Preemption (Server)                                            CONFIG_PREEMPT_NONE                     禁止内核抢占,这是Linux的传统模式,可以得到最大的吞吐量,适合服务器和科学计算环境      
           (X) Voluntary Kernel Preemption (Desktop)                                    CONFIG_PREEMPT_VOLUNTARY                自愿内核抢占,通过在内核中设置明确的抢占点以允许明确的内核抢占,可以提高响应速度,但是对吞吐量有不利影响.适合普通桌面环境      
           ( ) Preemptible Kernel (Low-Latency Desktop)                                 CONFIG_PREEMPT                          主动内核抢占,允许抢占所有内核代码,对吞吐量有更大影响,适合需要运行实时程序的场合或者追求最快响应速度的桌面环境.      
   [*] Reroute for broken boot IRQs                                                     CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS 这是一个对某些芯片组bug(在某些情况下会发送多余的&quot;boot IRQ&quot;)的修复功能.开启此选项之后,仅对有此bug的芯片组生效.
                                                                                                                                    要检查哪些芯片组有此bug可以查看&quot;drivers/pci/quirks.c&quot;文件中                                            
   [*] Machine Check / overheating reporting                                            CONFIG_X86_MCE                          MCE(Machine Check Exception)支持.让CPU检测到硬件故障(过热/数据错误)时通知内核,以便内核采取相应的措施
                                                                                                                                    (如显示一条提示信息或关机等).更多信息可以&quot;manmcelog&quot;看看.可以通过&quot;grep mce /proc/cpuinfo&quot;检查CPU是否支持此特性,
                                                                                                                                    若支持建议选中,否则请关闭.当然,如果你对自己的硬件质量很放心,又是桌面系统的话,不选也无所谓.                                            
   [*]   Intel MCE features                                                             CONFIG_X86_MCE_INTEL                    Intel CPU 支持                                            
   [*]   AMD MCE features                                                               CONFIG_X86_MCE_AMD                      AMD CPU 支持                                            
   &lt;M&gt; Machine check injector support                                                   CONFIG_X86_MCE_INJECT                   MCE注入支持,仅用于调试                         
       Performance monitoring  ---&gt;    
           &lt;*&gt; Intel uncore performance events                                                                   
           &lt;*&gt; Intel rapl performance events                                                                     
           &lt;*&gt; Intel cstate performance events                                                                   
           &lt; &gt; AMD Processor Power Reporting Mechanism                                                           
   [*] Enable support for 16-bit segments                                                 CONFIG_X86_VSYSCALL_EMULATION           对过时的vsyscall页提供仿真支持.禁用此项大致相当于使用&quot;vsyscall=none&quot;内核引导参数(差别在于当应用程序使用vsyscall时将
                                                                                                                                    直接崩溃(segfault)而不会产生警告消息).许多2013年之前编译的程序(也可能包括某些新近编译的程序)需要使用此特性.                                                                              
   [*] Enable vsyscall emulation                                                                                                    
   &lt;M&gt; Dell i8k legacy laptop support                                                   CONFIG_I8K                              Dell Inspiron 8000 笔记本的 System Management Mode 驱动(i8k).该驱动可以读取CPU温度和风扇转速,进而帮助上层工具控制
                                                                                                                                    风扇转速.该驱动仅针对 Dell Inspiron 8000 笔记本进行过测试,所以不保证一定能适用于其他型号的Dell笔记本.
   [*] CPU microcode loading support                                                    CONFIG_MICROCODE                        CPU的微代码更新支持,建议选中.CPU的微代码更新就像是给CPU打补丁,用于纠正CPU的行为.更新微代码的常规方法是升级BIOS,
                                                                                                                                    但是也可以在Linux启动后更新.比如在Gentoo下,可以使用&quot;emerge microcode-ctl&quot;安装microcode-ctl服务,再把这个服务
                                                                                                                                    加入boot运行级即可在每次开机时自动更新CPU微代码.其他Linux系统可以参考这个帖子.                                                
   [*]   Intel microcode loading support                                                CONFIG_MICROCODE_INTEL                    Intel CPU 微代码支持                                                  
   [*]   AMD microcode loading support                                                  CONFIG_MICROCODE_AMD                    AMD CPU                               
   &lt;M&gt; /dev/cpu/*/msr - Model-specific register support                                 CONFIG_X86_MSR                            允许用户空间的特权进程(使用rdmsr与wrmsr指令)访问x86的MSR寄存器(Model-Specific Register)以访问CPU的很多重要的参数.
                                                                                                                                    MSR是非标准寄存器,主要用于读取CPU的工作状态(频率/电压/功耗/温度/性能等),以及设置CPU的工作参数(触发特定的CPU特性,
                                                                                                                                    依CPU的不同而不同).msrtool工具可以转储出MSR的内容.不确定的可以选&quot;M&quot;.                                                 
   &lt;M&gt; /dev/cpu/*/cpuid - CPU information support                                       CONFIG_X86_CPUID                        允许用户空间的特权进程使用CPUID指令获得详细的CPU信息(CPUID):CPU类型,型号,制造商信息,商标信息,序列号,缓存等.不确定的可以选&quot;M&quot;.                                                  
   [*] Numa Memory Allocation and Scheduler Support                                     CONFIG_NUMA                             开启 NUMA(Non Uniform Memory Access) 支持.虽然说集成了内存控制器的CPU都属于NUMA架构.但事实上,对于大多数只有一颗物理CPU的
                                                                                                                                    个人电脑而言,即使支持NUMA架构,也没必要开启此特性.可以参考SMP/NUMA/MPP体系结构对比.此外,对于不支持&quot;虚拟NUMA&quot;,
                                                                                                                                    或&quot;虚拟NUMA&quot;被禁用的虚拟机(即使所在的物理机是NUMA系统),也应该关闭此项.                                                 
   [*]   Old style AMD Opteron NUMA detection                                           CONFIG_AMD_NUMA                            因为AMD使用一种旧式的方法读取NUMA配置信息(新式方法是CONFIG_X86_64_ACPI_NUMA),所以如果你使用的是AMD多核CPU,建议开启.
                                                                                                                                    不过,即使开启此选项,内核也会优先尝试CONFIG_X86_64_ACPI_NUMA方法,仅在失败后才会使用此方法,
                                                                                                                                    所以即使你不能确定CPU的类型也可以安全的选中此项                                                 
   [*]   ACPI NUMA detection                                                            CONFIG_X86_64_ACPI_NUMA                 使用基于 ACPI SRAT(System Resource Affinity Table) 技术的NUMA节点探测方法.这也是检测NUMA节点信息的首选方法,建议选中.                                
   [ ]   NUMA emulation                                                                 CONFIG_NUMA_EMU                            仅供开发调试使用                                                 
   (6) Maximum NUMA Nodes (as a power of 2)                                             CONFIG_NODES_SHIFT                        允许的最大NUMA节点数.需要注意其计算方法:最大允许节点数=2CONFIG_NODES_SHIFT.也就是说这里设置的值会被当做2的指数使用.
                                                                                                                                    取值范围是[1,10],也就最多允许1024个节点.                                                 
 @ [*] Enable sysfs memory/probe interface                                                                                               
       Memory model (Sparse Memory)  ---&gt;                                                                                        内存模式.&quot;Sparse Memory&quot;主要用来支持内存热插拔,相比其他两个旧有的内存模式,代码复杂性也比较低,而且还拥有一些性能上的优势,
                                                                                                                                    对某些架构而言是唯一的可选项.其他两个旧有的内存模式是:&quot;Discontiguous Memory&quot;和&quot;Flat Memory&quot;.                                                                                
            (X) Sparse Memory
   [*] Sparse Memory virtual memmap                                                      CONFIG_SPARSEMEM_VMEMMAP                对于64位CPU而言,开启此选项可以简化pfn_to_page/page_to_pfn的操作,从而提高内核的运行效率.但是在32位平台则建议关闭.
   [*] Enable to assign a node which has only movable memory                            CONFIG_MOVABLE_NODE                        允许对一个完整的NUMA节点(CPU和对应的内存)进行热插拔.一般的服务器和个人电脑不需要这么高级的特性.                                                 
   [*] Allow for memory hot-add                                                         CONFIG_MEMORY_HOTPLUG                    支持向运行中的系统添加内存.也就是内存热插支持.                                                    
 @ [ ]   Online the newly added memory blocks by default                                                                                    
   [*]   Allow for memory hot remove                                                     CONFIG_MEMORY_HOTREMOVE                    支持从运行中的系统移除内存.也就是内存热拔支持.                                                                                               
   [*] Allow for balloon memory compaction/migration                                    CONFIG_BALLOON_COMPACTION                允许规整/合并泡状内存(balloon memory).内存的Ballooning技术是指虚拟机在运行时动态地调整它所占用的宿主机内存资源,
                                                                                                                                    该技术在节约内存和灵活分配内存方面有明显的优势,目前所有主流虚拟化方案都支持这项技术(前提是客户机操作系统中
                                                                                                                                    必须安装有相应的balloon驱动).由于内存的动态增加和减少会导致内存过度碎片化,特别是对于2M尺寸的连续大内存页
                                                                                                                                    来说更加严重,从而严重降低内存性能.允许balloon内存压缩和迁移可以很好的解决在客户机中使用大内存页时内存过度碎片化问题.
                                                                                                                                    如果你打算在虚拟机中使用大内存页(huge page),那么建议开启,否则建议关闭                                                    
   -*- Allow for memory compaction                                                      CONFIG_COMPACTION                       允许对大内存页(huge pages)进行规整.主要是为了解决大内存页的碎片问题.建议在使用大内存页的情况下开启此项,否则建议关闭.                             
   -*-   Page migration                                                                 CONFIG_MIGRATION                        允许在保持虚拟内存页地址不变的情况下移动其所对应的物理内存页的位置.这主要是为了解决两个问题:
                                                                                                                                    (1)在NUMA系统上,将物理内存转移到相应的节点上,以加快CPU与内存之间的访问速度.(2)在分配大内存页的时候,可以避免碎片问题.                                                    
   [*] Enable bounce buffers                                                            CONFIG_BOUNCE                            为那些不能直接访问所有内存范围的驱动程序开启bounce buffer支持.当CONFIG_ZONE_DMA被开启后,这个选项会被默认开启
                                                                                                                                    (当然,你也可以在这里手动关闭).这主要是为了那些不具备IOMMU功能的PCI/ISA设备而设,但它对性能有些不利影响.
                                                                                                                                    在支持IOMMU的设备上,应该关闭它而是用IOMMU来代替.                                                    
   [*] Enable KSM for page merging                                                      CONFIG_KSM                                KSM(Kernel Samepage Merging)支持:周期性的扫描那些被应用程序标记为&quot;可合并&quot;的地址空间,一旦发现有内容完全相同的页面,
                                                                                                                                    就将它们合并为同一个页面,这样就可以节约内存的使用,但对性能有不利影响.推荐和内核虚拟机KVM(Documentation/vm/ksm.txt)
                                                                                                                                    或者其他支持&quot;MADV_MERGEABLE&quot;特性的应用程序一起使用.KSM并不默认开启,仅在应用程序设置了&quot;MADV_MERGEABLE&quot;标记,
                                                                                                                                    并且 /sys/kernel/mm/ksm/run 被设为&quot;1&quot;的情况下才会生效.                                                    
   (65536) Low address space to protect from user allocation                            CONFIG_DEFAULT_MMAP_MIN_ADDR            2009年,内核曾经爆过一个严重的NULL指针漏洞,由于其根源是将NULL指针映射到地址&quot;0&quot;所致,所以从2.6.32版本以后,
                                                                                                                                    为了防止此类漏洞再次造成严重后果,特别设置了此选项,用于指定受保护的内存低端地址范围(可以在系统运行时通过 
                                                                                                                                    /proc/sys/vm/mmap_min_addr 进行调整),这个范围内的地址禁止任何用户态程序的写入,
                                                                                                                                    以从根本上堵死此类漏洞可能对系统造成的损害.但内核这种强加的限制,对于需要使用vm86系统调用
                                                                                                                                    (用于在保护模式的进程中模拟8086的实模式)或者需要映射此低端地址空间的程序(bitbake,dosemu,qemu,wine,...)来说,
                                                                                                                                    则会造成不兼容,不过目前这些程序的新版本都进行了改进,以适应内核的这种保护.一般情况下,
                                                                                                                                    &quot;4096&quot;是个明智的选择,或者你也可以保持默认值.                                                    
   [*] Enable recovery from hardware memory errors                                      CONFIG_MEMORY_FAILURE                    在具备MCA(Machine Check Architecture)恢复机制的系统上,允许内核在物理内存中的发生数据错误的情况下,
                                                                                                                                    依然坚强的纠正错误并恢复正常运行.这需要有相应的硬件(通常是ECC内存)支持.有ECC内存的选,没有的就别选了.                                                    
   &lt;M&gt;   HWPoison pages injector                                                        CONFIG_HWPOISON_INJECT                    仅用于调试.                                                    
   [*] Transparent Hugepage Support                                                     CONFIG_TRANSPARENT_HUGEPAGE                大多数现代计算机体系结构都支持多种不同的内存页面大小(比如x86_64支持4K和2M以及1G[需要cpu-flags中含有&quot;pdpe1gb&quot;]).
                                                                                                                                    大于4K的内存页被称为&quot;大页&quot;(Hugepage).TLB(页表缓存)是位于CPU内部的分页表(虚拟地址到物理地址的映射表)缓冲区,
                                                                                                                                    既高速又很宝贵(尺寸很小).如果系统内存很大(大于4G)又使用4K的内存页,那么分页表将会变得很大而难以在CPU内缓存,
                                                                                                                                    从而导致较高的TLB不命中概率,进而降低系统的运行效率.开启大内存页支持之后,就可以使用大页(2M或1G),
                                                                                                                                    从而大大缩小分页表的尺寸以大幅提高TLB的命中率,进而优化系统性能.传统上使用大内存页的方法是通过Hugetlbfs
                                                                                                                                    虚拟文件系统(CONFIG_HUGETLBFS),但是hugetlbfs需要专门进行配置以及应用程序的特别支持.所以从2.6.38版本开始
                                                                                                                                    引入了THP(Transparent Hugepages),目标是替代先前的Hugetlbfs虚拟文件系统(CONFIG_HUGETLBFS).THP允许内核在
                                                                                                                                    可能的条件下,透明的(对应用程序来说)使用大页(huge pages)与HugeTLB,THP不像hugetlbfs那样需要专门进行配置
                                                                                                                                    以及应用程序的特别支持.THP将这一切都交给操作系统来完成,也不再需要额外的配置,对于应用程序完全透明,
                                                                                                                                    因而可用于更广泛的应用程序.这对于数据库/KVM等需要使用大量内存的应用来说,可以提升其效能,但对于内存较小
                                                                                                                                    (4G或更少)的个人PC来说就没啥必要了.详见&quot;Documentation/vm/transhuge.txt&quot;文档                                                    
         Transparent Hugepage Support sysfs defaults (always)  ---&gt;                                                                设置 /sys/kernel/mm/transparent_hugepage/enabled 文件的默认值.&quot;always&quot;表示总是对所有应用程序启用透明大内存页支持,
                                                                                                                                    &quot;madvise&quot;表示仅对明确要求该特性的程序启用.建议选&quot;always&quot;.
                (X) always                   
                ( ) madvise   
   [*] Enable cleancache driver to cache clean pages if tmem is present                 CONFIG_CLEANCACHE                       Cleancache是内核VFS层新增的特性,可以被看作是内存页的&quot;Victim Cache&quot;(受害者缓存),当回收内存页时,先不把它清空,
                                                                                                                                    而是把其加入到内核不能直接访问的&quot;transcendent memory&quot;中,这样支持Cleancache的文件系统再次访问这个页时
                                                                                                                                    可以直接从&quot;transcendent memory&quot;加载它,从而减少磁盘IO的损耗.目前只有zcache和XEN支持&quot;transcendent memory&quot;,
                                                                                                                                    不过将来会有越来越多的应用支持.开启此项后即使此特性不能得到利用,也仅对性能有微小的影响,所以建议开启.
                                                                                                                                    更多细节请参考&quot;Documentation/vm/cleancache.txt&quot;文件.                             
   [*] Enable frontswap to cache swap pages if tmem is present                          CONFIG_FRONTSWAP                        Frontswap是和Cleancache非常类似的东西,在传统的swap前加一道内存缓冲(同样位于&quot;transcendent memory&quot;中).
                                                                                                                                    目的也是减少swap时的磁盘读写.CONFIG_ZSWAP依赖于它,建议开启.                                                    
   [*] Contiguous Memory Allocator                                                      CONFIG_CMA                              这是一个分配连续物理内存页面的分配器.一些比较低端的DMA设备只能访问连续的物理内存,同时透明大内存页
                                                                                                                                    也需要连续的物理内存.传统的解决办法是在系统启动时,在内存还很充足的时候,先预留一部分连续物理内存页面,
                                                                                                                                    留作后用,但这部分内存就无法被挪作他用了,为了可能的分配需求,预留这么一大块内存,并不是一个明智的方法.
                                                                                                                                    而连续内存分配器(Contiguous Memory Allocator)可以做到允许这部分预留的内存被正常使用,
                                                                                                                                    仅在确实需要的时候才将大块的连续物理内存分配给相应的驱动程序.这个机制对于那些不支持I/O map和scatter-gather
                                                                                                                                    的设备很有作用.详情参见&quot;include/linux/dma-contiguous.h&quot;文件.此选项仅对嵌入式系统有意义,不确定的选&quot;N&quot;.                       
 @ [ ]   CMA debug messages (DEVELOPMENT)                                                                                                   
 @ [ ]   CMA debugfs interface                                                                                                              
 @ (7)   Maximum count of the CMA areas                                                                                                    
   [*] Track memory changes                                                             CONFIG_MEM_SOFT_DIRTY                    在内核页表的PTE(Page Table Entry)数据结构上添加一个&quot;soft-dirty&quot;位以追踪内存页内容的变化.此特性基本上专用于CRIU
                                                                                                                                    (Checkpoint/Restore In Userspace)项目(可以帮助容器进行热迁移).不确定的选&quot;N&quot;.                                                 
   [*] Compressed cache for swap pages (EXPERIMENTAL)                                   CONFIG_ZSWAP                            ZSWAP是一个放置在swap前面的压缩缓存,它可以将需要换出的页压缩存放在内存中的压缩池里,这样在压缩池没有满的时候,
                                                                                                                                    可以避免使用真正的swap设备.当压缩池满的时候,则把最老的页解压后写入swap设备.压缩池默认是内存总量的20%
                                                                                                                                    (/sys/module/zswap/parameters/max_pool_percent).ZSWAP不仅提升了swap的整体性能,也变相的增加了swap空间.
                                                                                                                                    选中此项后,可以通过&quot;zswap.enabled=1&quot;内核引导参数开启此功能.                                                 
   -*- Common API for compressed memory storage                                         CONFIG_ZPOOL                            通用的内存压缩API,主要用于给zbud(zswap)或zsmalloc提供支持.不确定的选&quot;N&quot;,如果内核有其他选项依赖于它会自动选中                                                 
   &lt;*&gt; Low (Up to 2x) density storage for compressed pages                              CONFIG_ZBUD                             专用于zswap内部的低密度内存压缩API,最多允许将两个物理内存页压缩为一个压缩内存页,这既有优势
                                                                                                                                    (简单的空间收集及空闲空间复用)也有劣势(潜在的低内存利用率).
                                                                                                                                    此种算法还能确保压缩后的内存页不会比最初未压缩页数多.不确定的选&quot;N&quot;.                    
 @ &lt; &gt; Up to 3x density storage for compressed pages                                                                                    
   &lt;*&gt; Memory allocator for compressed pages                                            CONFIG_ZSMALLOC                            zsmalloc压缩内存分配器主要用于给zram提供支持,建议与CONFIG_ZRAM同开关.参考:3种内存压缩方案对比.                                                                      
   [*]   Use page table mapping to access object in zsmalloc                            CONFIG_PGTABLE_MAPPING                    zsmalloc默认使用基于内存复制的对象映射方法来访问跨越不同页面的区域,但如果某些架构(例如ARM)
                                                                                                                                    执行虚拟内存映射的速度快于内存复制,那么应该将此项选&quot;Y&quot;,这将导致zsmalloc使用页表映射
                                                                                                                                    而不是内存复制来进行对象的映射.你可以在你的系统上使用&quot;https://github.com/spartacus06/zsmapbench&quot;
                                                                                                                                    脚本来测试这两种方法的速度差异.在x86_64平台上,Debian8与Fedora22与openSUSE13此项默认为&quot;N&quot;,
                                                                                                                                    而Ubuntu15此项默认为&quot;Y&quot;,作者本人未测试过哪个更合理.                                                                         
 @ [ ]   Export zsmalloc statistics                                                                                                      
 @ [ ] Defer initialisation of struct pages to kthreads                                                                                  
   [ ] Enable idle page tracking                                                        CONFIG_IDLE_PAGE_TRACKING               此特性跟踪哪些用户页面需要被工作负载使用,哪些用户页面处于闲置状态.此信息(/sys/kernel/mm/page_idle)
                                                                                                                                    可用于确定工作负载需要的用户内存大小.从而帮助调优内存cgroup限制以及决定将此任务放置到集群中的
                                                                                                                                    那台机器上.参见Documentation/vm/idle_page_tracking.txt文档.不确定的选&quot;N&quot;.                                  
 @ [ ] Device memory (pmem, etc...) hotplug support                                                                                      
   &lt;*&gt; Support non-standard NVDIMMs and ADR protected memory                            CONFIG_X86_PMEM_LEGACY                    支持 Intel Sandy Bridge-EP 处理器使用的不符合NVDIMM规范的非易失内存(以电容做后备电力且掉电后
                                                                                                                                    不会丢失数据的内存).仅有某些高端服务器才会使用这种外带电容供电的内存.                                                 
   [*] Check for low memory corruption                                                  CONFIG_X86_CHECK_BIOS_CORRUPTION        低位内存脏数据检查,即使开启此选项,默认也不会开启此功能(需要明确使用&quot;memory_corruption_check=1&quot;
                                                                                                                                    内核引导选项).这些脏数据通常被认为是有bug的BIOS引起的,默认每60秒(可以通过memory_corruption_check_period
                                                                                                                                    内核参数进行调整)扫描一次0-64k(可以通过memory_corruption_check_size内核参数进行调整)之间的区域.
                                                                                                                                    这种检查所占用的开销非常小,基本可以忽略不计.如果始终检查到错误,则可以通过&quot;memmap=&quot;内核引导参数
                                                                                                                                    来避免使用这段内存.一般没必要选中,如果你对BIOS不放心,带着它试运行一段时间,确认没问题之后再去掉.                                                 
   [*]   Set the default setting of memory_corruption_check                             CONFIG_X86_BOOTPARAM_MEMORY_CORRUPTION_CHECK
                                                                                                                                设置memory_corruption_check的默认值,选中表示默认开启(相当于使用&quot;memory_corruption_check=1&quot;内核引导选项),
                                                                                                                                    不选中表示默认关闭.
   (64) Amount of low memory, in kilobytes, to reserve for the BIOS                     CONFIG_X86_RESERVE_LOW                    为BIOS设置保留的低端地址(默认是64K).内存的第一页(4K)存放的必定是BIOS数据,内核不能使用,所以必须要保留.
                                                                                                                                    但是有许多BIOS还会在suspend/resume/热插拔等事件发生的时候使用更多的页(一般在0-64K范围),所以默认
                                                                                                                                    保留0-64K范围.如果你确定自己的BIOS不会越界使用内存的话,可以设为&quot;4&quot;,否则请保持默认值.但是也有一些
                                                                                                                                    很奇葩的BIOS会使用更多的低位内存,这种情况下可以考虑设为&quot;640&quot;以保留所有640K的低位内存区域.                                                    
   [*] MTRR (Memory Type Range Register) support                                        CONFIG_MTRR                                MTRR(Memory type range registers)是CPU内的一组MSR(Model-specific registers),其作用是告诉CPU以哪种模式
                                                                                                                                    (write-back/uncachable)存取各内存区段效率最高.这对于AGP/PCI显卡意义重大,因为write-combining技术
                                                                                                                                    可以将若干个总线写传输捆绑成一次较大的写传输操作,可以将图像写操作的性能提高2.5倍或者更多.
                                                                                                                                    这段代码有着通用的接口,其他CPU的寄存器同样能够使用该功能.简而言之,开启此选项是个明智的选择.                                                    
   [*]   MTRR cleanup support                                                           CONFIG_MTRR_SANITIZER                                                                        
   (1)     MTRR cleanup enable value (0-1)                                              CONFIG_MTRR_SANITIZER_ENABLE_DEFAULT    &quot;1&quot;表示默认开启CONFIG_MTRR_SANITIZER特性,相当于使用&quot;enable_mtrr_cleanup&quot;,&quot;0&quot;表示默认关闭
                                                                                                                                    CONFIG_MTRR_SANITIZER特性,相当于使用&quot;disable_mtrr_cleanup&quot;.建议设为&quot;1&quot;.                                                    
   (1)     MTRR cleanup spare reg num (0-7)                                             CONFIG_MTRR_SANITIZER_SPARE_REG_NR_DEFAULT
                                                                                                                                这里设定的值等价于使用内核引导参数&quot;mtrr_spare_reg_nr=N&quot;中的&quot;N&quot;.也就是告诉内核reg0N可以被清理或改写
                                                                                                                                    (参见&quot;/proc/mtrr&quot;文件).在多数情况下默认值是&quot;1&quot;,其含义是 /proc/mtrr 中的 reg01 将会被映射.
                                                                                                                                    一般保持其默认值即可.修改此项的值通常是为了解决某些MTRR故障.
   [*]   x86 PAT support                                                                CONFIG_X86_PAT                            PAT(Page Attribute Table)是对MTRR的补充,且比MTRR更灵活.如果你的CPU支持PAT(grep pat /proc/cpuinfo),
                                                                                                                                    那么建议开启.仅在开启后导致无法正常启动或者显卡驱动不能正常工作的情况下才需要关闭.                                                    
   [*] x86 architectural random number generator                                        CONFIG_ARCH_RANDOM                        Intel 从 Ivy Bridge 微架构开始(对于Atom来说是从Silvermont开始),在CPU中集成了一个高效的硬件随机数生成器
                                                                                                                                    (称为&quot;Bull Mountain&quot;技术),并引入了一个新的x86指令&quot;RDRAND&quot;,可以非常高效的产生随机数.
                                                                                                                                    此选项就是对此特性的支持.                                                    
   [*] Supervisor Mode Access Prevention                                                CONFIG_X86_SMAP                            SMAP(Supervisor Mode Access Prevention)是Intel从Haswell微架构开始引入的一种新特征,它在CR4寄存器上引入
                                                                                                                                    一个新标志位SMAP,如果这个标志为1,内核访问用户进程的地址空间时就会触发一个页错误,目的是为了防止内核
                                                                                                                                    因为自身错误意外访问用户空间,这样就可以避免一些内核漏洞所导致的安全问题.但是由于内核在有些时候仍然
                                                                                                                                    需要访问用户空间,因此intel提供了两条指令STAC和CLAC用于临时打开/关闭这个功能,反复使用STAC和CLAC会
                                                                                                                                    带来一些轻微的性能损失,但考虑到增加的安全性,还是建议开启.                                                    
   [*] Intel MPX (Memory Protection Extensions)                                         CONFIG_X86_INTEL_MPX                    Intel MPX(内存保护扩展)是一种用于检测缓冲区溢出bug的硬件特性.此选项并非用于保护内核自身,而是用于允许
                                                                                                                                    应用程序利用MPX特性.可以通过&quot;grep mpx /proc/cpuinfo&quot;检查你的CPU是否支持MPX特性.
                                                                                                                                    详见Documentation/x86/intel_mpx.txt文档.不确定的选&quot;N&quot;.                                                    
 @ [*] Intel Memory Protection Keys                                                                                                         
   [*] EFI runtime service support                                                      CONFIG_EFI                                EFI/UEFI支持.如果你打算在UEFI/EFI平台上安装Linux(2010年之后的机器基本都已经是UEFI规格了),那么就必须
                                                                                                                                    开启此项(开启后也依然可以在传统的BIOS机器上启动).UEFI启动流程与传统的BIOS相差很大.虽然Linux受到
                                                                                                                                    了所谓&quot;安全启动&quot;问题的阻挠(已经解决),但是UEFI依然将迅速一统江湖.[提示]在UEFI平台上安装Linux的
                                                                                                                                    关键之一是首先要用一个支持UEFI启动的LiveCD以UEFI模式启动机器.                                                    
   [*]   EFI stub support                                                               CONFIG_EFI_STUB                            EFI stub 支持.如果开启此项,就可以不通过GRUB2之类的引导程序来加载内核,而直接由EFI固件进行加载,
                                                                                                                                    这样就可以不必安装引导程序了.不过这是一个看上去很美的特性,由于EFI固件灵活性比GRUB2差许多,
                                                                                                                                    所以缺点有三:(1)不能在传统的BIOS机器上启动.(2)给内核传递引导参数很麻烦(需要使用&quot;efibootmgr -u&quot;).
                                                                                                                                    (3)不能使用intrd.不过,针对后两点的解决办法是:使用CONFIG_CMDLINE和CONFIG_INITRAMFS_SOURCE.
                                                                                                                                    更多细节可参考&quot;Documentation/x86/efi-stub.txt&quot;文档.                                                  
   [*]     EFI mixed-mode support                                                       CONFIG_EFI_MIXED                        允许在32位固件上启动64位内核.选&quot;N&quot;.                            
   [*] Enable seccomp to safely compute untrusted bytecode                              CONFIG_SECCOMP                            允许使用SECCOMP技术安全地运算非信任代码.通过使用管道或其他进程可用的通信方式作为文件描述符
                                                                                                                                    (支持读/写调用),就可以利用SECCOMP把这些应用程序隔离在它们自己的地址空间.这是一种有效的
                                                                                                                                    安全沙盒技术.systemd也强烈建议开启它.除非你是嵌入式系统,否则不要关闭.                                                    
       Timer frequency (250 HZ)  ---&gt;                                                                                              内核时钟频率.对于要求快速响应的场合,比如桌面环境,建议使用1000Hz,而对于不需要快速响应的
                                                                                                                                    SMP/NUMA服务器,建议使用250Hz或100Hz或300Hz(主要处理多媒体数据).
        ( ) 100 HZ                                                                                                                                       
       (X) 250 HZ                       
       ( ) 300 HZ                     
       ( ) 1000 HZ      
   [*] kexec system call                                                                CONFIG_KEXEC                            提供kexec系统调用,可以不必重启而切换到另一个内核(不一定必须是Linux内核),不过这个特性并不总是那么可靠.
                                                                                                                                    如果你不确定是否需要它,那么就是不需要                                                                            
 @ [*] kexec file based system call                                                                                                         
 @ [*]   Verify kernel signature during kexec_file_load() syscall                                                                           
   [*] kernel crash dumps                                                               CONFIG_CRASH_DUMP                          当内核崩溃时自动导出运行时信息的功能,主要用于调试目的.更多信息请参考&quot;Documentation/kdump/kdump.txt&quot;文件.                                                   
   [*] kexec jump                                                                       CONFIG_KEXEC_JUMP                        kexec jump 支持.这是对CONFIG_KEXEC的增强功能,仅在你确实明白这是干啥的情况下再开启,否则请关闭.                                                    
   (0x1000000) Physical address where the kernel is loaded                              CONFIG_PHYSICAL_START                   加载内核的物理地址.如果内核不是可重定位的(CONFIG_RELOCATABLE=n),那么bzImage会将自己解压到该物理地址并
                                                                                                                                    从此地址开始运行,否则,bzImage将忽略此处设置的值,而从引导装载程序将其装入的物理地址开始运行.
                                                                                                                                    仅在你确实知道自己是在干什么的情况下才可以改变该值,否则请保持默认.                                 
   -*- Build a relocatable kernel                                                       CONFIG_RELOCATABLE                        使内核可以在浮动的物理内存位置加载,主要用于调试目的.仅在你确实知道为什么需要的时候再开启,否则请关闭.                                                    
 @ [*]   Randomize the address of the kernel image (KASLR)                                                                                  
 @ (0x1000000) Alignment value to which kernel should be aligned                                                                            
 @ [*] Randomize the kernel memory sections                                                                                                 
 @ (0xa) Physical memory mapping padding                                                                                                    
   -*- Support for hot-pluggable CPUs                                                   CONFIG_HOTPLUG_CPU                        热插拔CPU支持(通过 /sys/devices/system/cpu 进行控制).                                                    
   [ ]   Set default setting of cpu0_hotpluggable                                       CONFIG_BOOTPARAM_HOTPLUG_CPU0            开启/关闭此项的意思是设置&quot;cpu0_hotpluggable&quot;的默认值为&quot;on/off&quot;.开启此项表示默认将CPU0设置为允许热插拔.                                                    
   [ ]   Debug CPU0 hotplug                                                             CONFIG_DEBUG_HOTPLUG_CPU0                仅用于调试目的.                                                    
   [ ] Disable the 32-bit vDSO (needed for glibc 2.3.3)                                 CONFIG_COMPAT_VDSO                        是否将VDSO(Virtual Dynamic Shared Object)映射到旧式的确定性地址.如果Glibc版本大于等于2.3.3选&quot;N&quot;,否则就选&quot;Y&quot;.                                                    
       vsyscall table for legacy applications (Emulate)  ---&gt;                                                                     设置内核引导参数&quot;vsyscall=[native|emulate|none]&quot;的值.对于使用Glibc-2.14以上版本的系统来说,如果不需要使用特别
                                                                                                                                    老旧的静态二进制程序,应该将此项设为&quot;None&quot;以提升性能与安全性
       ( ) Native                         
       (X) Emulate                        
       ( ) None 
   [ ] Built-in kernel command line                                                     CONFIG_CMDLINE_BOOL                        将内核引导参数直接编进来.在无法向内核传递引导参数的情况下(比如在嵌入式系统上,或者想使用 EFI stub kernel),
                                                                                                                                    这就是唯一的救命稻草了.如果你使用grub之类的引导管理器,那么就可以不需要此特性.                                                    
   [*] Enable the LDT (local descriptor table)                                          CONFIG_MODIFY_LDT_SYSCALL               Linux允许用户空间的应用程序使用modify_ldt(2)系统调用针对每个CPU安装Local Descriptor Table (LDT).
                                                                                                                                    某些老旧的程序或者运行在DOSEMU/Wine中的程序需要使用此接口.不确定的选&quot;N&quot;(尤其是嵌入式系统与服务器).                                     
 @ [*] Kernel Live Patching                  
</code></pre></div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2016/12/10/linux内核学习-配置篇-Linux内核配置详解-五-——-Processor-type-and-features-中央处理器-CPU-类型及特性/" data-id="ciww70n5k00gl7ofyq2simnbz" class="article-share-link">分享到</a><div class="tags"><a href="/tags/Linux内核学习/">Linux内核学习</a></div><div class="post-nav"><a href="/2016/12/12/linux内核学习-配置篇-Linux内核配置详解-六-——-Power-management-and-ACPI-options-电源管理和ACPI选项/" class="pre">Linux内核配置详解(六) ——  Power management and ACPI options (电源管理和ACPI选项)</a><a href="/2016/12/07/linux内核学习-配置篇-Linux内核配置详解-四-——-Enable-the-block-layer-块设备支持/" class="next">Linux内核配置详解(四) ——  Enable the block layer(块设备支持)</a></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C-C-经验累积/">C&C++经验累积</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Docker学习/">Docker学习</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux使用/">Linux使用</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux内核学习/">Linux内核学习</a><span class="category-list-count">32</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux内核学习/基础篇/">基础篇</a><span class="category-list-count">24</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux内核学习/杂记/">杂记</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux内核学习/配置篇/">配置篇</a><span class="category-list-count">7</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux系统编程/">Linux系统编程</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux网络编程/">Linux网络编程</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Q-A/">Q&A</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Sip协议/">Sip协议</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux内核驱动与文件系统/">linux内核驱动与文件系统</a><span class="category-list-count">24</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/project-note/">project_note</a><span class="category-list-count">13</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/project-note/decode/">decode</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/project-note/think-about/">think_about</a><span class="category-list-count">4</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/开发环境搭建/">开发环境搭建</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂项/">杂项</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/渗透测试/">渗透测试</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/源码分析/">源码分析</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法学习/">算法学习</a><span class="category-list-count">19</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/系统性能/">系统性能</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/">阅读笔记</a><span class="category-list-count">258</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/C-11新特性/">C++11新特性</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/C-Templates/">C++Templates</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/C程序设计语言/">C程序设计语言</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/EffectiveC/">EffectiveC++</a><span class="category-list-count">50</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/EffectiveSTL/">EffectiveSTL</a><span class="category-list-count">51</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/InsideC-ObjectModel/">InsideC++ObjectModel</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/Linux多线程服务器编程/">Linux多线程服务器编程</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/Linux性能优化大师/">Linux性能优化大师</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/Linux设备驱动程序/">Linux设备驱动程序</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/MoreEffectiveC/">MoreEffectiveC++</a><span class="category-list-count">26</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/TCPIP详解Vol1/">TCPIP详解Vol1</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/TheC-StandardLibraryEd1/">TheC++StandardLibraryEd1</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/TheC-StandardLibraryEd2/">TheC++StandardLibraryEd2</a><span class="category-list-count">23</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/http权威指南/">http权威指南</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/unix网络编程Ed3/">unix网络编程Ed3</a><span class="category-list-count">28</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/wireshark数据包分析实战/">wireshark数据包分析实战</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/实战LinuxShell编程与服务器管理/">实战LinuxShell编程与服务器管理</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/程序员的自我修养/">程序员的自我修养</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/网络安全基础/">网络安全基础</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/面向模式的软件体系结构Vol1/">面向模式的软件体系结构Vol1</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读笔记/高级C-C-编译技术/">高级C&C++编译技术</a><span class="category-list-count">2</span></li></ul></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/C-11新特性/" style="font-size: 15px;">C++11新特性</a> <a href="/tags/C-C-经验累积/" style="font-size: 15px;">C&C++经验累积</a> <a href="/tags/Linux使用/" style="font-size: 15px;">Linux使用</a> <a href="/tags/Linux系统编程/" style="font-size: 15px;">Linux系统编程</a> <a href="/tags/Linux网络编程/" style="font-size: 15px;">Linux网络编程</a> <a href="/tags/Q-A/" style="font-size: 15px;">Q&A</a> <a href="/tags/Sip协议/" style="font-size: 15px;">Sip协议</a> <a href="/tags/linux内核驱动与文件系统/" style="font-size: 15px;">linux内核驱动与文件系统</a> <a href="/tags/开发环境搭建/" style="font-size: 15px;">开发环境搭建</a> <a href="/tags/杂项/" style="font-size: 15px;">杂项</a> <a href="/tags/渗透测试/" style="font-size: 15px;">渗透测试</a> <a href="/tags/阅读笔记/" style="font-size: 15px;">阅读笔记</a> <a href="/tags/源码分析/" style="font-size: 15px;">源码分析</a> <a href="/tags/算法学习/" style="font-size: 15px;">算法学习</a> <a href="/tags/系统性能/" style="font-size: 15px;">系统性能</a> <a href="/tags/Linux内核学习/" style="font-size: 15px;">Linux内核学习</a> <a href="/tags/decode/" style="font-size: 15px;">decode</a> <a href="/tags/think-about/" style="font-size: 15px;">think_about</a> <a href="/tags/C-Templates/" style="font-size: 15px;">C++Templates</a> <a href="/tags/Docker学习/" style="font-size: 15px;">Docker学习</a> <a href="/tags/InsideC-ObjectModel/" style="font-size: 15px;">InsideC++ObjectModel</a> <a href="/tags/C程序设计语言/" style="font-size: 15px;">C程序设计语言</a> <a href="/tags/Linux性能优化大师/" style="font-size: 15px;">Linux性能优化大师</a> <a href="/tags/Linux设备驱动程序/" style="font-size: 15px;">Linux设备驱动程序</a> <a href="/tags/MoreEffectiveC/" style="font-size: 15px;">MoreEffectiveC++</a> <a href="/tags/Linux多线程服务器编程/" style="font-size: 15px;">Linux多线程服务器编程</a> <a href="/tags/TheC-StandardLibraryEd1/" style="font-size: 15px;">TheC++StandardLibraryEd1</a> <a href="/tags/TCPIP详解Vol1/" style="font-size: 15px;">TCPIP详解Vol1</a> <a href="/tags/EffectiveSTL/" style="font-size: 15px;">EffectiveSTL</a> <a href="/tags/http权威指南/" style="font-size: 15px;">http权威指南</a> <a href="/tags/EffectiveC/" style="font-size: 15px;">EffectiveC++</a> <a href="/tags/unix网络编程Ed3/" style="font-size: 15px;">unix网络编程Ed3</a> <a href="/tags/wireshark数据包分析实战/" style="font-size: 15px;">wireshark数据包分析实战</a> <a href="/tags/实战LinuxShell编程与服务器管理/" style="font-size: 15px;">实战LinuxShell编程与服务器管理</a> <a href="/tags/网络安全基础/" style="font-size: 15px;">网络安全基础</a> <a href="/tags/程序员的自我修养/" style="font-size: 15px;">程序员的自我修养</a> <a href="/tags/面向模式的软件体系结构Vol1/" style="font-size: 15px;">面向模式的软件体系结构Vol1</a> <a href="/tags/高级C-C-编译技术/" style="font-size: 15px;">高级C&C++编译技术</a> <a href="/tags/TheC-StandardLibraryEd2/" style="font-size: 15px;">TheC++StandardLibraryEd2</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/12/14/linux内核学习-配置篇-Linux内核配置详解-七-——-Executable-file-formats-Emulations-可执行文件格式-仿真/">Linux内核配置详解(七) ——   Executable file formats / Emulations (可执行文件格式/仿真)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/12/linux内核学习-配置篇-Linux内核配置详解-六-——-Power-management-and-ACPI-options-电源管理和ACPI选项/">Linux内核配置详解(六) ——  Power management and ACPI options (电源管理和ACPI选项)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/10/linux内核学习-配置篇-Linux内核配置详解-五-——-Processor-type-and-features-中央处理器-CPU-类型及特性/">Linux内核配置详解(五) ——  Processor type and features(中央处理器(CPU)类型及特性)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/07/linux内核学习-配置篇-Linux内核配置详解-四-——-Enable-the-block-layer-块设备支持/">Linux内核配置详解(四) ——  Enable the block layer(块设备支持)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/04/linux内核学习-配置篇-Linux内核配置详解-三-——-Enable-loadable-module-support-可加载模块支持/">Linux内核配置详解(三) ——  Enable loadable module support(可加载模块支持)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/01/linux内核学习-配置篇-Linux内核配置详解-二-——-General-setup-常规设置/">Linux内核配置详解(二) —— General setup(常规设置)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/28/linux内核学习-配置篇-Linux内核配置详解-一-——-main-主菜单/">Linux内核配置详解(一) —— main(主菜单)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/28/linux内核学习-杂记-Linux-Kernel-diff-3-x-to-4-x-—-Documents/">Linux Kernel diff 3.x to 4.x — Documents)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/22/linux内核学习-基础篇-Linux内核初探-之-中断-三-——-工作队列和底半机制/">Linux内核初探 之 中断(三) —— 工作队列和底半机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/20/linux内核学习-基础篇-Linux内核初探-之-中断-二-——-底半处理/">Linux内核初探 之 中断(二) —— 底半处理</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://easy.ac.cn/" title="easy" target="_blank">easy</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">dupengair的blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>